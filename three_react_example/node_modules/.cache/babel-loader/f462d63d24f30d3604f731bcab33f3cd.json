{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _realpathNative() {\n  const data = require('realpath-native');\n\n  _realpathNative = function _realpathNative() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _console() {\n  const data = require('@jest/console');\n\n  _console = function _console() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function _exit() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWatcher() {\n  const data = require('jest-watcher');\n\n  _jestWatcher = function _jestWatcher() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function _testResult() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _getNoTestsFoundMessage = _interopRequireDefault(require('./getNoTestsFoundMessage'));\n\nvar _runGlobalHook = _interopRequireDefault(require('./runGlobalHook'));\n\nvar _SearchSource = _interopRequireDefault(require('./SearchSource'));\n\nvar _TestScheduler = _interopRequireDefault(require('./TestScheduler'));\n\nvar _collectHandles = _interopRequireDefault(require('./collectHandles'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst getTestPaths =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(function* (globalConfig, context, outputStream, changedFiles, jestHooks, filter) {\n    const source = new _SearchSource.default(context);\n    const data = yield source.getTestPaths(globalConfig, changedFiles, filter);\n\n    if (!data.tests.length && globalConfig.onlyChanged && data.noSCM) {\n      new (_console().CustomConsole)(outputStream, outputStream).log('Jest can only find uncommitted changed files in a git or hg ' + 'repository. If you make your project a git or hg ' + 'repository (`git init` or `hg init`), Jest will be able ' + 'to only run tests related to files changed since the last ' + 'commit.');\n    }\n\n    const shouldTestArray = yield Promise.all(data.tests.map(test => jestHooks.shouldRunTestSuite({\n      config: test.context.config,\n      duration: test.duration,\n      testPath: test.path\n    })));\n    const filteredTests = data.tests.filter((_test, i) => shouldTestArray[i]);\n    return _objectSpread({}, data, {\n      allTests: filteredTests.length,\n      tests: filteredTests\n    });\n  });\n\n  return function getTestPaths(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst processResults = (runResults, options) => {\n  const outputFile = options.outputFile,\n        isJSON = options.json,\n        onComplete = options.onComplete,\n        outputStream = options.outputStream,\n        testResultsProcessor = options.testResultsProcessor,\n        collectHandles = options.collectHandles;\n\n  if (collectHandles) {\n    runResults.openHandles = collectHandles();\n  } else {\n    runResults.openHandles = [];\n  }\n\n  if (testResultsProcessor) {\n    runResults = require(testResultsProcessor)(runResults);\n  }\n\n  if (isJSON) {\n    if (outputFile) {\n      const cwd = (0, _realpathNative().sync)(process.cwd());\n\n      const filePath = _path().default.resolve(cwd, outputFile);\n\n      _gracefulFs().default.writeFileSync(filePath, JSON.stringify((0, _jestUtil().formatTestResults)(runResults)));\n\n      outputStream.write(\"Test results written to: \".concat(_path().default.relative(cwd, filePath), \"\\n\"));\n    } else {\n      process.stdout.write(JSON.stringify((0, _jestUtil().formatTestResults)(runResults)));\n    }\n  }\n\n  return onComplete && onComplete(runResults);\n};\n\nconst testSchedulerContext = {\n  firstRun: true,\n  previousSuccess: true\n};\n\nvar _default =\n/*#__PURE__*/\nfunction () {\n  var _runJest = _asyncToGenerator(function* ({\n    contexts,\n    globalConfig,\n    outputStream,\n    testWatcher,\n    jestHooks = new (_jestWatcher().JestHook)().getEmitter(),\n    startRun,\n    changedFilesPromise,\n    onComplete,\n    failedTestsCache,\n    filter\n  }) {\n    const Sequencer = (0, _jestUtil().interopRequireDefault)(require(globalConfig.testSequencer)).default;\n    const sequencer = new Sequencer();\n    let allTests = [];\n\n    if (changedFilesPromise && globalConfig.watch) {\n      const _ref2 = yield changedFilesPromise,\n            repos = _ref2.repos;\n\n      const noSCM = Object.keys(repos).every(scm => repos[scm].size === 0);\n\n      if (noSCM) {\n        process.stderr.write('\\n' + _chalk().default.bold('--watch') + ' is not supported without git/hg, please use --watchAll ' + '\\n');\n        (0, _exit().default)(1);\n      }\n    }\n\n    const testRunData = yield Promise.all(contexts.map(\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(function* (context) {\n        const matches = yield getTestPaths(globalConfig, context, outputStream, changedFilesPromise && (yield changedFilesPromise), jestHooks, filter);\n        allTests = allTests.concat(matches.tests);\n        return {\n          context,\n          matches\n        };\n      });\n\n      return function (_x8) {\n        return _ref3.apply(this, arguments);\n      };\n    }()));\n    allTests = yield sequencer.sort(allTests);\n\n    if (globalConfig.listTests) {\n      const testsPaths = Array.from(new Set(allTests.map(test => test.path)));\n\n      if (globalConfig.json) {\n        console.log(JSON.stringify(testsPaths));\n      } else {\n        console.log(testsPaths.join('\\n'));\n      }\n\n      onComplete && onComplete((0, _testResult().makeEmptyAggregatedTestResult)());\n      return null;\n    }\n\n    if (globalConfig.onlyFailures && failedTestsCache) {\n      allTests = failedTestsCache.filterTests(allTests);\n      globalConfig = failedTestsCache.updateConfig(globalConfig);\n    }\n\n    const hasTests = allTests.length > 0;\n\n    if (!hasTests) {\n      const noTestsFoundMessage = (0, _getNoTestsFoundMessage.default)(testRunData, globalConfig);\n\n      if (globalConfig.passWithNoTests || globalConfig.findRelatedTests || globalConfig.lastCommit || globalConfig.onlyChanged) {\n        new (_console().CustomConsole)(outputStream, outputStream).log(noTestsFoundMessage);\n      } else {\n        new (_console().CustomConsole)(outputStream, outputStream).error(noTestsFoundMessage);\n        (0, _exit().default)(1);\n      }\n    } else if (allTests.length === 1 && globalConfig.silent !== true && globalConfig.verbose !== false) {\n      const newConfig = _objectSpread({}, globalConfig, {\n        verbose: true\n      });\n\n      globalConfig = Object.freeze(newConfig);\n    }\n\n    let collectHandles;\n\n    if (globalConfig.detectOpenHandles) {\n      collectHandles = (0, _collectHandles.default)();\n    }\n\n    if (hasTests) {\n      yield (0, _runGlobalHook.default)({\n        allTests,\n        globalConfig,\n        moduleName: 'globalSetup'\n      });\n    }\n\n    if (changedFilesPromise) {\n      testSchedulerContext.changedFiles = (yield changedFilesPromise).changedFiles;\n    }\n\n    const results = yield new _TestScheduler.default(globalConfig, {\n      startRun\n    }, testSchedulerContext).scheduleTests(allTests, testWatcher);\n    sequencer.cacheResults(allTests, results);\n\n    if (hasTests) {\n      yield (0, _runGlobalHook.default)({\n        allTests,\n        globalConfig,\n        moduleName: 'globalTeardown'\n      });\n    }\n\n    return processResults(results, {\n      collectHandles,\n      json: globalConfig.json,\n      onComplete,\n      outputFile: globalConfig.outputFile,\n      outputStream,\n      testResultsProcessor: globalConfig.testResultsProcessor\n    });\n  });\n\n  function runJest(_x7) {\n    return _runJest.apply(this, arguments);\n  }\n\n  return runJest;\n}();\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}