{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst common = require('./common');\n\nconst platform = require('os').platform();\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Constants\n */\n\n\nconst DEFAULT_DELAY = common.DEFAULT_DELAY;\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n/**\n * Export `NodeWatcher` class.\n * Watches `dir`.\n *\n * @class NodeWatcher\n * @param {String} dir\n * @param {Object} opts\n * @public\n */\n\nmodule.exports = class NodeWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n    common.assignOptions(this, opts);\n    this.watched = Object.create(null);\n    this.changeTimers = Object.create(null);\n    this.dirRegistery = Object.create(null);\n    this.root = path.resolve(dir);\n    this.watchdir = this.watchdir.bind(this);\n    this.register = this.register.bind(this);\n    this.checkedEmitError = this.checkedEmitError.bind(this);\n    this.watchdir(this.root);\n    common.recReaddir(this.root, this.watchdir, this.register, this.emit.bind(this, 'ready'), this.checkedEmitError, this.ignored);\n  }\n  /**\n   * Register files that matches our globs to know what to type of event to\n   * emit in the future.\n   *\n   * Registery looks like the following:\n   *\n   *  dirRegister => Map {\n   *    dirpath => Map {\n   *       filename => true\n   *    }\n   *  }\n   *\n   * @param {string} filepath\n   * @return {boolean} whether or not we have registered the file.\n   * @private\n   */\n\n\n  register(filepath) {\n    let relativePath = path.relative(this.root, filepath);\n\n    if (!common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n      return false;\n    }\n\n    let dir = path.dirname(filepath);\n\n    if (!this.dirRegistery[dir]) {\n      this.dirRegistery[dir] = Object.create(null);\n    }\n\n    let filename = path.basename(filepath);\n    this.dirRegistery[dir][filename] = true;\n    return true;\n  }\n  /**\n   * Removes a file from the registery.\n   *\n   * @param {string} filepath\n   * @private\n   */\n\n\n  unregister(filepath) {\n    let dir = path.dirname(filepath);\n\n    if (this.dirRegistery[dir]) {\n      let filename = path.basename(filepath);\n      delete this.dirRegistery[dir][filename];\n    }\n  }\n  /**\n   * Removes a dir from the registery.\n   *\n   * @param {string} dirpath\n   * @private\n   */\n\n\n  unregisterDir(dirpath) {\n    if (this.dirRegistery[dirpath]) {\n      delete this.dirRegistery[dirpath];\n    }\n  }\n  /**\n   * Checks if a file or directory exists in the registery.\n   *\n   * @param {string} fullpath\n   * @return {boolean}\n   * @private\n   */\n\n\n  registered(fullpath) {\n    let dir = path.dirname(fullpath);\n    return this.dirRegistery[fullpath] || this.dirRegistery[dir] && this.dirRegistery[dir][path.basename(fullpath)];\n  }\n  /**\n   * Emit \"error\" event if it's not an ignorable event\n   *\n   * @param error\n   * @private\n   */\n\n\n  checkedEmitError(error) {\n    if (!isIgnorableFileError(error)) {\n      this.emit('error', error);\n    }\n  }\n  /**\n   * Watch a directory.\n   *\n   * @param {string} dir\n   * @private\n   */\n\n\n  watchdir(dir) {\n    if (this.watched[dir]) {\n      return;\n    }\n\n    let watcher = fs.watch(dir, {\n      persistent: true\n    }, this.normalizeChange.bind(this, dir));\n    this.watched[dir] = watcher;\n    watcher.on('error', this.checkedEmitError);\n\n    if (this.root !== dir) {\n      this.register(dir);\n    }\n  }\n  /**\n   * Stop watching a directory.\n   *\n   * @param {string} dir\n   * @private\n   */\n\n\n  stopWatching(dir) {\n    if (this.watched[dir]) {\n      this.watched[dir].close();\n      delete this.watched[dir];\n    }\n  }\n  /**\n   * End watching.\n   *\n   * @public\n   */\n\n\n  close(callback) {\n    Object.keys(this.watched).forEach(this.stopWatching, this);\n    this.removeAllListeners();\n\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n  /**\n   * On some platforms, as pointed out on the fs docs (most likely just win32)\n   * the file argument might be missing from the fs event. Try to detect what\n   * change by detecting if something was deleted or the most recent file change.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n\n  detectChangedFile(dir, event, callback) {\n    if (!this.dirRegistery[dir]) {\n      return;\n    }\n\n    let found = false;\n    let closest = {\n      mtime: 0\n    };\n    let c = 0;\n    Object.keys(this.dirRegistery[dir]).forEach(function (file, i, arr) {\n      fs.lstat(path.join(dir, file), function (error, stat) {\n        if (found) {\n          return;\n        }\n\n        if (error) {\n          if (isIgnorableFileError(error)) {\n            found = true;\n            callback(file);\n          } else {\n            this.emit('error', error);\n          }\n        } else {\n          if (stat.mtime > closest.mtime) {\n            stat.file = file;\n            closest = stat;\n          }\n\n          if (arr.length === ++c) {\n            callback(closest.file);\n          }\n        }\n      }.bind(this));\n    }, this);\n  }\n  /**\n   * Normalize fs events and pass it on to be processed.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n\n  normalizeChange(dir, event, file) {\n    if (!file) {\n      this.detectChangedFile(dir, event, function (actualFile) {\n        if (actualFile) {\n          this.processChange(dir, event, actualFile);\n        }\n      }.bind(this));\n    } else {\n      this.processChange(dir, event, path.normalize(file));\n    }\n  }\n  /**\n   * Process changes.\n   *\n   * @param {string} dir\n   * @param {string} event\n   * @param {string} file\n   * @public\n   */\n\n\n  processChange(dir, event, file) {\n    let fullPath = path.join(dir, file);\n    let relativePath = path.join(path.relative(this.root, dir), file);\n    fs.lstat(fullPath, function (error, stat) {\n      if (error && error.code !== 'ENOENT') {\n        this.emit('error', error);\n      } else if (!error && stat.isDirectory()) {\n        // win32 emits usless change events on dirs.\n        if (event !== 'change') {\n          this.watchdir(fullPath);\n\n          if (common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n            this.emitEvent(ADD_EVENT, relativePath, stat);\n          }\n        }\n      } else {\n        let registered = this.registered(fullPath);\n\n        if (error && error.code === 'ENOENT') {\n          this.unregister(fullPath);\n          this.stopWatching(fullPath);\n          this.unregisterDir(fullPath);\n\n          if (registered) {\n            this.emitEvent(DELETE_EVENT, relativePath);\n          }\n        } else if (registered) {\n          this.emitEvent(CHANGE_EVENT, relativePath, stat);\n        } else {\n          if (this.register(fullPath)) {\n            this.emitEvent(ADD_EVENT, relativePath, stat);\n          }\n        }\n      }\n    }.bind(this));\n  }\n  /**\n   * Triggers a 'change' event after debounding it to take care of duplicate\n   * events on os x.\n   *\n   * @private\n   */\n\n\n  emitEvent(type, file, stat) {\n    let key = type + '-' + file;\n    let addKey = ADD_EVENT + '-' + file;\n\n    if (type === CHANGE_EVENT && this.changeTimers[addKey]) {\n      // Ignore the change event that is immediately fired after an add event.\n      // (This happens on Linux).\n      return;\n    }\n\n    clearTimeout(this.changeTimers[key]);\n    this.changeTimers[key] = setTimeout(function () {\n      delete this.changeTimers[key];\n\n      if (type === ADD_EVENT && stat.isDirectory()) {\n        // Recursively emit add events and watch for sub-files/folders\n        common.recReaddir(path.resolve(this.root, file), function emitAddDir(dir, stats) {\n          this.watchdir(dir);\n          this.rawEmitEvent(ADD_EVENT, path.relative(this.root, dir), stats);\n        }.bind(this), function emitAddFile(file, stats) {\n          this.register(file);\n          this.rawEmitEvent(ADD_EVENT, path.relative(this.root, file), stats);\n        }.bind(this), function endCallback() {}, this.checkedEmitError, this.ignored);\n      } else {\n        this.rawEmitEvent(type, file, stat);\n      }\n    }.bind(this), DEFAULT_DELAY);\n  }\n  /**\n   * Actually emit the events\n   */\n\n\n  rawEmitEvent(type, file, stat) {\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n\n};\n/**\n * Determine if a given FS error can be ignored\n *\n * @private\n */\n\nfunction isIgnorableFileError(error) {\n  return error.code === 'ENOENT' || // Workaround Windows node issue #4337.\n  error.code === 'EPERM' && platform === 'win32';\n}","map":null,"metadata":{},"sourceType":"script"}