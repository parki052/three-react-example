{"ast":null,"code":"const path = require('path');\n\nconst glob = require('glob');\n\nconst minimatch = require('minimatch');\n\nconst readPkgUp = require('read-pkg-up');\n\nconst requireMainFilename = require('require-main-filename');\n\nclass TestExclude {\n  constructor(opts) {\n    Object.assign(this, {\n      cwd: process.cwd(),\n      include: false,\n      relativePath: true,\n      configKey: null,\n      // the key to load config from in package.json.\n      configPath: null,\n      // optionally override requireMainFilename.\n      configFound: false,\n      excludeNodeModules: true,\n      extension: false\n    }, opts);\n\n    if (typeof this.include === 'string') {\n      this.include = [this.include];\n    }\n\n    if (typeof this.exclude === 'string') {\n      this.exclude = [this.exclude];\n    }\n\n    if (typeof this.extension === 'string') {\n      this.extension = [this.extension];\n    } else if (!Array.isArray(this.extension) || this.extension.length === 0) {\n      this.extension = false;\n    }\n\n    if (!this.include && !this.exclude && this.configKey) {\n      Object.assign(this, this.pkgConf(this.configKey, this.configPath));\n    }\n\n    if (!this.exclude || !Array.isArray(this.exclude)) {\n      this.exclude = exportFunc.defaultExclude;\n    }\n\n    if (this.include && this.include.length > 0) {\n      this.include = prepGlobPatterns([].concat(this.include));\n    } else {\n      this.include = false;\n    }\n\n    if (this.excludeNodeModules && !this.exclude.includes('**/node_modules/**')) {\n      this.exclude = this.exclude.concat('**/node_modules/**');\n    }\n\n    this.exclude = prepGlobPatterns([].concat(this.exclude));\n    this.handleNegation();\n  }\n  /* handle the special case of negative globs\n   * (!**foo/bar); we create a new this.excludeNegated set\n   * of rules, which is applied after excludes and we\n   * move excluded include rules into this.excludes.\n   */\n\n\n  handleNegation() {\n    const noNeg = e => e.charAt(0) !== '!';\n\n    const onlyNeg = e => e.charAt(0) === '!';\n\n    const stripNeg = e => e.slice(1);\n\n    if (Array.isArray(this.include)) {\n      const includeNegated = this.include.filter(onlyNeg).map(stripNeg);\n      this.exclude.push(...prepGlobPatterns(includeNegated));\n      this.include = this.include.filter(noNeg);\n    }\n\n    this.excludeNegated = this.exclude.filter(onlyNeg).map(stripNeg);\n    this.exclude = this.exclude.filter(noNeg);\n    this.excludeNegated = prepGlobPatterns(this.excludeNegated);\n  }\n\n  shouldInstrument(filename, relFile) {\n    if (this.extension && !this.extension.some(ext => filename.endsWith(ext))) {\n      return false;\n    }\n\n    let pathToCheck = filename;\n\n    if (this.relativePath) {\n      relFile = relFile || path.relative(this.cwd, filename); // Don't instrument files that are outside of the current working directory.\n\n      if (/^\\.\\./.test(path.relative(this.cwd, filename))) {\n        return false;\n      }\n\n      pathToCheck = relFile.replace(/^\\.[\\\\/]/, ''); // remove leading './' or '.\\'.\n    }\n\n    const dot = {\n      dot: true\n    };\n\n    const matches = pattern => minimatch(pathToCheck, pattern, dot);\n\n    return (!this.include || this.include.some(matches)) && (!this.exclude.some(matches) || this.excludeNegated.some(matches));\n  }\n\n  pkgConf(key, path) {\n    const cwd = path || requireMainFilename(require);\n    const obj = readPkgUp.sync({\n      cwd\n    });\n\n    if (obj.pkg && obj.pkg[key] && typeof obj.pkg[key] === 'object') {\n      this.configFound = true;\n      return obj.pkg[key];\n    }\n\n    return {};\n  }\n\n  globSync(cwd = this.cwd) {\n    const globPatterns = getExtensionPattern(this.extension || []);\n    const globOptions = {\n      cwd,\n      nodir: true,\n      dot: true\n    };\n    /* If we don't have any excludeNegated then we can optimize glob by telling\n     * it to not iterate into unwanted directory trees (like node_modules). */\n\n    if (this.excludeNegated.length === 0) {\n      globOptions.ignore = this.exclude;\n    }\n\n    return glob.sync(globPatterns, globOptions).filter(file => this.shouldInstrument(path.resolve(cwd, file)));\n  }\n\n}\n\nfunction prepGlobPatterns(patterns) {\n  return patterns.reduce((result, pattern) => {\n    // Allow gitignore style of directory exclusion\n    if (!/\\/\\*\\*$/.test(pattern)) {\n      result = result.concat(pattern.replace(/\\/$/, '') + '/**');\n    } // Any rules of the form **/foo.js, should also match foo.js.\n\n\n    if (/^\\*\\*\\//.test(pattern)) {\n      result = result.concat(pattern.replace(/^\\*\\*\\//, ''));\n    }\n\n    return result.concat(pattern);\n  }, []);\n}\n\nfunction getExtensionPattern(extension) {\n  switch (extension.length) {\n    case 0:\n      return '**';\n\n    case 1:\n      return \"**/*\".concat(extension[0]);\n\n    default:\n      return \"**/*{\".concat(extension.join(), \"}\");\n  }\n}\n\nconst exportFunc = opts => new TestExclude(opts);\n\nconst devConfigs = ['ava', 'babel', 'jest', 'nyc', 'rollup', 'webpack'];\nexportFunc.defaultExclude = ['coverage/**', 'packages/*/test/**', 'test/**', 'test{,-*}.js', '**/*{.,-}test.js', '**/__tests__/**', \"**/{\".concat(devConfigs.join(), \"}.config.js\")];\nmodule.exports = exportFunc;","map":null,"metadata":{},"sourceType":"script"}