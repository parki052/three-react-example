{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst childProcess = require('child_process');\n\nconst crossSpawn = require('cross-spawn');\n\nconst stripEof = require('strip-eof');\n\nconst npmRunPath = require('npm-run-path');\n\nconst isStream = require('is-stream');\n\nconst _getStream = require('get-stream');\n\nconst pFinally = require('p-finally');\n\nconst onExit = require('signal-exit');\n\nconst errname = require('./lib/errname');\n\nconst stdio = require('./lib/stdio');\n\nconst TEN_MEGABYTES = 1000 * 1000 * 10;\n\nfunction handleArgs(cmd, args, opts) {\n  let parsed;\n  opts = Object.assign({\n    extendEnv: true,\n    env: {}\n  }, opts);\n\n  if (opts.extendEnv) {\n    opts.env = Object.assign({}, process.env, opts.env);\n  }\n\n  if (opts.__winShell === true) {\n    delete opts.__winShell;\n    parsed = {\n      command: cmd,\n      args,\n      options: opts,\n      file: cmd,\n      original: {\n        cmd,\n        args\n      }\n    };\n  } else {\n    parsed = crossSpawn._parse(cmd, args, opts);\n  }\n\n  opts = Object.assign({\n    maxBuffer: TEN_MEGABYTES,\n    buffer: true,\n    stripEof: true,\n    preferLocal: true,\n    localDir: parsed.options.cwd || process.cwd(),\n    encoding: 'utf8',\n    reject: true,\n    cleanup: true\n  }, parsed.options);\n  opts.stdio = stdio(opts);\n\n  if (opts.preferLocal) {\n    opts.env = npmRunPath.env(Object.assign({}, opts, {\n      cwd: opts.localDir\n    }));\n  }\n\n  if (opts.detached) {\n    // #115\n    opts.cleanup = false;\n  }\n\n  if (process.platform === 'win32' && path.basename(parsed.command) === 'cmd.exe') {\n    // #116\n    parsed.args.unshift('/q');\n  }\n\n  return {\n    cmd: parsed.command,\n    args: parsed.args,\n    opts,\n    parsed\n  };\n}\n\nfunction handleInput(spawned, input) {\n  if (input === null || input === undefined) {\n    return;\n  }\n\n  if (isStream(input)) {\n    input.pipe(spawned.stdin);\n  } else {\n    spawned.stdin.end(input);\n  }\n}\n\nfunction handleOutput(opts, val) {\n  if (val && opts.stripEof) {\n    val = stripEof(val);\n  }\n\n  return val;\n}\n\nfunction handleShell(fn, cmd, opts) {\n  let file = '/bin/sh';\n  let args = ['-c', cmd];\n  opts = Object.assign({}, opts);\n\n  if (process.platform === 'win32') {\n    opts.__winShell = true;\n    file = process.env.comspec || 'cmd.exe';\n    args = ['/s', '/c', \"\\\"\".concat(cmd, \"\\\"\")];\n    opts.windowsVerbatimArguments = true;\n  }\n\n  if (opts.shell) {\n    file = opts.shell;\n    delete opts.shell;\n  }\n\n  return fn(file, args, opts);\n}\n\nfunction getStream(process, stream, {\n  encoding,\n  buffer,\n  maxBuffer\n}) {\n  if (!process[stream]) {\n    return null;\n  }\n\n  let ret;\n\n  if (!buffer) {\n    // TODO: Use `ret = util.promisify(stream.finished)(process[stream]);` when targeting Node.js 10\n    ret = new Promise((resolve, reject) => {\n      process[stream].once('end', resolve).once('error', reject);\n    });\n  } else if (encoding) {\n    ret = _getStream(process[stream], {\n      encoding,\n      maxBuffer\n    });\n  } else {\n    ret = _getStream.buffer(process[stream], {\n      maxBuffer\n    });\n  }\n\n  return ret.catch(err => {\n    err.stream = stream;\n    err.message = \"\".concat(stream, \" \").concat(err.message);\n    throw err;\n  });\n}\n\nfunction makeError(result, options) {\n  const stdout = result.stdout,\n        stderr = result.stderr;\n  let err = result.error;\n  const code = result.code,\n        signal = result.signal;\n  const parsed = options.parsed,\n        joinedCmd = options.joinedCmd;\n  const timedOut = options.timedOut || false;\n\n  if (!err) {\n    let output = '';\n\n    if (Array.isArray(parsed.opts.stdio)) {\n      if (parsed.opts.stdio[2] !== 'inherit') {\n        output += output.length > 0 ? stderr : \"\\n\".concat(stderr);\n      }\n\n      if (parsed.opts.stdio[1] !== 'inherit') {\n        output += \"\\n\".concat(stdout);\n      }\n    } else if (parsed.opts.stdio !== 'inherit') {\n      output = \"\\n\".concat(stderr).concat(stdout);\n    }\n\n    err = new Error(\"Command failed: \".concat(joinedCmd).concat(output));\n    err.code = code < 0 ? errname(code) : code;\n  }\n\n  err.stdout = stdout;\n  err.stderr = stderr;\n  err.failed = true;\n  err.signal = signal || null;\n  err.cmd = joinedCmd;\n  err.timedOut = timedOut;\n  return err;\n}\n\nfunction joinCmd(cmd, args) {\n  let joinedCmd = cmd;\n\n  if (Array.isArray(args) && args.length > 0) {\n    joinedCmd += ' ' + args.join(' ');\n  }\n\n  return joinedCmd;\n}\n\nmodule.exports = (cmd, args, opts) => {\n  const parsed = handleArgs(cmd, args, opts);\n  const _parsed$opts = parsed.opts,\n        encoding = _parsed$opts.encoding,\n        buffer = _parsed$opts.buffer,\n        maxBuffer = _parsed$opts.maxBuffer;\n  const joinedCmd = joinCmd(cmd, args);\n  let spawned;\n\n  try {\n    spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  let removeExitHandler;\n\n  if (parsed.opts.cleanup) {\n    removeExitHandler = onExit(() => {\n      spawned.kill();\n    });\n  }\n\n  let timeoutId = null;\n  let timedOut = false;\n\n  const cleanup = () => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (removeExitHandler) {\n      removeExitHandler();\n    }\n  };\n\n  if (parsed.opts.timeout > 0) {\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      timedOut = true;\n      spawned.kill(parsed.opts.killSignal);\n    }, parsed.opts.timeout);\n  }\n\n  const processDone = new Promise(resolve => {\n    spawned.on('exit', (code, signal) => {\n      cleanup();\n      resolve({\n        code,\n        signal\n      });\n    });\n    spawned.on('error', err => {\n      cleanup();\n      resolve({\n        error: err\n      });\n    });\n\n    if (spawned.stdin) {\n      spawned.stdin.on('error', err => {\n        cleanup();\n        resolve({\n          error: err\n        });\n      });\n    }\n  });\n\n  function destroy() {\n    if (spawned.stdout) {\n      spawned.stdout.destroy();\n    }\n\n    if (spawned.stderr) {\n      spawned.stderr.destroy();\n    }\n  }\n\n  const handlePromise = () => pFinally(Promise.all([processDone, getStream(spawned, 'stdout', {\n    encoding,\n    buffer,\n    maxBuffer\n  }), getStream(spawned, 'stderr', {\n    encoding,\n    buffer,\n    maxBuffer\n  })]).then(arr => {\n    const result = arr[0];\n    result.stdout = arr[1];\n    result.stderr = arr[2];\n\n    if (result.error || result.code !== 0 || result.signal !== null) {\n      const err = makeError(result, {\n        joinedCmd,\n        parsed,\n        timedOut\n      }); // TODO: missing some timeout logic for killed\n      // https://github.com/nodejs/node/blob/master/lib/child_process.js#L203\n      // err.killed = spawned.killed || killed;\n\n      err.killed = err.killed || spawned.killed;\n\n      if (!parsed.opts.reject) {\n        return err;\n      }\n\n      throw err;\n    }\n\n    return {\n      stdout: handleOutput(parsed.opts, result.stdout),\n      stderr: handleOutput(parsed.opts, result.stderr),\n      code: 0,\n      failed: false,\n      killed: false,\n      signal: null,\n      cmd: joinedCmd,\n      timedOut: false\n    };\n  }), destroy);\n\n  crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);\n\n  handleInput(spawned, parsed.opts.input);\n\n  spawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected);\n\n  spawned.catch = onrejected => handlePromise().catch(onrejected);\n\n  return spawned;\n}; // TODO: set `stderr: 'ignore'` when that option is implemented\n\n\nmodule.exports.stdout = (...args) => module.exports(...args).then(x => x.stdout); // TODO: set `stdout: 'ignore'` when that option is implemented\n\n\nmodule.exports.stderr = (...args) => module.exports(...args).then(x => x.stderr);\n\nmodule.exports.shell = (cmd, opts) => handleShell(module.exports, cmd, opts);\n\nmodule.exports.sync = (cmd, args, opts) => {\n  const parsed = handleArgs(cmd, args, opts);\n  const joinedCmd = joinCmd(cmd, args);\n\n  if (isStream(parsed.opts.input)) {\n    throw new TypeError('The `input` option cannot be a stream in sync mode');\n  }\n\n  const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);\n  result.code = result.status;\n\n  if (result.error || result.status !== 0 || result.signal !== null) {\n    const err = makeError(result, {\n      joinedCmd,\n      parsed\n    });\n\n    if (!parsed.opts.reject) {\n      return err;\n    }\n\n    throw err;\n  }\n\n  return {\n    stdout: handleOutput(parsed.opts, result.stdout),\n    stderr: handleOutput(parsed.opts, result.stderr),\n    code: 0,\n    failed: false,\n    signal: null,\n    cmd: joinedCmd,\n    timedOut: false\n  };\n};\n\nmodule.exports.shellSync = (cmd, opts) => handleShell(module.exports.sync, cmd, opts);","map":null,"metadata":{},"sourceType":"script"}