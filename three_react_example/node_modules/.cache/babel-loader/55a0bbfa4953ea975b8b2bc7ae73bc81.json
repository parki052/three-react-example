{"ast":null,"code":"'use strict';\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _snapshot_resolver = require('./snapshot_resolver');\n\nvar _State = _interopRequireDefault(require('./State'));\n\nvar _plugins = require('./plugins');\n\nvar _print = require('./print');\n\nvar utils = _interopRequireWildcard(require('./utils'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestExistsFile = global[Symbol.for('jest-native-exists-file')] || _fs.default.existsSync;\n\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\n\nconst NOT_SNAPSHOT_MATCHERS = \".\".concat((0, _jestMatcherUtils.BOLD_WEIGHT)('not'), \" cannot be used with snapshot matchers\");\nconst HINT_ARG = 'hint';\nconst HINT_COLOR = _jestMatcherUtils.BOLD_WEIGHT;\nconst INLINE_SNAPSHOT_ARG = 'snapshot';\nconst PROPERTY_MATCHERS_ARG = 'properties';\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m; // Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\n\nconst printName = (concatenatedBlockNames = '', hint = '', count) => {\n  const hasNames = concatenatedBlockNames.length !== 0;\n  const hasHint = hint.length !== 0;\n  return '`' + (hasNames ? utils.escapeBacktickString(concatenatedBlockNames) : '') + (hasNames && hasHint ? ': ' : '') + (hasHint ? (0, _jestMatcherUtils.BOLD_WEIGHT)(utils.escapeBacktickString(hint)) : '') + ' ' + count + '`';\n};\n\nfunction stripAddedIndentation(inlineSnapshot) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].substr(indentation.length);\n    }\n  } // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n\n\n  lines[lines.length - 1] = ''; // Return inline snapshot, now at indent 0.\n\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath, hasteFS) => hasteFS.exists(filePath) || jestExistsFile(filePath);\n\nconst cleanup = (hasteFS, update, snapshotResolver, testPathIgnorePatterns) => {\n  const pattern = '\\\\.' + _snapshot_resolver.EXTENSION + '$';\n  const files = hasteFS.matchFiles(pattern);\n  let testIgnorePatternsRegex = null;\n\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile); // ignore snapshots of ignored tests\n\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, hasteFS)) {\n      if (update === 'all') {\n        _fs.default.unlinkSync(snapshotFile);\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list\n  };\n};\n\nconst toMatchSnapshot = function toMatchSnapshot(received, propertyMatchers, hint) {\n  const matcherName = 'toMatchSnapshot';\n  let expectedArgument = '';\n  let secondArgument = '';\n\n  if (typeof propertyMatchers === 'object' && propertyMatchers !== null) {\n    expectedArgument = PROPERTY_MATCHERS_ARG;\n\n    if (typeof hint === 'string' && hint.length !== 0) {\n      secondArgument = HINT_ARG;\n    }\n  } else if (typeof propertyMatchers === 'string' && propertyMatchers.length !== 0) {\n    expectedArgument = HINT_ARG;\n  }\n\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument\n  };\n\n  if (expectedArgument === HINT_ARG) {\n    options.expectedColor = HINT_COLOR;\n  }\n\n  if (secondArgument === HINT_ARG) {\n    options.secondArgumentColor = HINT_COLOR;\n  }\n\n  if (arguments.length === 3 && !propertyMatchers) {\n    throw new Error('Property matchers must be an object.\\n\\nTo provide a snapshot test name without property matchers, use: toMatchSnapshot(\"name\")');\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    expectedArgument,\n    hint,\n    matcherName,\n    options,\n    propertyMatchers,\n    received\n  });\n};\n\nconst toMatchInlineSnapshot = function toMatchInlineSnapshot(received, propertyMatchersOrInlineSnapshot, inlineSnapshot) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let expectedArgument = '';\n  let secondArgument = '';\n\n  if (typeof propertyMatchersOrInlineSnapshot === 'string') {\n    expectedArgument = INLINE_SNAPSHOT_ARG;\n  } else if (typeof propertyMatchersOrInlineSnapshot === 'object' && propertyMatchersOrInlineSnapshot !== null) {\n    expectedArgument = PROPERTY_MATCHERS_ARG;\n\n    if (typeof inlineSnapshot === 'string') {\n      secondArgument = INLINE_SNAPSHOT_ARG;\n    }\n  }\n\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument\n  };\n  let propertyMatchers;\n\n  if (typeof propertyMatchersOrInlineSnapshot === 'string') {\n    inlineSnapshot = propertyMatchersOrInlineSnapshot;\n  } else {\n    propertyMatchers = propertyMatchersOrInlineSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    expectedArgument,\n    inlineSnapshot: stripAddedIndentation(inlineSnapshot || ''),\n    matcherName,\n    options,\n    propertyMatchers,\n    received\n  });\n};\n\nconst _toMatchSnapshot = ({\n  context,\n  expectedArgument,\n  hint,\n  inlineSnapshot,\n  matcherName,\n  options,\n  propertyMatchers,\n  received\n}) => {\n  context.dontThrow && context.dontThrow();\n  hint = typeof propertyMatchers === 'string' ? propertyMatchers : hint;\n  const currentTestName = context.currentTestName,\n        isNot = context.isNot,\n        snapshotState = context.snapshotState;\n\n  if (isNot) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + NOT_SNAPSHOT_MATCHERS);\n  }\n\n  if (!snapshotState) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\nsnapshot state must be initialized');\n  }\n\n  const fullTestName = currentTestName && hint ? \"\".concat(currentTestName, \": \").concat(hint) : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof propertyMatchers === 'object') {\n    if (propertyMatchers === null) {\n      throw new Error(\"Property matchers must be an object.\");\n    }\n\n    const propertyPass = context.equals(received, propertyMatchers, [context.utils.iterableEquality, context.utils.subsetEquality]);\n\n    if (!propertyPass) {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const report = () => \"Snapshot name: \".concat(printName(currentTestName, hint, count), \"\\n\") + '\\n' + \"Expected properties: \".concat(context.utils.printExpected(propertyMatchers), \"\\n\") + \"Received value:      \".concat(context.utils.printReceived(received));\n\n      return {\n        message: () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + report(),\n        name: matcherName,\n        pass: false,\n        report\n      };\n    } else {\n      received = utils.deepMerge(received, propertyMatchers);\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    received,\n    testName: fullTestName\n  });\n  const count = result.count,\n        pass = result.pass;\n  let actual = result.actual,\n      expected = result.expected;\n  let report;\n\n  if (pass) {\n    return {\n      message: () => '',\n      pass: true\n    };\n  } else if (!expected) {\n    report = () => \"New snapshot was \".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('not written'), \". The update flag \") + \"must be explicitly passed to write a new snapshot.\\n\\n\" + \"This is likely because this test is run in a continuous integration \" + \"(CI) environment in which snapshots are not written by default.\\n\\n\" + \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('Received value'), \" \") + \"\".concat(actual);\n  } else {\n    expected = (expected || '').trim();\n    actual = (actual || '').trim(); // Assign to local variable because of declaration let expected:\n    // TypeScript thinks it could change before report function is called.\n\n    const printed = (0, _print.printDiffOrStringified)(expected, actual, received, 'Snapshot', 'Received', snapshotState.expand);\n\n    report = () => \"Snapshot name: \".concat(printName(currentTestName, hint, count), \"\\n\\n\") + printed;\n  } // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n\n\n  return {\n    actual,\n    expected,\n    message: () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + report(),\n    name: matcherName,\n    pass: false,\n    report\n  };\n};\n\nconst toThrowErrorMatchingSnapshot = function toThrowErrorMatchingSnapshot(received, hint, // because error TS1016 for hint?: string\nfromPromise) {\n  const matcherName = 'toThrowErrorMatchingSnapshot';\n  const expectedArgument = typeof hint === 'string' && hint.length !== 0 ? HINT_ARG : '';\n  const options = {\n    expectedColor: HINT_COLOR,\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: ''\n  };\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    expectedArgument,\n    hint,\n    matcherName,\n    options,\n    received\n  }, fromPromise);\n};\n\nconst toThrowErrorMatchingInlineSnapshot = function toThrowErrorMatchingInlineSnapshot(received, inlineSnapshot, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n  const expectedArgument = typeof inlineSnapshot === 'string' ? INLINE_SNAPSHOT_ARG : '';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: ''\n  };\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    expectedArgument,\n    inlineSnapshot: inlineSnapshot || '',\n    matcherName,\n    options,\n    received\n  }, fromPromise);\n};\n\nconst _toThrowErrorMatchingSnapshot = ({\n  context,\n  expectedArgument,\n  inlineSnapshot,\n  matcherName,\n  options,\n  received,\n  hint\n}, fromPromise) => {\n  context.dontThrow && context.dontThrow();\n  const isNot = context.isNot;\n\n  if (isNot) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + NOT_SNAPSHOT_MATCHERS);\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error === undefined) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + DID_NOT_THROW);\n  }\n\n  return _toMatchSnapshot({\n    context,\n    expectedArgument,\n    hint,\n    inlineSnapshot,\n    matcherName,\n    options,\n    received: error.message\n  });\n};\n\nconst JestSnapshot = {\n  EXTENSION: _snapshot_resolver.EXTENSION,\n  SnapshotState: _State.default,\n  addSerializer: _plugins.addSerializer,\n  buildSnapshotResolver: _snapshot_resolver.buildSnapshotResolver,\n  cleanup,\n  getSerializers: _plugins.getSerializers,\n  isSnapshotPath: _snapshot_resolver.isSnapshotPath,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n  utils\n};\n/* eslint-disable-next-line no-redeclare */\n\nmodule.exports = JestSnapshot;","map":null,"metadata":{},"sourceType":"script"}