{"ast":null,"code":"'use strict';\n\nconst argsert = require('./argsert');\n\nconst objFilter = require('./obj-filter');\n\nconst specialKeys = ['$0', '--', '_']; // validation-type-stuff, missing params,\n// bad implications, custom checks.\n\nmodule.exports = function validation(yargs, usage, y18n) {\n  const __ = y18n.__;\n  const __n = y18n.__n;\n  const self = {}; // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands(); // don't count currently executing commands\n\n    const _s = argv._.length - yargs.getContext().commands.length;\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail( // replace $0 with observed, $1 with expected.\n          demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.min) : null);\n        } else {\n          usage.fail(__('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail( // replace $0 with observed, $1 with expected.\n          demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.max) : null);\n        } else {\n          usage.fail(__('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max));\n        }\n      }\n    }\n  }; // validate the appropriate # of <required>\n  // positional arguments were provided:\n\n\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__('Not enough non-option arguments: got %s, need at least %s', observed, required));\n    }\n  }; // make sure all the required arguments are present.\n\n\n  self.requiredArguments = function requiredArguments(argv) {\n    const demandedOptions = yargs.getDemandedOptions();\n    let missing = null;\n    Object.keys(demandedOptions).forEach(key => {\n      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    });\n\n    if (missing) {\n      const customMsgs = [];\n      Object.keys(missing).forEach(key => {\n        const msg = missing[key];\n\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      });\n      const customMsg = customMsgs.length ? \"\\n\".concat(customMsgs.join('\\n')) : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  }; // check for unknown arguments (strict-mode).\n\n\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && !positionalMap.hasOwnProperty(key) && !yargs._getParseContext().hasOwnProperty(key) && !aliases.hasOwnProperty(key)) {\n        unknown.push(key);\n      }\n    });\n\n    if (commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  }; // validate arguments limited to enumerated choices\n\n\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach(value => {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n\n    let msg = __('Invalid values:');\n\n    invalidKeys.forEach(key => {\n      msg += \"\\n  \".concat(__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key])));\n    });\n    usage.fail(msg);\n  }; // custom checks, added using the `check` option on yargs.\n\n\n  let checks = [];\n\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global\n    });\n  };\n\n  self.customChecks = function customChecks(argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func;\n      let result = null;\n\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  }; // check implications, argument foo implies => argument bar.\n\n\n  let implied = {};\n\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        implied[key].push(value);\n      }\n    }\n  };\n\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let num;\n        let key = origKey;\n        const origValue = value; // convert string '1' to number 1\n\n        num = Number(key);\n        key = isNaN(num) ? key : num;\n\n        if (typeof key === 'number') {\n          // check length of argv._\n          key = argv._.length >= key;\n        } else if (key.match(/^--no-.+/)) {\n          // check if key doesn't exist\n          key = key.match(/^--no-(.+)/)[1];\n          key = !argv[key];\n        } else {\n          // check if key exists\n          key = argv[key];\n        }\n\n        num = Number(value);\n        value = isNaN(num) ? value : num;\n\n        if (typeof value === 'number') {\n          value = argv._.length >= value;\n        } else if (value.match(/^--no-.+/)) {\n          value = value.match(/^--no-(.+)/)[1];\n          value = !argv[value];\n        } else {\n          value = argv[value];\n        }\n\n        if (key && !value) {\n          implyFail.push(\" \".concat(origKey, \" -> \").concat(origValue));\n        }\n      });\n    });\n\n    if (implyFail.length) {\n      let msg = \"\".concat(__('Implications failed:'), \"\\n\");\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n\n  let conflicting = {};\n\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n\n  self.getConflicting = () => conflicting;\n\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          // we default keys to 'undefined' that have been configured, we should not\n          // apply conflicting check unless they are a value other than 'undefined'.\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n  };\n\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const distance = require('./levenshtein');\n\n    const threshold = 3; // if it takes more than three edits, let's move on.\n\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate);\n\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, (k, v) => !localLookup[k]);\n    conflicting = objFilter(conflicting, (k, v) => !localLookup[k]);\n    checks = checks.filter(c => c.global);\n    return self;\n  };\n\n  let frozen;\n\n  self.freeze = function freeze() {\n    frozen = {};\n    frozen.implied = implied;\n    frozen.checks = checks;\n    frozen.conflicting = conflicting;\n  };\n\n  self.unfreeze = function unfreeze() {\n    implied = frozen.implied;\n    checks = frozen.checks;\n    conflicting = frozen.conflicting;\n    frozen = undefined;\n  };\n\n  return self;\n};","map":null,"metadata":{},"sourceType":"script"}