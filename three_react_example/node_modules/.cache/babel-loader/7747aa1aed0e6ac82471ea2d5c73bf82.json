{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = WatchmanWatcher;\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _assert() {\n  const data = _interopRequireDefault(require('assert'));\n\n  _assert = function _assert() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function _events() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function _fbWatchman() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _common() {\n  const data = _interopRequireDefault(require('sane/src/common'));\n\n  _common = function _common() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _recrawlWarningDedupe() {\n  const data = _interopRequireDefault(require('sane/src/utils/recrawl-warning-dedupe'));\n\n  _recrawlWarningDedupe = function _recrawlWarningDedupe() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst CHANGE_EVENT = _common().default.CHANGE_EVENT;\n\nconst DELETE_EVENT = _common().default.DELETE_EVENT;\n\nconst ADD_EVENT = _common().default.ADD_EVENT;\n\nconst ALL_EVENT = _common().default.ALL_EVENT;\n\nconst SUB_NAME = 'sane-sub';\n/**\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction WatchmanWatcher(dir, opts) {\n  _common().default.assignOptions(this, opts);\n\n  this.root = _path().default.resolve(dir);\n  this.init();\n} // eslint-disable-next-line no-proto\n\n\nWatchmanWatcher.prototype.__proto__ = _events().EventEmitter.prototype;\n/**\n * Run the watchman `watch` command on the root and subscribe to changes.\n *\n * @private\n */\n\nWatchmanWatcher.prototype.init = function () {\n  if (this.client) {\n    this.client.removeAllListeners();\n  }\n\n  const self = this;\n  this.client = new (_fbWatchman().default.Client)();\n  this.client.on('error', error => {\n    self.emit('error', error);\n  });\n  this.client.on('subscription', this.handleChangeEvent.bind(this));\n  this.client.on('end', () => {\n    console.warn('[sane] Warning: Lost connection to watchman, reconnecting..');\n    self.init();\n  });\n  this.watchProjectInfo = null;\n\n  function getWatchRoot() {\n    return self.watchProjectInfo ? self.watchProjectInfo.root : self.root;\n  }\n\n  function onCapability(error, resp) {\n    if (handleError(self, error)) {\n      // The Watchman watcher is unusable on this system, we cannot continue\n      return;\n    }\n\n    handleWarning(resp);\n    self.capabilities = resp.capabilities;\n\n    if (self.capabilities.relative_root) {\n      self.client.command(['watch-project', getWatchRoot()], onWatchProject);\n    } else {\n      self.client.command(['watch', getWatchRoot()], onWatch);\n    }\n  }\n\n  function onWatchProject(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.watchProjectInfo = {\n      relativePath: resp.relative_path ? resp.relative_path : '',\n      root: resp.watch\n    };\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onWatch(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onClock(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    const options = {\n      fields: ['name', 'exists', 'new'],\n      since: resp.clock\n    }; // If the server has the wildmatch capability available it supports\n    // the recursive **/*.foo style match and we can offload our globs\n    // to the watchman server.  This saves both on data size to be\n    // communicated back to us and compute for evaluating the globs\n    // in our node process.\n\n    if (self.capabilities.wildmatch) {\n      if (self.globs.length === 0) {\n        if (!self.dot) {\n          // Make sure we honor the dot option if even we're not using globs.\n          options.expression = ['match', '**', 'wholename', {\n            includedotfiles: false\n          }];\n        }\n      } else {\n        options.expression = ['anyof'];\n\n        for (const i in self.globs) {\n          options.expression.push(['match', self.globs[i], 'wholename', {\n            includedotfiles: self.dot\n          }]);\n        }\n      }\n    }\n\n    if (self.capabilities.relative_root) {\n      options.relative_root = self.watchProjectInfo.relativePath;\n    }\n\n    self.client.command(['subscribe', getWatchRoot(), SUB_NAME, options], onSubscribe);\n  }\n\n  function onSubscribe(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.emit('ready');\n  }\n\n  self.client.capabilityCheck({\n    optional: ['wildmatch', 'relative_root']\n  }, onCapability);\n};\n/**\n * Handles a change event coming from the subscription.\n *\n * @param {Object} resp\n * @private\n */\n\n\nWatchmanWatcher.prototype.handleChangeEvent = function (resp) {\n  _assert().default.equal(resp.subscription, SUB_NAME, 'Invalid subscription event.');\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (Array.isArray(resp.files)) {\n    resp.files.forEach(this.handleFileChange, this);\n  }\n};\n/**\n * Handles a single change event record.\n *\n * @param {Object} changeDescriptor\n * @private\n */\n\n\nWatchmanWatcher.prototype.handleFileChange = function (changeDescriptor) {\n  const self = this;\n  let absPath;\n  let relativePath;\n\n  if (this.capabilities.relative_root) {\n    relativePath = changeDescriptor.name;\n    absPath = _path().default.join(this.watchProjectInfo.root, this.watchProjectInfo.relativePath, relativePath);\n  } else {\n    absPath = _path().default.join(this.root, changeDescriptor.name);\n    relativePath = changeDescriptor.name;\n  }\n\n  if (!(self.capabilities.wildmatch && !this.hasIgnore) && !_common().default.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n    return;\n  }\n\n  if (!changeDescriptor.exists) {\n    self.emitEvent(DELETE_EVENT, relativePath, self.root);\n  } else {\n    _fs().default.lstat(absPath, (error, stat) => {\n      // Files can be deleted between the event and the lstat call\n      // the most reliable thing to do here is to ignore the event.\n      if (error && error.code === 'ENOENT') {\n        return;\n      }\n\n      if (handleError(self, error)) {\n        return;\n      }\n\n      const eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT; // Change event on dirs are mostly useless.\n\n      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {\n        self.emitEvent(eventType, relativePath, self.root, stat);\n      }\n    });\n  }\n};\n/**\n * Dispatches the event.\n *\n * @param {string} eventType\n * @param {string} filepath\n * @param {string} root\n * @param {fs.Stat} stat\n * @private\n */\n\n\nWatchmanWatcher.prototype.emitEvent = function (eventType, filepath, root, stat) {\n  this.emit(eventType, filepath, root, stat);\n  this.emit(ALL_EVENT, eventType, filepath, root, stat);\n};\n/**\n * Closes the watcher.\n *\n * @param {function} callback\n * @private\n */\n\n\nWatchmanWatcher.prototype.close = function (callback) {\n  this.client.removeAllListeners();\n  this.client.end();\n  callback && callback(null, true);\n};\n/**\n * Handles an error and returns true if exists.\n *\n * @param {WatchmanWatcher} self\n * @param {Error} error\n * @private\n */\n\n\nfunction handleError(self, error) {\n  if (error != null) {\n    self.emit('error', error);\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * Handles a warning in the watchman resp object.\n *\n * @param {object} resp\n * @private\n */\n\n\nfunction handleWarning(resp) {\n  if ('warning' in resp) {\n    if (_recrawlWarningDedupe().default.isRecrawlWarningDupe(resp.warning)) {\n      return true;\n    }\n\n    console.warn(resp.warning);\n    return true;\n  } else {\n    return false;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}