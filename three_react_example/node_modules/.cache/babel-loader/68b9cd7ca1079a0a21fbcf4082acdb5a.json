{"ast":null,"code":"'use strict';\n\nconst path = require('path'); // add bash completions to your\n//  yargs-powered applications.\n\n\nmodule.exports = function completion(yargs, usage, command) {\n  const self = {\n    completionKey: 'get-yargs-completions'\n  };\n  const zshShell = process.env.SHELL && process.env.SHELL.indexOf('zsh') !== -1; // get a list of completion commands.\n  // 'args' is the array of strings from the line to be completed\n\n  self.getCompletion = function getCompletion(args, done) {\n    const completions = [];\n    const current = args.length ? args[args.length - 1] : '';\n    const argv = yargs.parse(args, true);\n    const aliases = yargs.parsed.aliases;\n    const parentCommands = yargs.getContext().commands; // a custom completion function can be provided\n    // to completion().\n\n    if (completionFunction) {\n      if (completionFunction.length < 3) {\n        const result = completionFunction(current, argv); // promise based completion function.\n\n        if (typeof result.then === 'function') {\n          return result.then(list => {\n            process.nextTick(() => {\n              done(list);\n            });\n          }).catch(err => {\n            process.nextTick(() => {\n              throw err;\n            });\n          });\n        } // synchronous completion function.\n\n\n        return done(result);\n      } else {\n        // asynchronous completion function\n        return completionFunction(current, argv, completions => {\n          done(completions);\n        });\n      }\n    }\n\n    const handlers = command.getCommandHandlers();\n\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      if (handlers[args[i]] && handlers[args[i]].builder) {\n        const builder = handlers[args[i]].builder;\n\n        if (typeof builder === 'function') {\n          const y = yargs.reset();\n          builder(y);\n          return y.argv;\n        }\n      }\n    }\n\n    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {\n      usage.getCommands().forEach(usageCommand => {\n        const commandName = command.parseCommand(usageCommand[0]).cmd;\n\n        if (args.indexOf(commandName) === -1) {\n          if (!zshShell) {\n            completions.push(commandName);\n          } else {\n            const desc = usageCommand[1] || '';\n            completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc);\n          }\n        }\n      });\n    }\n\n    if (current.match(/^-/) || current === '' && completions.length === 0) {\n      const descs = usage.getDescriptions();\n      Object.keys(yargs.getOptions().key).forEach(key => {\n        // If the key and its aliases aren't in 'args', add the key to 'completions'\n        const keyAndAliases = [key].concat(aliases[key] || []);\n        const notInArgs = keyAndAliases.every(val => args.indexOf(\"--\".concat(val)) === -1);\n\n        if (notInArgs) {\n          if (!zshShell) {\n            completions.push(\"--\".concat(key));\n          } else {\n            const desc = descs[key] || '';\n            completions.push(\"--\".concat(key.replace(/:/g, '\\\\:'), \":\").concat(desc.replace('__yargsString__:', '')));\n          }\n        }\n      });\n    }\n\n    done(completions);\n  }; // generate the completion script to add to your .bashrc.\n\n\n  self.generateCompletionScript = function generateCompletionScript($0, cmd) {\n    const templates = require('./completion-templates');\n\n    let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;\n    const name = path.basename($0); // add ./to applications not yet installed as bin.\n\n    if ($0.match(/\\.js$/)) $0 = \"./\".concat($0);\n    script = script.replace(/{{app_name}}/g, name);\n    script = script.replace(/{{completion_command}}/g, cmd);\n    return script.replace(/{{app_path}}/g, $0);\n  }; // register a function to perform your own custom\n  // completions., this function can be either\n  // synchrnous or asynchronous.\n\n\n  let completionFunction = null;\n\n  self.registerFunction = fn => {\n    completionFunction = fn;\n  };\n\n  return self;\n};","map":null,"metadata":{},"sourceType":"script"}