{"ast":null,"code":"const color = require('kleur');\n\nconst Prompt = require('./prompt');\n\nconst _require = require('sisteransi'),\n      cursor = _require.cursor,\n      erase = _require.erase;\n\nconst _require2 = require('../util'),\n      style = _require2.style,\n      figures = _require2.figures,\n      clear = _require2.clear,\n      lines = _require2.lines;\n\nconst isNumber = /[0-9]/;\n\nconst isDef = any => any !== undefined;\n\nconst round = (number, precision) => {\n  let factor = Math.pow(10, precision);\n  return Math.round(number * factor) / factor;\n};\n/**\n * NumberPrompt Base Element\n * @param {Object} opts Options\n * @param {String} opts.message Message\n * @param {String} [opts.style='default'] Render style\n * @param {Number} [opts.initial] Default value\n * @param {Number} [opts.max=+Infinity] Max value\n * @param {Number} [opts.min=-Infinity] Min value\n * @param {Boolean} [opts.float=false] Parse input as floats\n * @param {Number} [opts.round=2] Round floats to x decimals\n * @param {Number} [opts.increment=1] Number to increment by when using arrow-keys\n * @param {Function} [opts.validate] Validate function\n * @param {Stream} [opts.stdin] The Readable stream to listen to\n * @param {Stream} [opts.stdout] The Writable stream to write readline data to\n * @param {String} [opts.error] The invalid error label\n */\n\n\nclass NumberPrompt extends Prompt {\n  constructor(opts = {}) {\n    super(opts);\n    this.transform = style.render(opts.style);\n    this.msg = opts.message;\n    this.initial = isDef(opts.initial) ? opts.initial : '';\n    this.float = !!opts.float;\n    this.round = opts.round || 2;\n    this.inc = opts.increment || 1;\n    this.min = isDef(opts.min) ? opts.min : -Infinity;\n    this.max = isDef(opts.max) ? opts.max : Infinity;\n    this.errorMsg = opts.error || \"Please Enter A Valid Value\";\n\n    this.validator = opts.validate || (() => true);\n\n    this.color = \"cyan\";\n    this.value = \"\";\n    this.typed = \"\";\n    this.lastHit = 0;\n    this.render();\n  }\n\n  set value(v) {\n    if (!v && v !== 0) {\n      this.placeholder = true;\n      this.rendered = color.gray(this.transform.render(\"\".concat(this.initial)));\n      this._value = \"\";\n    } else {\n      this.placeholder = false;\n      this.rendered = this.transform.render(\"\".concat(round(v, this.round)));\n      this._value = round(v, this.round);\n    }\n\n    this.fire();\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  parse(x) {\n    return this.float ? parseFloat(x) : parseInt(x);\n  }\n\n  valid(c) {\n    return c === \"-\" || c === \".\" && this.float || isNumber.test(c);\n  }\n\n  reset() {\n    this.typed = \"\";\n    this.value = \"\";\n    this.fire();\n    this.render();\n  }\n\n  abort() {\n    let x = this.value;\n    this.value = x !== \"\" ? x : this.initial;\n    this.done = this.aborted = true;\n    this.error = false;\n    this.fire();\n    this.render();\n    this.out.write(\"\\n\");\n    this.close();\n  }\n\n  async validate() {\n    let valid = await this.validator(this.value);\n\n    if (typeof valid === \"string\") {\n      this.errorMsg = valid;\n      valid = false;\n    }\n\n    this.error = !valid;\n  }\n\n  async submit() {\n    await this.validate();\n\n    if (this.error) {\n      this.color = \"red\";\n      this.fire();\n      this.render();\n      return;\n    }\n\n    let x = this.value;\n    this.value = x !== \"\" ? x : this.initial;\n    this.done = true;\n    this.aborted = false;\n    this.error = false;\n    this.fire();\n    this.render();\n    this.out.write(\"\\n\");\n    this.close();\n  }\n\n  up() {\n    this.typed = \"\";\n    if (this.value >= this.max) return this.bell();\n    this.value += this.inc;\n    this.color = \"cyan\";\n    this.fire();\n    this.render();\n  }\n\n  down() {\n    this.typed = \"\";\n    if (this.value <= this.min) return this.bell();\n    this.value -= this.inc;\n    this.color = \"cyan\";\n    this.fire();\n    this.render();\n  }\n\n  delete() {\n    let val = this.value.toString();\n    if (val.length === 0) return this.bell();\n    this.value = this.parse(val = val.slice(0, -1)) || \"\";\n    this.color = \"cyan\";\n    this.fire();\n    this.render();\n  }\n\n  next() {\n    this.value = this.initial;\n    this.fire();\n    this.render();\n  }\n\n  _(c, key) {\n    if (!this.valid(c)) return this.bell();\n    const now = Date.now();\n    if (now - this.lastHit > 1000) this.typed = \"\"; // 1s elapsed\n\n    this.typed += c;\n    this.lastHit = now;\n    this.color = \"cyan\";\n    if (c === \".\") return this.fire();\n    this.value = Math.min(this.parse(this.typed), this.max);\n    if (this.value > this.max) this.value = this.max;\n    if (this.value < this.min) this.value = this.min;\n    this.fire();\n    this.render();\n  }\n\n  render() {\n    if (this.closed) return;\n\n    if (!this.firstRender) {\n      if (this.outputError) this.out.write(cursor.down(lines(this.outputError) - 1) + clear(this.outputError));\n      this.out.write(clear(this.outputText));\n    }\n\n    super.render();\n    this.outputError = ''; // Print prompt\n\n    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(\" \"); // Print error\n\n    if (this.error) {\n      this.outputError += this.errorMsg.split(\"\\n\").reduce((a, l, i) => a + \"\\n\".concat(i ? \" \" : figures.pointerSmall, \" \").concat(color.red().italic(l)), \"\");\n    }\n\n    this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);\n  }\n\n}\n\nmodule.exports = NumberPrompt;","map":null,"metadata":{},"sourceType":"script"}