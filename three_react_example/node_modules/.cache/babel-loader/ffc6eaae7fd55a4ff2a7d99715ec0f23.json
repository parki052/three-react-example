{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _vm() {\n  const data = _interopRequireDefault(require('vm'));\n\n  _vm = function _vm() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function _core() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function _babelPluginIstanbul() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = _interopRequireDefault(require('convert-source-map'));\n\n  _convertSourceMap = function _convertSourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function _jestHasteMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function _fastJsonStableStringify() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function _slash() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = _interopRequireDefault(require('write-file-atomic'));\n\n  _writeFileAtomic = function _writeFileAtomic() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _realpathNative() {\n  const data = require('realpath-native');\n\n  _realpathNative = function _realpathNative() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function _pirates() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(require('./enhanceUnexpectedTokenMessage'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n} // Use `require` to avoid TS rootDir\n\n\nconst _require = require('../package.json'),\n      VERSION = _require.version; // This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\n\n\nconst projectCaches = new WeakMap(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nfunction waitForPromiseWithCleanup(_x, _x2) {\n  return _waitForPromiseWithCleanup.apply(this, arguments);\n}\n\nfunction _waitForPromiseWithCleanup() {\n  _waitForPromiseWithCleanup = _asyncToGenerator(function* (promise, cleanup) {\n    try {\n      yield promise;\n    } finally {\n      cleanup();\n    }\n  });\n  return _waitForPromiseWithCleanup.apply(this, arguments);\n}\n\nclass ScriptTransformer {\n  constructor(config) {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_transformCache', void 0);\n\n    _defineProperty(this, '_transformConfigCache', void 0);\n\n    this._config = config;\n    this._transformCache = new Map();\n    this._transformConfigCache = new Map();\n    let projectCache = projectCaches.get(config);\n\n    if (!projectCache) {\n      projectCache = {\n        configString: (0, _fastJsonStableStringify().default)(this._config),\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(config, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _getCacheKey(fileData, filename, instrument) {\n    const configString = this._cache.configString;\n\n    const transformer = this._getTransformer(filename);\n\n    if (transformer && typeof transformer.getCacheKey === 'function') {\n      return _crypto().default.createHash('md5').update(transformer.getCacheKey(fileData, filename, configString, {\n        config: this._config,\n        instrument,\n        rootDir: this._config.rootDir\n      })).update(CACHE_VERSION).digest('hex');\n    } else {\n      return _crypto().default.createHash('md5').update(fileData).update(configString).update(instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex');\n    }\n  }\n\n  _getFileCachePath(filename, content, instrument) {\n    const baseCacheDir = _jestHasteMap().default.getCacheFilePath(this._config.cacheDirectory, 'jest-transform-cache-' + this._config.name, VERSION);\n\n    const cacheKey = this._getCacheKey(content, filename, instrument); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n\n    const cacheDir = _path().default.join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n\n    const cacheFilenamePrefix = _path().default.basename(filename, _path().default.extname(filename)).replace(/\\W/g, '');\n\n    const cachePath = (0, _slash().default)(_path().default.join(cacheDir, cacheFilenamePrefix + '_' + cacheKey));\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        const transformPath = transformRegExp[i][1];\n\n        this._transformConfigCache.set(transformPath, transformRegExp[i][2]);\n\n        return transformPath;\n      }\n    }\n\n    return undefined;\n  }\n\n  _getTransformer(filename) {\n    let transform = null;\n\n    if (!this._config.transform || !this._config.transform.length) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (transformPath) {\n      const transformer = this._transformCache.get(transformPath);\n\n      if (transformer != null) {\n        return transformer;\n      }\n\n      transform = require(transformPath);\n\n      const transformerConfig = this._transformConfigCache.get(transformPath);\n\n      if (typeof transform.createTransformer === 'function') {\n        transform = transform.createTransformer(transformerConfig);\n      }\n\n      if (typeof transform.process !== 'function') {\n        throw new TypeError('Jest: a transform must export a `process` function.');\n      }\n\n      this._transformCache.set(transformPath, transform);\n    }\n\n    return transform;\n  }\n\n  _instrumentFile(filename, content) {\n    const result = (0, _core().transformSync)(content, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsStaticESM: false\n      },\n      configFile: false,\n      filename,\n      plugins: [[_babelPluginIstanbul().default, {\n        compact: false,\n        // files outside `cwd` will not be instrumented\n        cwd: this._config.rootDir,\n        exclude: [],\n        useInlineSourceMaps: false\n      }]]\n    });\n\n    if (result) {\n      const code = result.code;\n\n      if (code) {\n        return code;\n      }\n    }\n\n    return content;\n  }\n\n  _getRealPath(filepath) {\n    try {\n      return (0, _realpathNative().sync)(filepath) || filepath;\n    } catch (err) {\n      return filepath;\n    }\n  } // We don't want to expose transformers to the outside - this function is just\n  // to warm up `this._transformCache`\n\n\n  preloadTransformer(filepath) {\n    this._getTransformer(filepath);\n  }\n\n  transformSource(filepath, content, instrument) {\n    const filename = this._getRealPath(filepath);\n\n    const transform = this._getTransformer(filename);\n\n    const cacheFilePath = this._getFileCachePath(filename, content, instrument);\n\n    let sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    let code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n    const shouldCallTransform = transform && this.shouldTransform(filename); // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument = shouldCallTransform && transform && transform.canInstrument; // If we handle the coverage instrumentation, we should try to map code\n    // coverage against original source with any provided source map\n\n    const mapCoverage = instrument && !transformWillInstrument;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        mapCoverage,\n        sourceMapPath\n      };\n    }\n\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transform && shouldCallTransform) {\n      const processed = transform.process(content, filename, this._config, {\n        instrument\n      });\n\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new TypeError(\"Jest: a transform's `process` function must return a string, \" + 'or an object with `code` key containing this string.');\n      }\n    }\n\n    if (!transformed.map) {\n      //Could be a potential freeze here.\n      //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n      const inlineSourceMap = _convertSourceMap().default.fromSource(transformed.code);\n\n      if (inlineSourceMap) {\n        transformed.map = inlineSourceMap.toJSON();\n      }\n    }\n\n    if (!transformWillInstrument && instrument) {\n      code = this._instrumentFile(filename, transformed.code);\n    } else {\n      code = transformed.code;\n    }\n\n    if (transformed.map) {\n      const sourceMapContent = typeof transformed.map === 'string' ? transformed.map : JSON.stringify(transformed.map);\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      mapCoverage,\n      sourceMapPath\n    };\n  }\n\n  _transformAndBuildScript(filename, options, instrument, fileSource) {\n    const isInternalModule = !!(options && options.isInternalModule);\n    const isCoreModule = !!(options && options.isCoreModule);\n    const content = stripShebang(fileSource || _gracefulFs().default.readFileSync(filename, 'utf8'));\n    let wrappedCode;\n    let sourceMapPath = null;\n    let mapCoverage = false;\n    const willTransform = !isInternalModule && !isCoreModule && (this.shouldTransform(filename) || instrument);\n\n    try {\n      const extraGlobals = options && options.extraGlobals || [];\n\n      if (willTransform) {\n        const transformedSource = this.transformSource(filename, content, instrument);\n        wrappedCode = wrap(transformedSource.code, ...extraGlobals);\n        sourceMapPath = transformedSource.sourceMapPath;\n        mapCoverage = transformedSource.mapCoverage;\n      } else {\n        wrappedCode = wrap(content, ...extraGlobals);\n      }\n\n      return {\n        mapCoverage,\n        script: new (_vm().default.Script)(wrappedCode, {\n          displayErrors: true,\n          filename: isCoreModule ? 'jest-nodejs-core-' + filename : filename\n        }),\n        sourceMapPath\n      };\n    } catch (e) {\n      if (e.codeFrame) {\n        e.stack = e.message + '\\n' + e.codeFrame;\n      }\n\n      if (e instanceof SyntaxError && e.message.includes('Unexpected token') && !e.message.includes(' expected')) {\n        throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n      }\n\n      throw e;\n    }\n  }\n\n  transform(filename, options, fileSource) {\n    let scriptCacheKey = undefined;\n    let instrument = false;\n\n    if (!options.isCoreModule) {\n      instrument = (0, _shouldInstrument.default)(filename, options, this._config);\n      scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n      const result = this._cache.transformedFiles.get(scriptCacheKey);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    const result = this._transformAndBuildScript(filename, options, instrument, fileSource);\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const isInternalModule = options.isInternalModule;\n    const isCoreModule = options.isCoreModule;\n    const willTransform = !isInternalModule && !isCoreModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const _this$transformSource = this.transformSource(filename, fileSource, false),\n            transformedJsonSource = _this$transformSource.code;\n\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  requireAndTranspileModule(moduleName, callback) {\n    // Load the transformer to avoid a cycle where we need to load a\n    // transformer in order to transform it in the require hooks\n    this.preloadTransformer(moduleName);\n    let transforming = false;\n    const revertHook = (0, _pirates().addHook)((code, filename) => {\n      try {\n        transforming = true;\n        return this.transformSource(filename, code, false).code || code;\n      } finally {\n        transforming = false;\n      }\n    }, {\n      exts: [_path().default.extname(moduleName)],\n      ignoreNodeModules: false,\n      matcher: filename => {\n        if (transforming) {\n          // Don't transform any dependency required by the transformer itself\n          return false;\n        }\n\n        return this.shouldTransform(filename);\n      }\n    });\n\n    const module = require(moduleName);\n\n    if (!callback) {\n      revertHook();\n      return module;\n    }\n\n    try {\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(() => module);\n      }\n    } finally {\n      revertHook();\n    }\n\n    return module;\n  }\n  /**\n   * @deprecated use `this.shouldTransform` instead\n   */\n  // @ts-ignore: Unused and private - remove in Jest 25\n\n\n  _shouldTransform(filename) {\n    return this.shouldTransform(filename);\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return !!this._config.transform && !!this._config.transform.length && !isIgnored;\n  }\n\n}\n\nexports.default = ScriptTransformer;\n\n_defineProperty(ScriptTransformer, 'EVAL_RESULT_VARIABLE', void 0);\n\nconst removeFile = path => {\n  try {\n    _gracefulFs().default.unlinkSync(path);\n  } catch (e) {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = _crypto().default.createHash('md5').update(code).digest('hex');\n\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substr(33);\n\n  const checksum = _crypto().default.createHash('md5').update(code).digest('hex');\n\n  if (checksum === content.substr(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    _writeFileAtomic().default.sync(cachePath, fileData, {\n      encoding: 'utf8'\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message = 'jest: failed to cache transform results in: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) => process.platform === 'win32' && e.code === 'EPERM' && _gracefulFs().default.existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!_gracefulFs().default.existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = _gracefulFs().default.readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = 'jest: failed to read cache file: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = _gracefulFs().default.statSync(filename).mtime;\n\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([new RegExp(config.transform[i][0]), config.transform[i][1], config.transform[i][2]]);\n  }\n\n  return transformRegexp;\n};\n\nconst wrap = (content, ...extras) => {\n  const globals = new Set(['module', 'exports', 'require', '__dirname', '__filename', 'global', 'jest', ...extras]);\n  return '({\"' + ScriptTransformer.EVAL_RESULT_VARIABLE + \"\\\":function(\".concat(Array.from(globals).join(','), \"){\") + content + '\\n}});';\n}; // TODO: Can this be added to the static property?\n\n\nScriptTransformer.EVAL_RESULT_VARIABLE = 'Object.<anonymous>';","map":null,"metadata":{},"sourceType":"script"}