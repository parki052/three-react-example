{"ast":null,"code":"'use strict';\n\nconst watchman = require('fb-watchman');\n\nconst captureExit = require('capture-exit');\n\nfunction values(obj) {\n  return Object.keys(obj).map(key => obj[key]);\n}\n/**\n * Constants\n */\n\n/**\n * Singleton that provides a public API for a connection to a watchman instance for 'sane'.\n * It tries to abstract/remove as much of the boilerplate processing as necessary\n * from WatchmanWatchers that use it. In particular, they have no idea whether\n * we're using 'watch-project' or 'watch', what the 'project root' is when\n * we internally use watch-project, whether a connection has been lost\n * and reestablished, etc. Also switched to doing things with promises and known-name\n * methods in WatchmanWatcher, so as much information as possible can be kept in\n * the WatchmanClient, ultimately making this the only object listening directly\n * to watchman.Client, then forwarding appropriately (via the known-name methods) to\n * the relevant WatchmanWatcher(s).\n *\n * Note: WatchmanWatcher also added a 'watchmanPath' option for use with the sane CLI.\n * Because of that, we actually need a map of watchman binary path to WatchmanClient instance.\n * That is set up in getInstance(). Once the WatchmanWatcher has a given client, it doesn't\n * change.\n *\n * @class WatchmanClient\n * @param String watchmanBinaryPath\n * @public\n */\n\n\nclass WatchmanClient {\n  constructor(watchmanBinaryPath) {\n    captureExit.captureExit(); // define/clear some local state. The properties will be initialized\n    // in _handleClientAndCheck(). This is also called again in _onEnd when\n    // trying to reestablish connection to watchman.\n\n    this._clearLocalVars();\n\n    this._watchmanBinaryPath = watchmanBinaryPath;\n    this._backoffTimes = this._setupBackoffTimes();\n    this._clientListeners = null; // direct listeners from here to watchman.Client.\n    // Define a handler for if somehow the Node process gets interrupted. We need to\n    // close down the watchman.Client, if we have one.\n\n    captureExit.onExit(() => this._clearLocalVars());\n  } // Define 'wildmatch' property, which must be available when we call the\n  // WatchmanWatcher.createOptions() method.\n\n\n  get wildmatch() {\n    return this._wildmatch;\n  }\n  /**\n   * Called from WatchmanWatcher (or WatchmanClient during reconnect) to create\n   * a watcherInfo entry in our _watcherMap and issue a 'subscribe' to the\n   * watchman.Client, to be handled here.\n   */\n\n\n  subscribe(watchmanWatcher, root) {\n    let subscription;\n    let watcherInfo;\n    return this._setupClient().then(() => {\n      watcherInfo = this._createWatcherInfo(watchmanWatcher);\n      subscription = watcherInfo.subscription;\n      return this._watch(subscription, root);\n    }).then(() => this._clock(subscription)).then(() => this._subscribe(subscription)); // Note: callers are responsible for noting any subscription failure.\n  }\n  /**\n   * Remove the information about a specific WatchmanWatcher.\n   * Once done, if no watchers are left, clear the local vars,\n   * which will end the connection to the watchman.Client, too.\n   */\n\n\n  closeWatcher(watchmanWatcher) {\n    let watcherInfos = values(this._watcherMap);\n    let numWatchers = watcherInfos.length;\n\n    if (numWatchers > 0) {\n      let watcherInfo;\n\n      for (let info of watcherInfos) {\n        if (info.watchmanWatcher === watchmanWatcher) {\n          watcherInfo = info;\n          break;\n        }\n      }\n\n      if (watcherInfo) {\n        delete this._watcherMap[watcherInfo.subscription];\n        numWatchers--;\n\n        if (numWatchers === 0) {\n          this._clearLocalVars(); // nobody watching, so shut the watchman.Client down.\n\n        }\n      }\n    }\n  }\n  /**\n   * Simple backoff-time iterator. next() returns times in ms.\n   * When it's at the last value, it stays there until reset()\n   * is called.\n   */\n\n\n  _setupBackoffTimes() {\n    return {\n      _times: [0, 1000, 5000, 10000, 60000],\n      _next: 0,\n\n      next() {\n        let val = this._times[this._next];\n\n        if (this._next < this._times.length - 1) {\n          this._next++;\n        }\n\n        return val;\n      },\n\n      reset() {\n        this._next = 0;\n      }\n\n    };\n  }\n  /**\n   * Set up the connection to the watchman client. Return a promise\n   * that is fulfilled when we have a client that has finished the\n   * capabilityCheck.\n   */\n\n\n  _setupClient() {\n    if (!this._clientPromise) {\n      this._clientPromise = new Promise((resolve, reject) => {\n        this._handleClientAndCheck(resolve, reject);\n      });\n    }\n\n    return this._clientPromise;\n  }\n  /**\n   * Handle the process of creating a client and doing a capability check and\n   * getting a valid response, then setting up local data based on that.\n   *\n   * This is split from _setupClient and _createClientAndCheck so it can\n   * provide the backoff handling needed during attempts to reconnect.\n   */\n\n\n  _handleClientAndCheck(resolve, reject) {\n    this._createClientAndCheck().then(value => {\n      let resp = value.resp;\n      let client = value.client;\n\n      try {\n        this._wildmatch = resp.capabilities.wildmatch;\n        this._relative_root = resp.capabilities.relative_root;\n        this._client = client;\n        client.on('subscription', this._onSubscription.bind(this));\n        client.on('error', this._onError.bind(this));\n        client.on('end', this._onEnd.bind(this));\n\n        this._backoffTimes.reset();\n\n        resolve(this);\n      } catch (error) {\n        // somehow, even though we supposedly got a valid value back, it's\n        // malformed, or some other internal error occurred. Reject so\n        // the promise itself doesn't hang forever.\n        reject(error);\n      }\n    }, () => {\n      // create & capability check failed in any of several ways,\n      // do the retry with backoff.\n      // XXX May want to change this later to actually reject/terminate with\n      // an error in certain of the inner errors (e.g. when we\n      // can figure out the server is definitely not coming\n      // back, or something else is not recoverable by just waiting).\n      // Could also decide after N retries to just quit.\n      let backoffMillis = this._backoffTimes.next(); // XXX may want to fact we'll attempt reconnect in backoffMillis ms.\n\n\n      setTimeout(() => {\n        this._handleClientAndCheck(resolve, reject);\n      }, backoffMillis);\n    });\n  }\n  /**\n   * Create a promise that will only be fulfilled when either\n   * we correctly get capabilities back or we get an 'error' or 'end'\n   * callback, indicating a problem. The caller _handleClientAndCheck\n   * then deals with providing a retry and backoff mechanism.\n   */\n\n\n  _createClientAndCheck() {\n    return new Promise((resolve, reject) => {\n      let client;\n\n      try {\n        client = new watchman.Client(this._watchmanBinaryPath ? {\n          watchmanBinaryPath: this._watchmanBinaryPath\n        } : {});\n      } catch (error) {\n        // if we're here, either the binary path is bad or something\n        // else really bad happened. The client doesn't even attempt\n        // to connect until we send it a command, though.\n        reject(error);\n        return;\n      }\n\n      client.on('error', error => {\n        client.removeAllListeners();\n        reject(error);\n      });\n      client.on('end', () => {\n        client.removeAllListeners();\n        reject(new Error('Disconnected during client capabilities check'));\n      });\n      client.capabilityCheck({\n        optional: ['wildmatch', 'relative_root']\n      }, (error, resp) => {\n        try {\n          client.removeAllListeners();\n\n          if (error) {\n            reject(error);\n          } else {\n            resolve({\n              resp,\n              client\n            });\n          }\n        } catch (err) {\n          // In case we get something weird in the block using 'resp'.\n          // XXX We could also just remove the try/catch if we believe\n          // the resp stuff should always work, but just in case...\n          reject(err);\n        }\n      });\n    });\n  }\n  /**\n   * Clear out local state at the beginning and if we end up\n   * getting disconnected and try to reconnect.\n   */\n\n\n  _clearLocalVars() {\n    if (this._client) {\n      this._client.removeAllListeners();\n\n      this._client.end();\n    }\n\n    this._client = null;\n    this._clientPromise = null;\n    this._wildmatch = false;\n    this._relative_root = false;\n    this._subscriptionId = 1;\n    this._watcherMap = Object.create(null); // Note that we do not clear _clientListeners or _watchmanBinaryPath.\n  }\n\n  _genSubscription() {\n    let val = 'sane_' + this._subscriptionId++;\n    return val;\n  }\n  /**\n   * Create a new watcherInfo entry for the given watchmanWatcher and\n   * initialize it.\n   */\n\n\n  _createWatcherInfo(watchmanWatcher) {\n    let watcherInfo = {\n      subscription: this._genSubscription(),\n      watchmanWatcher: watchmanWatcher,\n      root: null,\n      // set during 'watch' or 'watch-project'\n      relativePath: null,\n      // same\n      since: null,\n      // set during 'clock'\n      options: null // created and set during 'subscribe'.\n\n    };\n    this._watcherMap[watcherInfo.subscription] = watcherInfo;\n    return watcherInfo;\n  }\n  /**\n   * Find an existing watcherInfo instance.\n   */\n\n\n  _getWatcherInfo(subscription) {\n    return this._watcherMap[subscription];\n  }\n  /**\n   * Given a watchmanWatcher and a root, issue the correct 'watch'\n   * or 'watch-project' command and handle it with the callback.\n   * Because we're operating in 'sane', we'll keep the results\n   * of the 'watch' or 'watch-project' here.\n   */\n\n\n  _watch(subscription, root) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription);\n\n      if (this._relative_root) {\n        this._client.command(['watch-project', root], (error, resp) => {\n          if (error) {\n            reject(error);\n          } else {\n            watcherInfo.root = resp.watch;\n            watcherInfo.relativePath = resp.relative_path ? resp.relative_path : '';\n            resolve(resp);\n          }\n        });\n      } else {\n        this._client.command(['watch', root], (error, resp) => {\n          if (error) {\n            reject(error);\n          } else {\n            watcherInfo.root = root;\n            watcherInfo.relativePath = '';\n            resolve(resp);\n          }\n        });\n      }\n    });\n  }\n  /**\n   * Issue the 'clock' command to get the time value for use with the 'since'\n   * option during 'subscribe'.\n   */\n\n\n  _clock(subscription) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription);\n\n      this._client.command(['clock', watcherInfo.root], (error, resp) => {\n        if (error) {\n          reject(error);\n        } else {\n          watcherInfo.since = resp.clock;\n          resolve(resp);\n        }\n      });\n    });\n  }\n  /**\n   * Do the internal handling of calling the watchman.Client for\n   * a subscription.\n   */\n\n\n  _subscribe(subscription) {\n    return new Promise((resolve, reject) => {\n      let watcherInfo = this._getWatcherInfo(subscription); // create the 'bare' options w/o 'since' or relative_root.\n      // Store in watcherInfo for later use if we need to reset\n      // things after an 'end' caught here.\n\n\n      let options = watcherInfo.watchmanWatcher.createOptions();\n      watcherInfo.options = options; // Dup the options object so we can add 'relative_root' and 'since'\n      // and leave the original options object alone. We'll do this again\n      // later if we need to resubscribe after 'end' and reconnect.\n\n      options = Object.assign({}, options);\n\n      if (this._relative_root) {\n        options.relative_root = watcherInfo.relativePath;\n      }\n\n      options.since = watcherInfo.since;\n\n      this._client.command(['subscribe', watcherInfo.root, subscription, options], (error, resp) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(resp);\n        }\n      });\n    });\n  }\n  /**\n   * Handle the 'subscription' (file change) event, by calling the\n   * handler on the relevant WatchmanWatcher.\n   */\n\n\n  _onSubscription(resp) {\n    let watcherInfo = this._getWatcherInfo(resp.subscription);\n\n    if (watcherInfo) {\n      // we're assuming the watchmanWatcher does not throw during\n      // handling of the change event.\n      watcherInfo.watchmanWatcher.handleChangeEvent(resp);\n    } else {\n      // Note it in the log, but otherwise ignore it\n      console.error(\"WatchmanClient error - received 'subscription' event \" + \"for non-existent subscription '\" + resp.subscription + \"'\");\n    }\n  }\n  /**\n   * Handle the 'error' event by forwarding to the\n   * handler on all WatchmanWatchers (errors are generally during processing\n   * a particular command, but it's not given which command that was, or\n   * which subscription it belonged to).\n   */\n\n\n  _onError(error) {\n    values(this._watcherMap).forEach(watcherInfo => watcherInfo.watchmanWatcher.handleErrorEvent(error));\n  }\n  /**\n   * Handle the 'end' event by creating a new watchman.Client and\n   * attempting to resubscribe all the existing subscriptions, but\n   * without notifying the WatchmanWatchers about it. They should\n   * not be aware the connection was lost and recreated.\n   * If something goes wrong during any part of the reconnect/setup,\n   * call the error handler on each existing WatchmanWatcher.\n   */\n\n\n  _onEnd() {\n    console.warn('[sane.WatchmanClient] Warning: Lost connection to watchman, reconnecting..'); // Hold the old watcher map so we use it to recreate all subscriptions.\n\n    let oldWatcherInfos = values(this._watcherMap);\n\n    this._clearLocalVars();\n\n    this._setupClient().then(() => {\n      let promises = oldWatcherInfos.map(watcherInfo => this.subscribe(watcherInfo.watchmanWatcher, watcherInfo.watchmanWatcher.root));\n      Promise.all(promises).then(() => {\n        console.log('[sane.WatchmanClient]: Reconnected to watchman');\n      }, error => {\n        console.error('[sane.WatchmanClient]: Reconnected to watchman, but failed to ' + 'reestablish at least one subscription, cannot continue');\n        console.error(error);\n        oldWatcherInfos.forEach(watcherInfo => watcherInfo.watchmanWatcher.handleErrorEvent(error)); // XXX not sure whether to clear all _watcherMap instances here,\n        // but basically this client is inconsistent now, since at least one\n        // subscribe failed.\n      });\n    }, error => {\n      console.error('[sane.WatchmanClient]: Lost connection to watchman, ' + 'reconnect failed, cannot continue');\n      console.error(error);\n      oldWatcherInfos.forEach(watcherInfo => watcherInfo.watchmanWatcher.handleErrorEvent(error));\n    });\n  }\n\n}\n\nmodule.exports = {\n  /**\n   * Create/retrieve an instance of the WatchmanClient. See the header comment\n   * about the map of client instances, one per watchmanPath.\n   * Export the getInstance method by itself so the callers cannot do anything until\n   * they get a real WatchmanClient instance here.\n   */\n  getInstance(watchmanBinaryPath) {\n    let clientMap = WatchmanClient.prototype._clientMap;\n\n    if (!clientMap) {\n      clientMap = Object.create(null);\n      WatchmanClient.prototype._clientMap = clientMap;\n    }\n\n    if (watchmanBinaryPath == undefined || watchmanBinaryPath === null) {\n      watchmanBinaryPath = '';\n    }\n\n    let watchmanClient = clientMap[watchmanBinaryPath];\n\n    if (!watchmanClient) {\n      watchmanClient = new WatchmanClient(watchmanBinaryPath);\n      clientMap[watchmanBinaryPath] = watchmanClient;\n    }\n\n    return watchmanClient;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}