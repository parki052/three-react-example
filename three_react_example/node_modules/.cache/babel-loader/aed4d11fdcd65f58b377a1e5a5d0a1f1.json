{"ast":null,"code":"'use strict'; // this file handles outputting usage instructions,\n// failures, etc. keeps logging in one place.\n\nconst decamelize = require('./decamelize');\n\nconst stringWidth = require('string-width');\n\nconst objFilter = require('./obj-filter');\n\nconst path = require('path');\n\nconst setBlocking = require('set-blocking');\n\nconst YError = require('./yerror');\n\nmodule.exports = function usage(yargs, y18n) {\n  const __ = y18n.__;\n  const self = {}; // methods for ouputting/building failure message.\n\n  const fails = [];\n\n  self.failFn = function failFn(f) {\n    fails.push(f);\n  };\n\n  let failMessage = null;\n  let showHelpOnFail = true;\n\n  self.showHelpOnFail = function showHelpOnFailFn(enabled, message) {\n    if (typeof enabled === 'string') {\n      message = enabled;\n      enabled = true;\n    } else if (typeof enabled === 'undefined') {\n      enabled = true;\n    }\n\n    failMessage = message;\n    showHelpOnFail = enabled;\n    return self;\n  };\n\n  let failureOutput = false;\n\n  self.fail = function fail(msg, err) {\n    const logger = yargs._getLoggerInstance();\n\n    if (fails.length) {\n      for (let i = fails.length - 1; i >= 0; --i) {\n        fails[i](msg, err, self);\n      }\n    } else {\n      if (yargs.getExitProcess()) setBlocking(true); // don't output failure message more than once\n\n      if (!failureOutput) {\n        failureOutput = true;\n\n        if (showHelpOnFail) {\n          yargs.showHelp('error');\n          logger.error();\n        }\n\n        if (msg || err) logger.error(msg || err);\n\n        if (failMessage) {\n          if (msg || err) logger.error('');\n          logger.error(failMessage);\n        }\n      }\n\n      err = err || new YError(msg);\n\n      if (yargs.getExitProcess()) {\n        return yargs.exit(1);\n      } else if (yargs._hasParseCallback()) {\n        return yargs.exit(1, err);\n      } else {\n        throw err;\n      }\n    }\n  }; // methods for ouputting/building help (usage) message.\n\n\n  let usages = [];\n  let usageDisabled = false;\n\n  self.usage = (msg, description) => {\n    if (msg === null) {\n      usageDisabled = true;\n      usages = [];\n      return;\n    }\n\n    usageDisabled = false;\n    usages.push([msg, description || '']);\n    return self;\n  };\n\n  self.getUsage = () => {\n    return usages;\n  };\n\n  self.getUsageDisabled = () => {\n    return usageDisabled;\n  };\n\n  self.getPositionalGroupName = () => {\n    return __('Positionals:');\n  };\n\n  let examples = [];\n\n  self.example = (cmd, description) => {\n    examples.push([cmd, description || '']);\n  };\n\n  let commands = [];\n\n  self.command = function command(cmd, description, isDefault, aliases) {\n    // the last default wins, so cancel out any previously set default\n    if (isDefault) {\n      commands = commands.map(cmdArray => {\n        cmdArray[2] = false;\n        return cmdArray;\n      });\n    }\n\n    commands.push([cmd, description || '', isDefault, aliases]);\n  };\n\n  self.getCommands = () => commands;\n\n  let descriptions = {};\n\n  self.describe = function describe(key, desc) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.describe(k, key[k]);\n      });\n    } else {\n      descriptions[key] = desc;\n    }\n  };\n\n  self.getDescriptions = () => descriptions;\n\n  let epilog;\n\n  self.epilog = msg => {\n    epilog = msg;\n  };\n\n  let wrapSet = false;\n  let wrap;\n\n  self.wrap = cols => {\n    wrapSet = true;\n    wrap = cols;\n  };\n\n  function getWrap() {\n    if (!wrapSet) {\n      wrap = windowWidth();\n      wrapSet = true;\n    }\n\n    return wrap;\n  }\n\n  const deferY18nLookupPrefix = '__yargsString__:';\n\n  self.deferY18nLookup = str => deferY18nLookupPrefix + str;\n\n  const defaultGroup = 'Options:';\n\n  self.help = function help() {\n    normalizeAliases(); // handle old demanded API\n\n    const base$0 = path.basename(yargs.$0);\n    const demandedOptions = yargs.getDemandedOptions();\n    const demandedCommands = yargs.getDemandedCommands();\n    const groups = yargs.getGroups();\n    const options = yargs.getOptions();\n    let keys = [];\n    keys = keys.concat(Object.keys(descriptions));\n    keys = keys.concat(Object.keys(demandedOptions));\n    keys = keys.concat(Object.keys(demandedCommands));\n    keys = keys.concat(Object.keys(options.default));\n    keys = keys.filter(filterHiddenOptions);\n    keys = Object.keys(keys.reduce((acc, key) => {\n      if (key !== '_') acc[key] = true;\n      return acc;\n    }, {}));\n    const theWrap = getWrap();\n\n    const ui = require('cliui')({\n      width: theWrap,\n      wrap: !!theWrap\n    }); // the usage string.\n\n\n    if (!usageDisabled) {\n      if (usages.length) {\n        // user-defined usage.\n        usages.forEach(usage => {\n          ui.div(\"\".concat(usage[0].replace(/\\$0/g, base$0)));\n\n          if (usage[1]) {\n            ui.div({\n              text: \"\".concat(usage[1]),\n              padding: [1, 0, 0, 0]\n            });\n          }\n        });\n        ui.div();\n      } else if (commands.length) {\n        let u = null; // demonstrate how commands are used.\n\n        if (demandedCommands._) {\n          u = \"\".concat(base$0, \" <\").concat(__('command'), \">\\n\");\n        } else {\n          u = \"\".concat(base$0, \" [\").concat(__('command'), \"]\\n\");\n        }\n\n        ui.div(\"\".concat(u));\n      }\n    } // your application's commands, i.e., non-option\n    // arguments populated in '_'.\n\n\n    if (commands.length) {\n      ui.div(__('Commands:'));\n      const context = yargs.getContext();\n      const parentCommands = context.commands.length ? \"\".concat(context.commands.join(' '), \" \") : '';\n\n      if (yargs.getParserConfiguration()['sort-commands'] === true) {\n        commands = commands.sort((a, b) => a[0].localeCompare(b[0]));\n      }\n\n      commands.forEach(command => {\n        const commandString = \"\".concat(base$0, \" \").concat(parentCommands).concat(command[0].replace(/^\\$0 ?/, '')); // drop $0 from default commands.\n\n        ui.span({\n          text: commandString,\n          padding: [0, 2, 0, 2],\n          width: maxWidth(commands, theWrap, \"\".concat(base$0).concat(parentCommands)) + 4\n        }, {\n          text: command[1]\n        });\n        const hints = [];\n        if (command[2]) hints.push(\"[\".concat(__('default:').slice(0, -1), \"]\")); // TODO hacking around i18n here\n\n        if (command[3] && command[3].length) {\n          hints.push(\"[\".concat(__('aliases:'), \" \").concat(command[3].join(', '), \"]\"));\n        }\n\n        if (hints.length) {\n          ui.div({\n            text: hints.join(' '),\n            padding: [0, 0, 0, 2],\n            align: 'right'\n          });\n        } else {\n          ui.div();\n        }\n      });\n      ui.div();\n    } // perform some cleanup on the keys array, making it\n    // only include top-level keys not their aliases.\n\n\n    const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);\n    keys = keys.filter(key => !yargs.parsed.newAliases[key] && aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1)); // populate 'Options:' group with any keys that have not\n    // explicitly had a group set.\n\n    if (!groups[defaultGroup]) groups[defaultGroup] = [];\n    addUngroupedKeys(keys, options.alias, groups); // display 'Options:' table along with any custom tables:\n\n    Object.keys(groups).forEach(groupName => {\n      if (!groups[groupName].length) return; // if we've grouped the key 'f', but 'f' aliases 'foobar',\n      // normalizedKeys should contain only 'foobar'.\n\n      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map(key => {\n        if (~aliasKeys.indexOf(key)) return key;\n\n        for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey;\n        }\n\n        return key;\n      });\n      if (normalizedKeys.length < 1) return;\n      ui.div(__(groupName)); // actually generate the switches string --foo, -f, --bar.\n\n      const switches = normalizedKeys.reduce((acc, key) => {\n        acc[key] = [key].concat(options.alias[key] || []).map(sw => {\n          // for the special positional group don't\n          // add '--' or '-' prefix.\n          if (groupName === self.getPositionalGroupName()) return sw;else return (sw.length > 1 ? '--' : '-') + sw;\n        }).join(', ');\n        return acc;\n      }, {});\n      normalizedKeys.forEach(key => {\n        const kswitch = switches[key];\n        let desc = descriptions[key] || '';\n        let type = null;\n        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));\n        if (~options.boolean.indexOf(key)) type = \"[\".concat(__('boolean'), \"]\");\n        if (~options.count.indexOf(key)) type = \"[\".concat(__('count'), \"]\");\n        if (~options.string.indexOf(key)) type = \"[\".concat(__('string'), \"]\");\n        if (~options.normalize.indexOf(key)) type = \"[\".concat(__('string'), \"]\");\n        if (~options.array.indexOf(key)) type = \"[\".concat(__('array'), \"]\");\n        if (~options.number.indexOf(key)) type = \"[\".concat(__('number'), \"]\");\n        const extra = [type, key in demandedOptions ? \"[\".concat(__('required'), \"]\") : null, options.choices && options.choices[key] ? \"[\".concat(__('choices:'), \" \").concat(self.stringifiedValues(options.choices[key]), \"]\") : null, defaultString(options.default[key], options.defaultDescription[key])].filter(Boolean).join(' ');\n        ui.span({\n          text: kswitch,\n          padding: [0, 2, 0, 2],\n          width: maxWidth(switches, theWrap) + 4\n        }, desc);\n        if (extra) ui.div({\n          text: extra,\n          padding: [0, 0, 0, 2],\n          align: 'right'\n        });else ui.div();\n      });\n      ui.div();\n    }); // describe some common use-cases for your application.\n\n    if (examples.length) {\n      ui.div(__('Examples:'));\n      examples.forEach(example => {\n        example[0] = example[0].replace(/\\$0/g, base$0);\n      });\n      examples.forEach(example => {\n        if (example[1] === '') {\n          ui.div({\n            text: example[0],\n            padding: [0, 2, 0, 2]\n          });\n        } else {\n          ui.div({\n            text: example[0],\n            padding: [0, 2, 0, 2],\n            width: maxWidth(examples, theWrap) + 4\n          }, {\n            text: example[1]\n          });\n        }\n      });\n      ui.div();\n    } // the usage string.\n\n\n    if (epilog) {\n      const e = epilog.replace(/\\$0/g, base$0);\n      ui.div(\"\".concat(e, \"\\n\"));\n    } // Remove the trailing white spaces\n\n\n    return ui.toString().replace(/\\s*$/, '');\n  }; // return the maximum width of a string\n  // in the left-hand column of a table.\n\n\n  function maxWidth(table, theWrap, modifier) {\n    let width = 0; // table might be of the form [leftColumn],\n    // or {key: leftColumn}\n\n    if (!Array.isArray(table)) {\n      table = Object.keys(table).map(key => [table[key]]);\n    }\n\n    table.forEach(v => {\n      width = Math.max(stringWidth(modifier ? \"\".concat(modifier, \" \").concat(v[0]) : v[0]), width);\n    }); // if we've enabled 'wrap' we should limit\n    // the max-width of the left-column.\n\n    if (theWrap) width = Math.min(width, parseInt(theWrap * 0.5, 10));\n    return width;\n  } // make sure any options set for aliases,\n  // are copied to the keys being aliased.\n\n\n  function normalizeAliases() {\n    // handle old demanded API\n    const demandedOptions = yargs.getDemandedOptions();\n    const options = yargs.getOptions();\n    (Object.keys(options.alias) || []).forEach(key => {\n      options.alias[key].forEach(alias => {\n        // copy descriptions.\n        if (descriptions[alias]) self.describe(key, descriptions[alias]); // copy demanded.\n\n        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]); // type messages.\n\n        if (~options.boolean.indexOf(alias)) yargs.boolean(key);\n        if (~options.count.indexOf(alias)) yargs.count(key);\n        if (~options.string.indexOf(alias)) yargs.string(key);\n        if (~options.normalize.indexOf(alias)) yargs.normalize(key);\n        if (~options.array.indexOf(alias)) yargs.array(key);\n        if (~options.number.indexOf(alias)) yargs.number(key);\n      });\n    });\n  } // given a set of keys, place any keys that are\n  // ungrouped under the 'Options:' grouping.\n\n\n  function addUngroupedKeys(keys, aliases, groups) {\n    let groupedKeys = [];\n    let toCheck = null;\n    Object.keys(groups).forEach(group => {\n      groupedKeys = groupedKeys.concat(groups[group]);\n    });\n    keys.forEach(key => {\n      toCheck = [key].concat(aliases[key]);\n\n      if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {\n        groups[defaultGroup].push(key);\n      }\n    });\n    return groupedKeys;\n  }\n\n  function filterHiddenOptions(key) {\n    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];\n  }\n\n  self.showHelp = level => {\n    const logger = yargs._getLoggerInstance();\n\n    if (!level) level = 'error';\n    const emit = typeof level === 'function' ? level : logger[level];\n    emit(self.help());\n  };\n\n  self.functionDescription = fn => {\n    const description = fn.name ? decamelize(fn.name, '-') : __('generated-value');\n    return ['(', description, ')'].join('');\n  };\n\n  self.stringifiedValues = function stringifiedValues(values, separator) {\n    let string = '';\n    const sep = separator || ', ';\n    const array = [].concat(values);\n    if (!values || !array.length) return string;\n    array.forEach(value => {\n      if (string.length) string += sep;\n      string += JSON.stringify(value);\n    });\n    return string;\n  }; // format the default-value-string displayed in\n  // the right-hand column.\n\n\n  function defaultString(value, defaultDescription) {\n    let string = \"[\".concat(__('default:'), \" \");\n    if (value === undefined && !defaultDescription) return null;\n\n    if (defaultDescription) {\n      string += defaultDescription;\n    } else {\n      switch (typeof value) {\n        case 'string':\n          string += \"\\\"\".concat(value, \"\\\"\");\n          break;\n\n        case 'object':\n          string += JSON.stringify(value);\n          break;\n\n        default:\n          string += value;\n      }\n    }\n\n    return \"\".concat(string, \"]\");\n  } // guess the width of the console window, max-width 80.\n\n\n  function windowWidth() {\n    const maxWidth = 80;\n\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n      return Math.min(maxWidth, process.stdout.columns);\n    } else {\n      return maxWidth;\n    }\n  } // logic for displaying application version.\n\n\n  let version = null;\n\n  self.version = ver => {\n    version = ver;\n  };\n\n  self.showVersion = () => {\n    const logger = yargs._getLoggerInstance();\n\n    logger.log(version);\n  };\n\n  self.reset = function reset(localLookup) {\n    // do not reset wrap here\n    // do not reset fails here\n    failMessage = null;\n    failureOutput = false;\n    usages = [];\n    usageDisabled = false;\n    epilog = undefined;\n    examples = [];\n    commands = [];\n    descriptions = objFilter(descriptions, (k, v) => !localLookup[k]);\n    return self;\n  };\n\n  let frozen;\n\n  self.freeze = function freeze() {\n    frozen = {};\n    frozen.failMessage = failMessage;\n    frozen.failureOutput = failureOutput;\n    frozen.usages = usages;\n    frozen.usageDisabled = usageDisabled;\n    frozen.epilog = epilog;\n    frozen.examples = examples;\n    frozen.commands = commands;\n    frozen.descriptions = descriptions;\n  };\n\n  self.unfreeze = function unfreeze() {\n    failMessage = frozen.failMessage;\n    failureOutput = frozen.failureOutput;\n    usages = frozen.usages;\n    usageDisabled = frozen.usageDisabled;\n    epilog = frozen.epilog;\n    examples = frozen.examples;\n    commands = frozen.commands;\n    descriptions = frozen.descriptions;\n    frozen = undefined;\n  };\n\n  return self;\n};","map":null,"metadata":{},"sourceType":"script"}