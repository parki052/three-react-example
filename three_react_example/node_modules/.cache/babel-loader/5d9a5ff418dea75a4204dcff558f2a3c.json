{"ast":null,"code":"'use strict';\n\nconst walker = require('walker');\n\nconst anymatch = require('anymatch');\n\nconst micromatch = require('micromatch');\n\nconst path = require('path');\n\nconst platform = require('os').platform();\n/**\n * Constants\n */\n\n\nexports.DEFAULT_DELAY = 100;\nexports.CHANGE_EVENT = 'change';\nexports.DELETE_EVENT = 'delete';\nexports.ADD_EVENT = 'add';\nexports.ALL_EVENT = 'all';\n/**\n * Assigns options to the watcher.\n *\n * @param {NodeWatcher|PollWatcher|WatchmanWatcher} watcher\n * @param {?object} opts\n * @return {boolean}\n * @public\n */\n\nexports.assignOptions = function (watcher, opts) {\n  opts = opts || {};\n  watcher.globs = opts.glob || [];\n  watcher.dot = opts.dot || false;\n  watcher.ignored = opts.ignored || false;\n\n  if (!Array.isArray(watcher.globs)) {\n    watcher.globs = [watcher.globs];\n  }\n\n  watcher.hasIgnore = Boolean(opts.ignored) && !(Array.isArray(opts) && opts.length > 0);\n  watcher.doIgnore = opts.ignored ? anymatch(opts.ignored) : () => false;\n\n  if (opts.watchman && opts.watchmanPath) {\n    watcher.watchmanPath = opts.watchmanPath;\n  }\n\n  return opts;\n};\n/**\n * Checks a file relative path against the globs array.\n *\n * @param {array} globs\n * @param {string} relativePath\n * @return {boolean}\n * @public\n */\n\n\nexports.isFileIncluded = function (globs, dot, doIgnore, relativePath) {\n  if (doIgnore(relativePath)) {\n    return false;\n  }\n\n  return globs.length ? micromatch.some(relativePath, globs, {\n    dot: dot\n  }) : dot || micromatch.some(relativePath, '**/*');\n};\n/**\n * Traverse a directory recursively calling `callback` on every directory.\n *\n * @param {string} dir\n * @param {function} dirCallback\n * @param {function} fileCallback\n * @param {function} endCallback\n * @param {*} ignored\n * @public\n */\n\n\nexports.recReaddir = function (dir, dirCallback, fileCallback, endCallback, errorCallback, ignored) {\n  walker(dir).filterDir(currentDir => !anymatch(ignored, currentDir)).on('dir', normalizeProxy(dirCallback)).on('file', normalizeProxy(fileCallback)).on('error', errorCallback).on('end', () => {\n    if (platform === 'win32') {\n      setTimeout(endCallback, 1000);\n    } else {\n      endCallback();\n    }\n  });\n};\n/**\n * Returns a callback that when called will normalize a path and call the\n * original callback\n *\n * @param {function} callback\n * @return {function}\n * @private\n */\n\n\nfunction normalizeProxy(callback) {\n  return (filepath, stats) => callback(path.normalize(filepath), stats);\n}","map":null,"metadata":{},"sourceType":"script"}