{"ast":null,"code":"'use strict'; // hoisted due to circular dependency on command.\n\nmodule.exports = argsert;\n\nconst command = require('./command')();\n\nconst YError = require('./yerror');\n\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\n\nfunction argsert(expected, callerArguments, length) {\n  // TODO: should this eventually raise an exception.\n  try {\n    // preface the argument description with \"cmd\", so\n    // that we can run it through yargs' command parser.\n    let position = 0;\n    let parsed = {\n      demanded: [],\n      optional: []\n    };\n\n    if (typeof expected === 'object') {\n      length = callerArguments;\n      callerArguments = expected;\n    } else {\n      parsed = command.parseCommand(\"cmd \".concat(expected));\n    }\n\n    const args = [].slice.call(callerArguments);\n\n    while (args.length && args[args.length - 1] === undefined) args.pop();\n\n    length = length || args.length;\n\n    if (length < parsed.demanded.length) {\n      throw new YError(\"Not enough arguments provided. Expected \".concat(parsed.demanded.length, \" but received \").concat(args.length, \".\"));\n    }\n\n    const totalCommands = parsed.demanded.length + parsed.optional.length;\n\n    if (length > totalCommands) {\n      throw new YError(\"Too many arguments provided. Expected max \".concat(totalCommands, \" but received \").concat(length, \".\"));\n    }\n\n    parsed.demanded.forEach(demanded => {\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position, false);\n      position += 1;\n    });\n    parsed.optional.forEach(optional => {\n      if (args.length === 0) return;\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position, true);\n      position += 1;\n    });\n  } catch (err) {\n    console.warn(err.stack);\n  }\n}\n\nfunction guessType(arg) {\n  if (Array.isArray(arg)) {\n    return 'array';\n  } else if (arg === null) {\n    return 'null';\n  }\n\n  return typeof arg;\n}\n\nfunction argumentTypeError(observedType, allowedTypes, position, optional) {\n  throw new YError(\"Invalid \".concat(positionName[position] || 'manyith', \" argument. Expected \").concat(allowedTypes.join(' or '), \" but received \").concat(observedType, \".\"));\n}","map":null,"metadata":{},"sourceType":"script"}