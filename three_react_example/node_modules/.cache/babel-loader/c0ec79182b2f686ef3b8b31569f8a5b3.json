{"ast":null,"code":"'use strict';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst prompts = require('./prompts');\n\nconst passOn = ['suggest', 'format', 'onState', 'validate', 'onRender'];\n\nconst noop = () => {};\n/**\n * Prompt for a series of questions\n * @param {Array|Object} questions Single question object or Array of question objects\n * @param {Function} [onSubmit] Callback function called on prompt submit\n * @param {Function} [onCancel] Callback function called on cancel/abort\n * @returns {Object} Object with values from user input\n */\n\n\nfunction prompt() {\n  return _prompt.apply(this, arguments);\n}\n\nfunction _prompt() {\n  _prompt = _asyncToGenerator(function* (questions = [], {\n    onSubmit = noop,\n    onCancel = noop\n  } = {}) {\n    const answers = {};\n    const override = prompt._override || {};\n    questions = [].concat(questions);\n    let answer, question, quit, name, type;\n\n    const getFormattedAnswer =\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(function* (question, answer, skipValidation = false) {\n        if (!skipValidation && question.validate && question.validate(answer) !== true) {\n          return;\n        }\n\n        return question.format ? yield question.format(answer, answers) : answer;\n      });\n\n      return function getFormattedAnswer(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = questions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        question = _step.value;\n        var _question = question;\n        name = _question.name;\n        type = _question.type; // if property is a function, invoke it unless it's a special function\n\n        for (let key in question) {\n          if (passOn.includes(key)) continue;\n          let value = question[key];\n          question[key] = typeof value === 'function' ? yield value(answer, _objectSpread({}, answers), question) : value;\n        }\n\n        if (typeof question.message !== 'string') {\n          throw new Error('prompt message is required');\n        } // update vars in case they changed\n\n\n        var _question2 = question;\n        name = _question2.name;\n        type = _question2.type; // skip if type is a falsy value\n\n        if (!type) continue;\n\n        if (prompts[type] === void 0) {\n          throw new Error(\"prompt type (\".concat(type, \") is not defined\"));\n        }\n\n        if (override[question.name] !== undefined) {\n          answer = yield getFormattedAnswer(question, override[question.name]);\n\n          if (answer !== undefined) {\n            answers[name] = answer;\n            continue;\n          }\n        }\n\n        try {\n          // Get the injected answer if there is one or prompt the user\n          answer = prompt._injected ? getInjectedAnswer(prompt._injected) : yield prompts[type](question);\n          answers[name] = answer = yield getFormattedAnswer(question, answer, true);\n          quit = yield onSubmit(question, answer, answers);\n        } catch (err) {\n          quit = !(yield onCancel(question, answers));\n        }\n\n        if (quit) return answers;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return answers;\n  });\n  return _prompt.apply(this, arguments);\n}\n\nfunction getInjectedAnswer(injected) {\n  const answer = injected.shift();\n\n  if (answer instanceof Error) {\n    throw answer;\n  }\n\n  return answer;\n}\n\nfunction inject(answers) {\n  prompt._injected = (prompt._injected || []).concat(answers);\n}\n\nfunction override(answers) {\n  prompt._override = Object.assign({}, answers);\n}\n\nmodule.exports = Object.assign(prompt, {\n  prompt,\n  prompts,\n  inject,\n  override\n});","map":null,"metadata":{},"sourceType":"script"}