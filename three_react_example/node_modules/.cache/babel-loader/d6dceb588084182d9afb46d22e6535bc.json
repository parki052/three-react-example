{"ast":null,"code":"'use strict';\n\nconst prompts = require('./prompts');\n\nconst passOn = ['suggest', 'format', 'onState', 'validate', 'onRender'];\n\nconst noop = () => {};\n/**\n * Prompt for a series of questions\n * @param {Array|Object} questions Single question object or Array of question objects\n * @param {Function} [onSubmit] Callback function called on prompt submit\n * @param {Function} [onCancel] Callback function called on cancel/abort\n * @returns {Object} Object with values from user input\n */\n\n\nasync function prompt(questions = [], {\n  onSubmit = noop,\n  onCancel = noop\n} = {}) {\n  const answers = {};\n  const override = prompt._override || {};\n  questions = [].concat(questions);\n  let answer, question, quit, name, type;\n\n  const getFormattedAnswer = async (question, answer, skipValidation = false) => {\n    if (!skipValidation && question.validate && question.validate(answer) !== true) {\n      return;\n    }\n\n    return question.format ? await question.format(answer, answers) : answer;\n  };\n\n  for (question of questions) {\n    var _question = question;\n    name = _question.name;\n    type = _question.type;\n\n    // if property is a function, invoke it unless it's a special function\n    for (let key in question) {\n      if (passOn.includes(key)) continue;\n      let value = question[key];\n      question[key] = typeof value === 'function' ? await value(answer, { ...answers\n      }, question) : value;\n    }\n\n    if (typeof question.message !== 'string') {\n      throw new Error('prompt message is required');\n    } // update vars in case they changed\n\n\n    var _question2 = question;\n    name = _question2.name;\n    type = _question2.type;\n    // skip if type is a falsy value\n    if (!type) continue;\n\n    if (prompts[type] === void 0) {\n      throw new Error(\"prompt type (\".concat(type, \") is not defined\"));\n    }\n\n    if (override[question.name] !== undefined) {\n      answer = await getFormattedAnswer(question, override[question.name]);\n\n      if (answer !== undefined) {\n        answers[name] = answer;\n        continue;\n      }\n    }\n\n    try {\n      // Get the injected answer if there is one or prompt the user\n      answer = prompt._injected ? getInjectedAnswer(prompt._injected) : await prompts[type](question);\n      answers[name] = answer = await getFormattedAnswer(question, answer, true);\n      quit = await onSubmit(question, answer, answers);\n    } catch (err) {\n      quit = !(await onCancel(question, answers));\n    }\n\n    if (quit) return answers;\n  }\n\n  return answers;\n}\n\nfunction getInjectedAnswer(injected) {\n  const answer = injected.shift();\n\n  if (answer instanceof Error) {\n    throw answer;\n  }\n\n  return answer;\n}\n\nfunction inject(answers) {\n  prompt._injected = (prompt._injected || []).concat(answers);\n}\n\nfunction override(answers) {\n  prompt._override = Object.assign({}, answers);\n}\n\nmodule.exports = Object.assign(prompt, {\n  prompt,\n  prompts,\n  inject,\n  override\n});","map":null,"metadata":{},"sourceType":"script"}