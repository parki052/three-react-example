{"ast":null,"code":"'use strict';\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _realpathNative() {\n  const data = require('realpath-native');\n\n  _realpathNative = function _realpathNative() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _nodeModulesPaths = _interopRequireDefault(require('./nodeModulesPaths'));\n\nvar _isBuiltinModule = _interopRequireDefault(require('./isBuiltinModule'));\n\nvar _defaultResolver = _interopRequireWildcard(require('./defaultResolver'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst NATIVE_PLATFORM = 'native'; // We might be inside a symlink.\n\nconst cwd = process.cwd();\nconst resolvedCwd = (0, _realpathNative().sync)(cwd) || cwd;\nconst NODE_PATH = process.env.NODE_PATH;\nconst nodePaths = NODE_PATH ? NODE_PATH.split(_path().default.delimiter).filter(Boolean) // The resolver expects absolute paths.\n.map(p => _path().default.resolve(resolvedCwd, p)) : undefined;\n/* eslint-disable-next-line no-redeclare */\n\nclass Resolver {\n  constructor(moduleMap, options) {\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_moduleMap', void 0);\n\n    _defineProperty(this, '_moduleIDCache', void 0);\n\n    _defineProperty(this, '_moduleNameCache', void 0);\n\n    _defineProperty(this, '_modulePathCache', void 0);\n\n    _defineProperty(this, '_supportsNativePlatform', void 0);\n\n    this._options = {\n      browser: options.browser,\n      defaultPlatform: options.defaultPlatform,\n      extensions: options.extensions,\n      hasCoreModules: options.hasCoreModules === undefined ? true : options.hasCoreModules,\n      moduleDirectories: options.moduleDirectories || ['node_modules'],\n      moduleNameMapper: options.moduleNameMapper,\n      modulePaths: options.modulePaths,\n      platforms: options.platforms,\n      resolver: options.resolver,\n      rootDir: options.rootDir\n    };\n    this._supportsNativePlatform = options.platforms ? options.platforms.includes(NATIVE_PLATFORM) : false;\n    this._moduleMap = moduleMap;\n    this._moduleIDCache = new Map();\n    this._moduleNameCache = new Map();\n    this._modulePathCache = new Map();\n  }\n\n  static clearDefaultResolverCache() {\n    (0, _defaultResolver.clearDefaultResolverCache)();\n  }\n\n  static findNodeModule(path, options) {\n    const resolver = options.resolver ? require(options.resolver) : _defaultResolver.default;\n    const paths = options.paths;\n\n    try {\n      return resolver(path, {\n        basedir: options.basedir,\n        browser: options.browser,\n        defaultResolver: _defaultResolver.default,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir\n      });\n    } catch (e) {}\n\n    return null;\n  }\n\n  resolveModuleFromDirIfExists(dirname, moduleName, options) {\n    const paths = options && options.paths || this._options.modulePaths;\n    const moduleDirectory = this._options.moduleDirectories;\n    const key = dirname + _path().default.delimiter + moduleName;\n    const defaultPlatform = this._options.defaultPlatform;\n\n    const extensions = this._options.extensions.slice();\n\n    let module;\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => '.' + NATIVE_PLATFORM + ext));\n    }\n\n    if (defaultPlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => '.' + defaultPlatform + ext));\n    } // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n\n\n    const cacheResult = this._moduleNameCache.get(key);\n\n    if (cacheResult) {\n      return cacheResult;\n    } // 2. Check if the module is a haste module.\n\n\n    module = this.getModule(moduleName);\n\n    if (module) {\n      this._moduleNameCache.set(key, module);\n\n      return module;\n    } // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n\n\n    const skipResolution = options && options.skipNodeResolution && !moduleName.includes(_path().default.sep);\n\n    const resolveNodeModule = name => Resolver.findNodeModule(name, {\n      basedir: dirname,\n      browser: this._options.browser,\n      extensions,\n      moduleDirectory,\n      paths,\n      resolver: this._options.resolver,\n      rootDir: this._options.rootDir\n    });\n\n    if (!skipResolution) {\n      module = resolveNodeModule(moduleName);\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n\n        return module;\n      }\n    } // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n\n\n    const parts = moduleName.split('/');\n    const hastePackage = this.getPackage(parts.shift());\n\n    if (hastePackage) {\n      try {\n        const module = _path().default.join.apply(_path().default, [_path().default.dirname(hastePackage)].concat(parts)); // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n\n\n        const resolvedModule = resolveNodeModule(module) || require.resolve(module);\n\n        this._moduleNameCache.set(key, resolvedModule);\n\n        return resolvedModule;\n      } catch (ignoredError) {}\n    }\n\n    return null;\n  }\n\n  resolveModule(from, moduleName, options) {\n    const dirname = _path().default.dirname(from);\n\n    const module = this.resolveStubModuleName(from, moduleName) || this.resolveModuleFromDirIfExists(dirname, moduleName, options);\n    if (module) return module; // 5. Throw an error if the module could not be found. `resolve.sync` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n\n    const relativePath = _path().default.relative(dirname, from);\n\n    const err = new Error(\"Cannot find module '\".concat(moduleName, \"' from '\").concat(relativePath || '.', \"'\"));\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  }\n\n  isCoreModule(moduleName) {\n    return this._options.hasCoreModules && (0, _isBuiltinModule.default)(moduleName);\n  }\n\n  getModule(name) {\n    return this._moduleMap.getModule(name, this._options.defaultPlatform, this._supportsNativePlatform);\n  }\n\n  getModulePath(from, moduleName) {\n    if (moduleName[0] !== '.' || _path().default.isAbsolute(moduleName)) {\n      return moduleName;\n    }\n\n    return _path().default.normalize(_path().default.dirname(from) + '/' + moduleName);\n  }\n\n  getPackage(name) {\n    return this._moduleMap.getPackage(name, this._options.defaultPlatform, this._supportsNativePlatform);\n  }\n\n  getMockModule(from, name) {\n    const mock = this._moduleMap.getMockModule(name);\n\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = this.resolveStubModuleName(from, name);\n\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n\n    return null;\n  }\n\n  getModulePaths(from) {\n    const cachedModule = this._modulePathCache.get(from);\n\n    if (cachedModule) {\n      return cachedModule;\n    }\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const paths = (0, _nodeModulesPaths.default)(from, {\n      moduleDirectory\n    });\n\n    if (paths[paths.length - 1] === undefined) {\n      // circumvent node-resolve bug that adds `undefined` as last item.\n      paths.pop();\n    }\n\n    this._modulePathCache.set(from, paths);\n\n    return paths;\n  }\n\n  getModuleID(virtualMocks, from, _moduleName) {\n    const moduleName = _moduleName || '';\n    const key = from + _path().default.delimiter + moduleName;\n\n    const cachedModuleID = this._moduleIDCache.get(key);\n\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n\n    const absolutePath = this._getAbsolutePath(virtualMocks, from, moduleName);\n\n    const mockPath = this._getMockPath(from, moduleName);\n\n    const sep = _path().default.delimiter;\n\n    const id = moduleType + sep + (absolutePath ? absolutePath + sep : '') + (mockPath ? mockPath + sep : '');\n\n    this._moduleIDCache.set(key, id);\n\n    return id;\n  }\n\n  _getModuleType(moduleName) {\n    return this.isCoreModule(moduleName) ? 'node' : 'user';\n  }\n\n  _getAbsolutePath(virtualMocks, from, moduleName) {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n\n    return this._isModuleResolved(from, moduleName) ? this.getModule(moduleName) : this._getVirtualMockPath(virtualMocks, from, moduleName);\n  }\n\n  _getMockPath(from, moduleName) {\n    return !this.isCoreModule(moduleName) ? this.getMockModule(from, moduleName) : null;\n  }\n\n  _getVirtualMockPath(virtualMocks, from, moduleName) {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks[virtualMockPath] ? virtualMockPath : moduleName ? this.resolveModule(from, moduleName) : from;\n  }\n\n  _isModuleResolved(from, moduleName) {\n    return !!(this.getModule(moduleName) || this.getMockModule(from, moduleName));\n  }\n\n  resolveStubModuleName(from, moduleName) {\n    const dirname = _path().default.dirname(from);\n\n    const paths = this._options.modulePaths;\n\n    const extensions = this._options.extensions.slice();\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n    const defaultPlatform = this._options.defaultPlatform;\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => '.' + NATIVE_PLATFORM + ext));\n    }\n\n    if (defaultPlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => '.' + defaultPlatform + ext));\n    }\n\n    if (moduleNameMapper) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = moduleNameMapper[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          const _step$value = _step.value,\n                mappedModuleName = _step$value.moduleName,\n                regex = _step$value.regex;\n\n          if (regex.test(moduleName)) {\n            // Note: once a moduleNameMapper matches the name, it must result\n            // in a module, or else an error is thrown.\n            const matches = moduleName.match(regex);\n            const updatedName = matches ? mappedModuleName.replace(/\\$([0-9]+)/g, (_, index) => matches[parseInt(index, 10)]) : mappedModuleName;\n            const module = this.getModule(updatedName) || Resolver.findNodeModule(updatedName, {\n              basedir: dirname,\n              browser: this._options.browser,\n              extensions,\n              moduleDirectory,\n              paths,\n              resolver,\n              rootDir: this._options.rootDir\n            });\n\n            if (!module) {\n              throw createNoMappedModuleFoundError(moduleName, updatedName, mappedModuleName, regex, resolver);\n            }\n\n            return module;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n}\n\nconst createNoMappedModuleFoundError = (moduleName, updatedName, mappedModuleName, regex, resolver) => {\n  const error = new Error(_chalk().default.red(\"\".concat(_chalk().default.bold('Configuration error'), \":\\n\\nCould not locate module \").concat(_chalk().default.bold(moduleName), \" mapped as:\\n\").concat(_chalk().default.bold(updatedName), \".\\n\\nPlease check your configuration for these entries:\\n{\\n  \\\"moduleNameMapper\\\": {\\n    \\\"\").concat(regex.toString(), \"\\\": \\\"\").concat(_chalk().default.bold(mappedModuleName), \"\\\"\\n  },\\n  \\\"resolver\\\": \").concat(_chalk().default.bold(String(resolver)), \"\\n}\")));\n  error.name = '';\n  return error;\n};\n\nmodule.exports = Resolver;","map":null,"metadata":{},"sourceType":"script"}