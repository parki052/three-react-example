{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = normalize;\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function _glob() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestValidate() {\n  const data = require('jest-validate');\n\n  _jestValidate = function _jestValidate() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function _micromatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _realpathNative() {\n  const data = require('realpath-native');\n\n  _realpathNative = function _realpathNative() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function _jestResolve() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestGetType() {\n  const data = _interopRequireDefault(require('jest-get-type'));\n\n  _jestGetType = function _jestGetType() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _validatePattern = _interopRequireDefault(require('./validatePattern'));\n\nvar _getMaxWorkers = _interopRequireDefault(require('./getMaxWorkers'));\n\nvar _utils = require('./utils');\n\nvar _constants = require('./constants');\n\nvar _ReporterValidationErrors = require('./ReporterValidationErrors');\n\nvar _Defaults = _interopRequireDefault(require('./Defaults'));\n\nvar _Deprecated = _interopRequireDefault(require('./Deprecated'));\n\nvar _setFromArgv = _interopRequireDefault(require('./setFromArgv'));\n\nvar _ValidConfig = _interopRequireDefault(require('./ValidConfig'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst ERROR = \"\".concat(_utils.BULLET, \"Validation Error\");\nconst PRESET_EXTENSIONS = ['.json', '.js'];\nconst PRESET_NAME = 'jest-preset';\n\nconst createConfigError = message => new (_jestValidate().ValidationError)(ERROR, message, _utils.DOCUMENTATION_NOTE); // TS 3.5 forces us to split these into 2\n\n\nconst mergeModuleNameMapperWithPreset = (options, preset) => {\n  if (options['moduleNameMapper'] && preset['moduleNameMapper']) {\n    options['moduleNameMapper'] = _objectSpread({}, options['moduleNameMapper'], preset['moduleNameMapper'], options['moduleNameMapper']);\n  }\n};\n\nconst mergeTransformWithPreset = (options, preset) => {\n  if (options['transform'] && preset['transform']) {\n    options['transform'] = _objectSpread({}, options['transform'], preset['transform'], options['transform']);\n  }\n};\n\nconst setupPreset = (options, optionsPreset) => {\n  let preset;\n  const presetPath = (0, _utils.replaceRootDirInPath)(options.rootDir, optionsPreset);\n\n  const presetModule = _jestResolve().default.findNodeModule(presetPath.startsWith('.') ? presetPath : _path().default.join(presetPath, PRESET_NAME), {\n    basedir: options.rootDir,\n    extensions: PRESET_EXTENSIONS\n  });\n\n  try {\n    // Force re-evaluation to support multiple projects\n    try {\n      if (presetModule) {\n        delete require.cache[require.resolve(presetModule)];\n      }\n    } catch (e) {} // @ts-ignore: `presetModule` can be null?\n\n\n    preset = require(presetModule);\n  } catch (error) {\n    if (error instanceof SyntaxError || error instanceof TypeError) {\n      throw createConfigError(\"  Preset \".concat(_chalk().default.bold(presetPath), \" is invalid:\\n\\n  \").concat(error.message, \"\\n  \").concat(error.stack));\n    }\n\n    const preset = _jestResolve().default.findNodeModule(presetPath, {\n      basedir: options.rootDir\n    });\n\n    if (preset) {\n      throw createConfigError(\"  Module \".concat(_chalk().default.bold(presetPath), \" should have \\\"jest-preset.js\\\" or \\\"jest-preset.json\\\" file at the root.\"));\n    }\n\n    throw createConfigError(\"  Preset \".concat(_chalk().default.bold(presetPath), \" not found.\"));\n  }\n\n  if (options.setupFiles) {\n    options.setupFiles = (preset.setupFiles || []).concat(options.setupFiles);\n  }\n\n  if (options.modulePathIgnorePatterns && preset.modulePathIgnorePatterns) {\n    options.modulePathIgnorePatterns = preset.modulePathIgnorePatterns.concat(options.modulePathIgnorePatterns);\n  }\n\n  mergeModuleNameMapperWithPreset(options, preset);\n  mergeTransformWithPreset(options, preset);\n  return _objectSpread({}, preset, options);\n};\n\nconst setupBabelJest = options => {\n  const transform = options.transform;\n  let babelJest;\n\n  if (transform) {\n    const customJSPattern = Object.keys(transform).find(pattern => {\n      const regex = new RegExp(pattern);\n      return regex.test('a.js') || regex.test('a.jsx');\n    });\n    const customTSPattern = Object.keys(transform).find(pattern => {\n      const regex = new RegExp(pattern);\n      return regex.test('a.ts') || regex.test('a.tsx');\n    });\n    [customJSPattern, customTSPattern].forEach(pattern => {\n      if (pattern) {\n        const customTransformer = transform[pattern];\n\n        if (Array.isArray(customTransformer)) {\n          if (customTransformer[0] === 'babel-jest') {\n            babelJest = require.resolve('babel-jest');\n            customTransformer[0] = babelJest;\n          } else if (customTransformer[0].includes('babel-jest')) {\n            babelJest = customTransformer[0];\n          }\n        } else {\n          if (customTransformer === 'babel-jest') {\n            babelJest = require.resolve('babel-jest');\n            transform[pattern] = babelJest;\n          } else if (customTransformer.includes('babel-jest')) {\n            babelJest = customTransformer;\n          }\n        }\n      }\n    });\n  } else {\n    babelJest = require.resolve('babel-jest');\n    options.transform = {\n      [_constants.DEFAULT_JS_PATTERN]: babelJest\n    };\n  }\n};\n\nconst normalizeCollectCoverageOnlyFrom = (options, key) => {\n  const initialCollectCoverageFrom = options[key];\n  const collectCoverageOnlyFrom = Array.isArray(initialCollectCoverageFrom) ? initialCollectCoverageFrom // passed from argv\n  : Object.keys(initialCollectCoverageFrom); // passed from options\n\n  return collectCoverageOnlyFrom.reduce((map, filePath) => {\n    filePath = _path().default.resolve(options.rootDir, (0, _utils.replaceRootDirInPath)(options.rootDir, filePath));\n    map[filePath] = true;\n    return map;\n  }, Object.create(null));\n};\n\nconst normalizeCollectCoverageFrom = (options, key) => {\n  const initialCollectCoverageFrom = options[key];\n  let value;\n\n  if (!initialCollectCoverageFrom) {\n    value = [];\n  }\n\n  if (!Array.isArray(initialCollectCoverageFrom)) {\n    try {\n      value = JSON.parse(initialCollectCoverageFrom);\n    } catch (e) {}\n\n    if (options[key] && !Array.isArray(value)) {\n      value = [initialCollectCoverageFrom];\n    }\n  } else {\n    value = initialCollectCoverageFrom;\n  }\n\n  if (value) {\n    value = value.map(filePath => filePath.replace(/^(!?)(<rootDir>\\/)(.*)/, '$1$3'));\n  }\n\n  return value;\n};\n\nconst normalizeUnmockedModulePathPatterns = (options, key // _replaceRootDirTags is specifically well-suited for substituting\n// <rootDir> in paths (it deals with properly interpreting relative path\n// separators, etc).\n//\n// For patterns, direct global substitution is far more ideal, so we\n// special case substitutions for patterns here.\n) => options[key].map(pattern => (0, _jestRegexUtil().replacePathSepForRegex)(pattern.replace(/<rootDir>/g, options.rootDir)));\n\nconst normalizePreprocessor = options => {\n  if (options.scriptPreprocessor && options.transform) {\n    throw createConfigError(\"  Options: \".concat(_chalk().default.bold('scriptPreprocessor'), \" and \").concat(_chalk().default.bold('transform'), \" cannot be used together.\\n  Please change your configuration to only use \").concat(_chalk().default.bold('transform'), \".\"));\n  }\n\n  if (options.preprocessorIgnorePatterns && options.transformIgnorePatterns) {\n    throw createConfigError(\"  Options \".concat(_chalk().default.bold('preprocessorIgnorePatterns'), \" and \").concat(_chalk().default.bold('transformIgnorePatterns'), \" cannot be used together.\\n  Please change your configuration to only use \").concat(_chalk().default.bold('transformIgnorePatterns'), \".\"));\n  }\n\n  if (options.scriptPreprocessor) {\n    options.transform = {\n      '.*': options.scriptPreprocessor\n    };\n  }\n\n  if (options.preprocessorIgnorePatterns) {\n    options.transformIgnorePatterns = options.preprocessorIgnorePatterns;\n  }\n\n  delete options.scriptPreprocessor;\n  delete options.preprocessorIgnorePatterns;\n  return options;\n};\n\nconst normalizeMissingOptions = (options, configPath, projectIndex) => {\n  if (!options.name) {\n    options.name = _crypto().default.createHash('md5').update(options.rootDir) // In case we load config from some path that has the same root dir\n    .update(configPath || '').update(String(projectIndex)).digest('hex');\n  }\n\n  if (!options.setupFiles) {\n    options.setupFiles = [];\n  }\n\n  return options;\n};\n\nconst normalizeRootDir = options => {\n  // Assert that there *is* a rootDir\n  if (!options.hasOwnProperty('rootDir')) {\n    throw createConfigError(\"  Configuration option \".concat(_chalk().default.bold('rootDir'), \" must be specified.\"));\n  }\n\n  options.rootDir = _path().default.normalize(options.rootDir);\n\n  try {\n    // try to resolve windows short paths, ignoring errors (permission errors, mostly)\n    options.rootDir = (0, _realpathNative().sync)(options.rootDir);\n  } catch (e) {// ignored\n  }\n\n  return options;\n};\n\nconst normalizeReporters = options => {\n  const reporters = options.reporters;\n\n  if (!reporters || !Array.isArray(reporters)) {\n    return options;\n  }\n\n  (0, _ReporterValidationErrors.validateReporters)(reporters);\n  options.reporters = reporters.map(reporterConfig => {\n    const normalizedReporterConfig = typeof reporterConfig === 'string' // if reporter config is a string, we wrap it in an array\n    ? // and pass an empty object for options argument, to normalize\n    [reporterConfig, {}] : reporterConfig;\n    const reporterPath = (0, _utils.replaceRootDirInPath)(options.rootDir, normalizedReporterConfig[0]);\n\n    if (reporterPath !== _constants.DEFAULT_REPORTER_LABEL) {\n      const reporter = _jestResolve().default.findNodeModule(reporterPath, {\n        basedir: options.rootDir\n      });\n\n      if (!reporter) {\n        throw new Error(\"Could not resolve a module for a custom reporter.\\n\" + \"  Module name: \".concat(reporterPath));\n      }\n\n      normalizedReporterConfig[0] = reporter;\n    }\n\n    return normalizedReporterConfig;\n  });\n  return options;\n};\n\nconst buildTestPathPattern = argv => {\n  const patterns = [];\n\n  if (argv._) {\n    patterns.push(...argv._);\n  }\n\n  if (argv.testPathPattern) {\n    patterns.push(...argv.testPathPattern);\n  }\n\n  const replacePosixSep = pattern => {\n    if (_path().default.sep === '/') {\n      return pattern;\n    }\n\n    return pattern.replace(/\\//g, '\\\\\\\\');\n  };\n\n  const testPathPattern = patterns.map(replacePosixSep).join('|');\n\n  if ((0, _validatePattern.default)(testPathPattern)) {\n    return testPathPattern;\n  } else {\n    showTestPathPatternError(testPathPattern);\n    return '';\n  }\n};\n\nconst showTestPathPatternError = testPathPattern => {\n  (0, _jestUtil().clearLine)(process.stdout);\n  console.log(_chalk().default.red(\"  Invalid testPattern \".concat(testPathPattern, \" supplied. \") + \"Running all tests instead.\"));\n};\n\nfunction normalize(options, argv, configPath, projectIndex = Infinity) {\n  const _validate = (0, _jestValidate().validate)(options, {\n    comment: _utils.DOCUMENTATION_NOTE,\n    deprecatedConfig: _Deprecated.default,\n    exampleConfig: _ValidConfig.default,\n    recursiveBlacklist: ['collectCoverageOnlyFrom', // 'coverageThreshold' allows to use 'global' and glob strings on the same\n    'coverageThreshold', 'globals', 'moduleNameMapper', 'testEnvironmentOptions', 'transform']\n  }),\n        hasDeprecationWarnings = _validate.hasDeprecationWarnings;\n\n  options = normalizePreprocessor(normalizeReporters(normalizeMissingOptions(normalizeRootDir((0, _setFromArgv.default)(options, argv)), configPath, projectIndex)));\n\n  if (options.preset) {\n    options = setupPreset(options, options.preset);\n  }\n\n  if (!options.setupFilesAfterEnv) {\n    options.setupFilesAfterEnv = [];\n  }\n\n  if (options.setupTestFrameworkScriptFile && options.setupFilesAfterEnv.length > 0) {\n    throw createConfigError(\"  Options: \".concat(_chalk().default.bold('setupTestFrameworkScriptFile'), \" and \").concat(_chalk().default.bold('setupFilesAfterEnv'), \" cannot be used together.\\n  Please change your configuration to only use \").concat(_chalk().default.bold('setupFilesAfterEnv'), \".\"));\n  }\n\n  if (options.setupTestFrameworkScriptFile) {\n    options.setupFilesAfterEnv.push(options.setupTestFrameworkScriptFile);\n  }\n\n  options.testEnvironment = (0, _utils.getTestEnvironment)({\n    rootDir: options.rootDir,\n    testEnvironment: options.testEnvironment || _Defaults.default.testEnvironment\n  });\n\n  if (!options.roots && options.testPathDirs) {\n    options.roots = options.testPathDirs;\n    delete options.testPathDirs;\n  }\n\n  if (!options.roots) {\n    options.roots = [options.rootDir];\n  }\n\n  if (!options.testRunner || options.testRunner === 'jasmine2') {\n    options.testRunner = require.resolve('jest-jasmine2');\n  }\n\n  if (!options.coverageDirectory) {\n    options.coverageDirectory = _path().default.resolve(options.rootDir, 'coverage');\n  }\n\n  setupBabelJest(options); // TODO: Type this properly\n\n  const newOptions = _objectSpread({}, _Defaults.default);\n\n  if (options.resolver) {\n    newOptions.resolver = (0, _utils.resolve)(null, {\n      filePath: options.resolver,\n      key: 'resolver',\n      rootDir: options.rootDir\n    });\n  }\n\n  const optionKeys = Object.keys(options);\n  optionKeys.reduce((newOptions, key) => {\n    // The resolver has been resolved separately; skip it\n    if (key === 'resolver') {\n      return newOptions;\n    } // This is cheating, because it claims that all keys of InitialOptions are Required.\n    // We only really know it's Required for oldOptions[key], not for oldOptions.someOtherKey,\n    // so oldOptions[key] is the only way it should be used.\n\n\n    const oldOptions = options;\n    let value;\n\n    switch (key) {\n      case 'collectCoverageOnlyFrom':\n        value = normalizeCollectCoverageOnlyFrom(oldOptions, key);\n        break;\n\n      case 'setupFiles':\n      case 'setupFilesAfterEnv':\n      case 'snapshotSerializers':\n        {\n          const option = oldOptions[key];\n          value = option && option.map(filePath => (0, _utils.resolve)(newOptions.resolver, {\n            filePath,\n            key,\n            rootDir: options.rootDir\n          }));\n        }\n        break;\n\n      case 'modulePaths':\n      case 'roots':\n        {\n          const option = oldOptions[key];\n          value = option && option.map(filePath => _path().default.resolve(options.rootDir, (0, _utils.replaceRootDirInPath)(options.rootDir, filePath)));\n        }\n        break;\n\n      case 'collectCoverageFrom':\n        value = normalizeCollectCoverageFrom(oldOptions, key);\n        break;\n\n      case 'cacheDirectory':\n      case 'coverageDirectory':\n        {\n          const option = oldOptions[key];\n          value = option && _path().default.resolve(options.rootDir, (0, _utils.replaceRootDirInPath)(options.rootDir, option));\n        }\n        break;\n\n      case 'dependencyExtractor':\n      case 'globalSetup':\n      case 'globalTeardown':\n      case 'moduleLoader':\n      case 'snapshotResolver':\n      case 'testResultsProcessor':\n      case 'testRunner':\n      case 'filter':\n        {\n          const option = oldOptions[key];\n          value = option && (0, _utils.resolve)(newOptions.resolver, {\n            filePath: option,\n            key,\n            rootDir: options.rootDir\n          });\n        }\n        break;\n\n      case 'runner':\n        {\n          const option = oldOptions[key];\n          value = option && (0, _utils.getRunner)(newOptions.resolver, {\n            filePath: option,\n            rootDir: options.rootDir\n          });\n        }\n        break;\n\n      case 'prettierPath':\n        {\n          // We only want this to throw if \"prettierPath\" is explicitly passed\n          // from config or CLI, and the requested path isn't found. Otherwise we\n          // set it to null and throw an error lazily when it is used.\n          const option = oldOptions[key];\n          value = option && (0, _utils.resolve)(newOptions.resolver, {\n            filePath: option,\n            key,\n            optional: option === _Defaults.default[key],\n            rootDir: options.rootDir\n          });\n        }\n        break;\n\n      case 'moduleNameMapper':\n        const moduleNameMapper = oldOptions[key];\n        value = moduleNameMapper && Object.keys(moduleNameMapper).map(regex => {\n          const item = moduleNameMapper && moduleNameMapper[regex];\n          return item && [regex, (0, _utils._replaceRootDirTags)(options.rootDir, item)];\n        });\n        break;\n\n      case 'transform':\n        const transform = oldOptions[key];\n        value = transform && Object.keys(transform).map(regex => {\n          const transformElement = transform[regex];\n          return [regex, (0, _utils.resolve)(newOptions.resolver, {\n            filePath: Array.isArray(transformElement) ? transformElement[0] : transformElement,\n            key,\n            rootDir: options.rootDir\n          }), ...(Array.isArray(transformElement) ? [transformElement[1]] : [])];\n        });\n        break;\n\n      case 'coveragePathIgnorePatterns':\n      case 'modulePathIgnorePatterns':\n      case 'testPathIgnorePatterns':\n      case 'transformIgnorePatterns':\n      case 'watchPathIgnorePatterns':\n      case 'unmockedModulePathPatterns':\n        value = normalizeUnmockedModulePathPatterns(oldOptions, key);\n        break;\n\n      case 'haste':\n        value = _objectSpread({}, oldOptions[key]);\n\n        if (value.hasteImplModulePath != null) {\n          const resolvedHasteImpl = (0, _utils.resolve)(newOptions.resolver, {\n            filePath: (0, _utils.replaceRootDirInPath)(options.rootDir, value.hasteImplModulePath),\n            key: 'haste.hasteImplModulePath',\n            rootDir: options.rootDir\n          });\n          value.hasteImplModulePath = resolvedHasteImpl || undefined;\n        }\n\n        break;\n\n      case 'projects':\n        value = (oldOptions[key] || []).map(project => typeof project === 'string' ? (0, _utils._replaceRootDirTags)(options.rootDir, project) : project).reduce((projects, project) => {\n          // Project can be specified as globs. If a glob matches any files,\n          // We expand it to these paths. If not, we keep the original path\n          // for the future resolution.\n          const globMatches = typeof project === 'string' ? _glob().default.sync(project) : [];\n          return projects.concat(globMatches.length ? globMatches : project);\n        }, []);\n        break;\n\n      case 'moduleDirectories':\n      case 'testMatch':\n        {\n          const replacedRootDirTags = (0, _utils._replaceRootDirTags)((0, _utils.escapeGlobCharacters)(options.rootDir), oldOptions[key]);\n\n          if (replacedRootDirTags) {\n            value = Array.isArray(replacedRootDirTags) ? replacedRootDirTags.map(_jestUtil().replacePathSepForGlob) : (0, _jestUtil().replacePathSepForGlob)(replacedRootDirTags);\n          } else {\n            value = replacedRootDirTags;\n          }\n        }\n        break;\n\n      case 'testRegex':\n        {\n          const option = oldOptions[key];\n          value = option ? (Array.isArray(option) ? option : [option]).map(_jestRegexUtil().replacePathSepForRegex) : [];\n        }\n        break;\n\n      case 'moduleFileExtensions':\n        {\n          value = oldOptions[key];\n\n          if (Array.isArray(value) && ( // If it's the wrong type, it can throw at a later time\n          options.runner === undefined || options.runner === _Defaults.default.runner) && // Only require 'js' for the default jest-runner\n          !value.includes('js')) {\n            const errorMessage = \"  moduleFileExtensions must include 'js':\\n\" + \"  but instead received:\\n\" + \"    \".concat(_chalk().default.bold.red(JSON.stringify(value))); // If `js` is not included, any dependency Jest itself injects into\n            // the environment, like jasmine or sourcemap-support, will need to\n            // `require` its modules with a file extension. This is not plausible\n            // in the long run, so it's way easier to just fail hard early.\n            // We might consider throwing if `json` is missing as well, as it's a\n            // fair assumption from modules that they can do\n            // `require('some-package/package') without the trailing `.json` as it\n            // works in Node normally.\n\n            throw createConfigError(errorMessage + \"\\n  Please change your configuration to include 'js'.\");\n          }\n\n          break;\n        }\n\n      case 'bail':\n        {\n          const bail = oldOptions[key];\n\n          if (typeof bail === 'boolean') {\n            value = bail ? 1 : 0;\n          } else if (typeof bail === 'string') {\n            value = 1; // If Jest is invoked as `jest --bail someTestPattern` then need to\n            // move the pattern from the `bail` configuration and into `argv._`\n            // to be processed as an extra parameter\n\n            argv._.push(bail);\n          } else {\n            value = oldOptions[key];\n          }\n\n          break;\n        }\n\n      case 'displayName':\n        {\n          const displayName = oldOptions[key];\n\n          if (typeof displayName === 'string') {\n            value = displayName;\n            break;\n          }\n          /**\n           * Ensuring that displayName shape is correct here so that the\n           * reporters can trust the shape of the data\n           * TODO: Normalize \"displayName\" such that given a config option\n           * {\n           *  \"displayName\": \"Test\"\n           * }\n           * becomes\n           * {\n           *   displayName: {\n           *     name: \"Test\",\n           *     color: \"white\"\n           *   }\n           * }\n           *\n           * This can't be done now since this will be a breaking change\n           * for custom reporters\n           */\n\n\n          if ((0, _jestGetType().default)(displayName) === 'object') {\n            const errorMessage = \"  Option \\\"\".concat(_chalk().default.bold('displayName'), \"\\\" must be of type:\\n\\n\") + '  {\\n' + '    name: string;\\n' + '    color: string;\\n' + '  }\\n';\n            const name = displayName.name,\n                  color = displayName.color;\n\n            if (!name || !color || typeof name !== 'string' || typeof color !== 'string') {\n              throw createConfigError(errorMessage);\n            }\n          }\n\n          value = oldOptions[key];\n          break;\n        }\n\n      case 'testTimeout':\n        {\n          if (oldOptions[key] < 0) {\n            throw createConfigError(\"  Option \\\"\".concat(_chalk().default.bold('testTimeout'), \"\\\" must be a natural number.\"));\n          }\n\n          value = oldOptions[key];\n          break;\n        }\n\n      case 'automock':\n      case 'browser':\n      case 'cache':\n      case 'changedSince':\n      case 'changedFilesWithAncestor':\n      case 'clearMocks':\n      case 'collectCoverage':\n      case 'coverageReporters':\n      case 'coverageThreshold':\n      case 'detectLeaks':\n      case 'detectOpenHandles':\n      case 'errorOnDeprecated':\n      case 'expand':\n      case 'extraGlobals':\n      case 'globals':\n      case 'findRelatedTests':\n      case 'forceCoverageMatch':\n      case 'forceExit':\n      case 'lastCommit':\n      case 'listTests':\n      case 'logHeapUsage':\n      case 'maxConcurrency':\n      case 'mapCoverage':\n      case 'name':\n      case 'noStackTrace':\n      case 'notify':\n      case 'notifyMode':\n      case 'onlyChanged':\n      case 'outputFile':\n      case 'passWithNoTests':\n      case 'replname':\n      case 'reporters':\n      case 'resetMocks':\n      case 'resetModules':\n      case 'restoreMocks':\n      case 'rootDir':\n      case 'runTestsByPath':\n      case 'silent':\n      case 'skipFilter':\n      case 'skipNodeResolution':\n      case 'testEnvironment':\n      case 'testEnvironmentOptions':\n      case 'testFailureExitCode':\n      case 'testLocationInResults':\n      case 'testNamePattern':\n      case 'testURL':\n      case 'timers':\n      case 'useStderr':\n      case 'verbose':\n      case 'watch':\n      case 'watchAll':\n      case 'watchman':\n        value = oldOptions[key];\n        break;\n\n      case 'watchPlugins':\n        value = (oldOptions[key] || []).map(watchPlugin => {\n          if (typeof watchPlugin === 'string') {\n            return {\n              config: {},\n              path: (0, _utils.getWatchPlugin)(newOptions.resolver, {\n                filePath: watchPlugin,\n                rootDir: options.rootDir\n              })\n            };\n          } else {\n            return {\n              config: watchPlugin[1] || {},\n              path: (0, _utils.getWatchPlugin)(newOptions.resolver, {\n                filePath: watchPlugin[0],\n                rootDir: options.rootDir\n              })\n            };\n          }\n        });\n        break;\n    } // @ts-ignore: automock is missing in GlobalConfig, so what\n\n\n    newOptions[key] = value;\n    return newOptions;\n  }, newOptions);\n\n  try {\n    // try to resolve windows short paths, ignoring errors (permission errors, mostly)\n    newOptions.cwd = (0, _realpathNative().sync)(process.cwd());\n  } catch (e) {// ignored\n  }\n\n  newOptions.testSequencer = (0, _utils.getSequencer)(newOptions.resolver, {\n    filePath: options.testSequencer || _Defaults.default.testSequencer,\n    rootDir: options.rootDir\n  });\n  newOptions.nonFlagArgs = argv._;\n  newOptions.testPathPattern = buildTestPathPattern(argv);\n  newOptions.json = !!argv.json;\n  newOptions.testFailureExitCode = parseInt(newOptions.testFailureExitCode, 10);\n\n  if (newOptions.lastCommit || newOptions.changedFilesWithAncestor || newOptions.changedSince) {\n    newOptions.onlyChanged = true;\n  }\n\n  if (argv.all) {\n    newOptions.onlyChanged = false;\n  } else if (newOptions.testPathPattern) {\n    // When passing a test path pattern we don't want to only monitor changed\n    // files unless `--watch` is also passed.\n    newOptions.onlyChanged = newOptions.watch;\n  }\n\n  newOptions.updateSnapshot = argv.ci && !argv.updateSnapshot ? 'none' : argv.updateSnapshot ? 'all' : 'new';\n  newOptions.maxConcurrency = parseInt(newOptions.maxConcurrency, 10);\n  newOptions.maxWorkers = (0, _getMaxWorkers.default)(argv, options);\n\n  if (newOptions.testRegex.length && options.testMatch) {\n    throw createConfigError(\"  Configuration options \".concat(_chalk().default.bold('testMatch'), \" and\") + \" \".concat(_chalk().default.bold('testRegex'), \" cannot be used together.\"));\n  }\n\n  if (newOptions.testRegex.length && !options.testMatch) {\n    // Prevent the default testMatch conflicting with any explicitly\n    // configured `testRegex` value\n    newOptions.testMatch = [];\n  } // If argv.json is set, coverageReporters shouldn't print a text report.\n\n\n  if (argv.json) {\n    newOptions.coverageReporters = (newOptions.coverageReporters || []).filter(reporter => reporter !== 'text');\n  } // If collectCoverage is enabled while using --findRelatedTests we need to\n  // avoid having false negatives in the generated coverage report.\n  // The following: `--findRelatedTests '/rootDir/file1.js' --coverage`\n  // Is transformed to: `--findRelatedTests '/rootDir/file1.js' --coverage --collectCoverageFrom 'file1.js'`\n  // where arguments to `--collectCoverageFrom` should be globs (or relative\n  // paths to the rootDir)\n\n\n  if (newOptions.collectCoverage && argv.findRelatedTests) {\n    let collectCoverageFrom = argv._.map(filename => {\n      filename = (0, _utils.replaceRootDirInPath)(options.rootDir, filename);\n      return _path().default.isAbsolute(filename) ? _path().default.relative(options.rootDir, filename) : filename;\n    }); // Don't override existing collectCoverageFrom options\n\n\n    if (newOptions.collectCoverageFrom) {\n      collectCoverageFrom = collectCoverageFrom.reduce((patterns, filename) => {\n        if (!_micromatch().default.some((0, _jestUtil().replacePathSepForGlob)(_path().default.relative(options.rootDir, filename)), newOptions.collectCoverageFrom)) {\n          return patterns;\n        }\n\n        return [...patterns, filename];\n      }, newOptions.collectCoverageFrom);\n    }\n\n    newOptions.collectCoverageFrom = collectCoverageFrom;\n  }\n\n  return {\n    hasDeprecationWarnings,\n    options: newOptions\n  };\n}","map":null,"metadata":{},"sourceType":"script"}