{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.readConfig = readConfig;\nexports.readConfigs = readConfigs;\nObject.defineProperty(exports, 'getTestEnvironment', {\n  enumerable: true,\n  get: function get() {\n    return _utils.getTestEnvironment;\n  }\n});\nObject.defineProperty(exports, 'isJSONString', {\n  enumerable: true,\n  get: function get() {\n    return _utils.isJSONString;\n  }\n});\nObject.defineProperty(exports, 'replaceRootDirInPath', {\n  enumerable: true,\n  get: function get() {\n    return _utils.replaceRootDirInPath;\n  }\n});\nObject.defineProperty(exports, 'normalize', {\n  enumerable: true,\n  get: function get() {\n    return _normalize2.default;\n  }\n});\nObject.defineProperty(exports, 'deprecationEntries', {\n  enumerable: true,\n  get: function get() {\n    return _Deprecated.default;\n  }\n});\nObject.defineProperty(exports, 'defaults', {\n  enumerable: true,\n  get: function get() {\n    return _Defaults.default;\n  }\n});\nObject.defineProperty(exports, 'descriptions', {\n  enumerable: true,\n  get: function get() {\n    return _Descriptions.default;\n  }\n});\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _utils = require('./utils');\n\nvar _normalize2 = _interopRequireDefault(require('./normalize'));\n\nvar _resolveConfigPath = _interopRequireDefault(require('./resolveConfigPath'));\n\nvar _readConfigFileAndSetRootDir = _interopRequireDefault(require('./readConfigFileAndSetRootDir'));\n\nvar _Deprecated = _interopRequireDefault(require('./Deprecated'));\n\nvar _Defaults = _interopRequireDefault(require('./Defaults'));\n\nvar _Descriptions = _interopRequireDefault(require('./Descriptions'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction readConfig(argv, packageRootOrConfig, // Whether it needs to look into `--config` arg passed to CLI.\n// It only used to read initial config. If the initial config contains\n// `project` property, we don't want to read `--config` value and rather\nskipArgvConfigOption, parentConfigPath, projectIndex = Infinity) {\n  let rawOptions;\n  let configPath = null;\n\n  if (typeof packageRootOrConfig !== 'string') {\n    if (parentConfigPath) {\n      const parentConfigDirname = _path().default.dirname(parentConfigPath);\n\n      rawOptions = packageRootOrConfig;\n      rawOptions.rootDir = rawOptions.rootDir ? (0, _utils.replaceRootDirInPath)(parentConfigDirname, rawOptions.rootDir) : parentConfigDirname;\n    } else {\n      throw new Error('Jest: Cannot use configuration as an object without a file path.');\n    }\n  } else if ((0, _utils.isJSONString)(argv.config)) {\n    // A JSON string was passed to `--config` argument and we can parse it\n    // and use as is.\n    let config;\n\n    try {\n      config = JSON.parse(argv.config);\n    } catch (e) {\n      throw new Error('There was an error while parsing the `--config` argument as a JSON string.');\n    } // NOTE: we might need to resolve this dir to an absolute path in the future\n\n\n    config.rootDir = config.rootDir || packageRootOrConfig;\n    rawOptions = config; // A string passed to `--config`, which is either a direct path to the config\n    // or a path to directory containing `package.json` or `jest.config.js`\n  } else if (!skipArgvConfigOption && typeof argv.config == 'string') {\n    configPath = (0, _resolveConfigPath.default)(argv.config, process.cwd());\n    rawOptions = (0, _readConfigFileAndSetRootDir.default)(configPath);\n  } else {\n    // Otherwise just try to find config in the current rootDir.\n    configPath = (0, _resolveConfigPath.default)(packageRootOrConfig, process.cwd());\n    rawOptions = (0, _readConfigFileAndSetRootDir.default)(configPath);\n  }\n\n  const _normalize = (0, _normalize2.default)(rawOptions, argv, configPath, projectIndex),\n        options = _normalize.options,\n        hasDeprecationWarnings = _normalize.hasDeprecationWarnings;\n\n  const _groupOptions = groupOptions(options),\n        globalConfig = _groupOptions.globalConfig,\n        projectConfig = _groupOptions.projectConfig;\n\n  return {\n    configPath,\n    globalConfig,\n    hasDeprecationWarnings,\n    projectConfig\n  };\n}\n\nconst groupOptions = options => ({\n  globalConfig: Object.freeze({\n    bail: options.bail,\n    changedFilesWithAncestor: options.changedFilesWithAncestor,\n    changedSince: options.changedSince,\n    collectCoverage: options.collectCoverage,\n    collectCoverageFrom: options.collectCoverageFrom,\n    collectCoverageOnlyFrom: options.collectCoverageOnlyFrom,\n    coverageDirectory: options.coverageDirectory,\n    coverageReporters: options.coverageReporters,\n    coverageThreshold: options.coverageThreshold,\n    detectLeaks: options.detectLeaks,\n    detectOpenHandles: options.detectOpenHandles,\n    enabledTestsMap: options.enabledTestsMap,\n    errorOnDeprecated: options.errorOnDeprecated,\n    expand: options.expand,\n    extraGlobals: options.extraGlobals,\n    filter: options.filter,\n    findRelatedTests: options.findRelatedTests,\n    forceExit: options.forceExit,\n    globalSetup: options.globalSetup,\n    globalTeardown: options.globalTeardown,\n    json: options.json,\n    lastCommit: options.lastCommit,\n    listTests: options.listTests,\n    logHeapUsage: options.logHeapUsage,\n    maxConcurrency: options.maxConcurrency,\n    maxWorkers: options.maxWorkers,\n    noSCM: undefined,\n    noStackTrace: options.noStackTrace,\n    nonFlagArgs: options.nonFlagArgs,\n    notify: options.notify,\n    notifyMode: options.notifyMode,\n    onlyChanged: options.onlyChanged,\n    onlyFailures: options.onlyFailures,\n    outputFile: options.outputFile,\n    passWithNoTests: options.passWithNoTests,\n    projects: options.projects,\n    replname: options.replname,\n    reporters: options.reporters,\n    rootDir: options.rootDir,\n    runTestsByPath: options.runTestsByPath,\n    silent: options.silent,\n    skipFilter: options.skipFilter,\n    testFailureExitCode: options.testFailureExitCode,\n    testNamePattern: options.testNamePattern,\n    testPathPattern: options.testPathPattern,\n    testResultsProcessor: options.testResultsProcessor,\n    testSequencer: options.testSequencer,\n    testTimeout: options.testTimeout,\n    updateSnapshot: options.updateSnapshot,\n    useStderr: options.useStderr,\n    verbose: options.verbose,\n    watch: options.watch,\n    watchAll: options.watchAll,\n    watchPlugins: options.watchPlugins,\n    watchman: options.watchman\n  }),\n  projectConfig: Object.freeze({\n    automock: options.automock,\n    browser: options.browser,\n    cache: options.cache,\n    cacheDirectory: options.cacheDirectory,\n    clearMocks: options.clearMocks,\n    coveragePathIgnorePatterns: options.coveragePathIgnorePatterns,\n    cwd: options.cwd,\n    dependencyExtractor: options.dependencyExtractor,\n    detectLeaks: options.detectLeaks,\n    detectOpenHandles: options.detectOpenHandles,\n    displayName: options.displayName,\n    errorOnDeprecated: options.errorOnDeprecated,\n    extraGlobals: options.extraGlobals,\n    filter: options.filter,\n    forceCoverageMatch: options.forceCoverageMatch,\n    globalSetup: options.globalSetup,\n    globalTeardown: options.globalTeardown,\n    globals: options.globals,\n    haste: options.haste,\n    moduleDirectories: options.moduleDirectories,\n    moduleFileExtensions: options.moduleFileExtensions,\n    moduleLoader: options.moduleLoader,\n    moduleNameMapper: options.moduleNameMapper,\n    modulePathIgnorePatterns: options.modulePathIgnorePatterns,\n    modulePaths: options.modulePaths,\n    name: options.name,\n    prettierPath: options.prettierPath,\n    resetMocks: options.resetMocks,\n    resetModules: options.resetModules,\n    resolver: options.resolver,\n    restoreMocks: options.restoreMocks,\n    rootDir: options.rootDir,\n    roots: options.roots,\n    runner: options.runner,\n    setupFiles: options.setupFiles,\n    setupFilesAfterEnv: options.setupFilesAfterEnv,\n    skipFilter: options.skipFilter,\n    skipNodeResolution: options.skipNodeResolution,\n    snapshotResolver: options.snapshotResolver,\n    snapshotSerializers: options.snapshotSerializers,\n    testEnvironment: options.testEnvironment,\n    testEnvironmentOptions: options.testEnvironmentOptions,\n    testLocationInResults: options.testLocationInResults,\n    testMatch: options.testMatch,\n    testPathIgnorePatterns: options.testPathIgnorePatterns,\n    testRegex: options.testRegex,\n    testRunner: options.testRunner,\n    testURL: options.testURL,\n    timers: options.timers,\n    transform: options.transform,\n    transformIgnorePatterns: options.transformIgnorePatterns,\n    unmockedModulePathPatterns: options.unmockedModulePathPatterns,\n    watchPathIgnorePatterns: options.watchPathIgnorePatterns\n  })\n});\n\nconst ensureNoDuplicateConfigs = (parsedConfigs, projects) => {\n  if (projects.length <= 1) {\n    return;\n  }\n\n  const configPathMap = new Map();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = parsedConfigs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      const config = _step.value;\n      const configPath = config.configPath;\n\n      if (configPathMap.has(configPath)) {\n        const message = \"Whoops! Two projects resolved to the same config path: \".concat(_chalk().default.bold(String(configPath)), \":\\n\\n  Project 1: \").concat(_chalk().default.bold(projects[parsedConfigs.findIndex(x => x === config)]), \"\\n  Project 2: \").concat(_chalk().default.bold(projects[parsedConfigs.findIndex(x => x === configPathMap.get(configPath))]), \"\\n\\nThis usually means that your \").concat(_chalk().default.bold('\"projects\"'), \" config includes a directory that doesn't have any configuration recognizable by Jest. Please fix it.\\n\");\n        throw new Error(message);\n      }\n\n      if (configPath !== null) {\n        configPathMap.set(configPath, config);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}; // Possible scenarios:\n//  1. jest --config config.json\n//  2. jest --projects p1 p2\n//  3. jest --projects p1 p2 --config config.json\n//  4. jest --projects p1\n//  5. jest\n//\n// If no projects are specified, process.cwd() will be used as the default\n// (and only) project.\n\n\nfunction readConfigs(argv, projectPaths) {\n  let globalConfig;\n  let hasDeprecationWarnings;\n  let configs = [];\n  let projects = projectPaths;\n  let configPath;\n\n  if (projectPaths.length === 1) {\n    const parsedConfig = readConfig(argv, projects[0]);\n    configPath = parsedConfig.configPath;\n\n    if (parsedConfig.globalConfig.projects) {\n      // If this was a single project, and its config has `projects`\n      // settings, use that value instead.\n      projects = parsedConfig.globalConfig.projects;\n    }\n\n    hasDeprecationWarnings = parsedConfig.hasDeprecationWarnings;\n    globalConfig = parsedConfig.globalConfig;\n    configs = [parsedConfig.projectConfig];\n\n    if (globalConfig.projects && globalConfig.projects.length) {\n      // Even though we had one project in CLI args, there might be more\n      // projects defined in the config.\n      projects = globalConfig.projects;\n    }\n  }\n\n  if (projects.length > 1 || projects.length && typeof projects[0] === 'object') {\n    const parsedConfigs = projects.filter(root => {\n      // Ignore globbed files that cannot be `require`d.\n      if (typeof root === 'string' && _fs().default.existsSync(root) && !_fs().default.lstatSync(root).isDirectory() && !root.endsWith('.js') && !root.endsWith('.json')) {\n        return false;\n      }\n\n      return true;\n    }).map((root, projectIndex) => readConfig(argv, root, true, configPath, projectIndex));\n    ensureNoDuplicateConfigs(parsedConfigs, projects);\n    configs = parsedConfigs.map(({\n      projectConfig\n    }) => projectConfig);\n\n    if (!hasDeprecationWarnings) {\n      hasDeprecationWarnings = parsedConfigs.some(({\n        hasDeprecationWarnings\n      }) => !!hasDeprecationWarnings);\n    } // If no config was passed initially, use the one from the first project\n\n\n    if (!globalConfig) {\n      globalConfig = parsedConfigs[0].globalConfig;\n    }\n  }\n\n  if (!globalConfig || !configs.length) {\n    throw new Error('jest: No configuration found for any project.');\n  }\n\n  return {\n    configs,\n    globalConfig,\n    hasDeprecationWarnings: !!hasDeprecationWarnings\n  };\n}","map":null,"metadata":{},"sourceType":"script"}