{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceCoverage = void 0;\n\nvar _istanbulLibCoverage = require(\"istanbul-lib-coverage\");\n\nfunction cloneLocation(loc) {\n  return {\n    start: {\n      line: loc && loc.start.line,\n      column: loc && loc.start.column\n    },\n    end: {\n      line: loc && loc.end.line,\n      column: loc && loc.end.column\n    }\n  };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\n\n\nclass SourceCoverage extends _istanbulLibCoverage.classes.FileCoverage {\n  constructor(pathOrObj) {\n    super(pathOrObj);\n    this.meta = {\n      last: {\n        s: 0,\n        f: 0,\n        b: 0\n      }\n    };\n  }\n\n  newStatement(loc) {\n    const s = this.meta.last.s;\n    this.data.statementMap[s] = cloneLocation(loc);\n    this.data.s[s] = 0;\n    this.meta.last.s += 1;\n    return s;\n  }\n\n  newFunction(name, decl, loc) {\n    const f = this.meta.last.f;\n    name = name || '(anonymous_' + f + ')';\n    this.data.fnMap[f] = {\n      name,\n      decl: cloneLocation(decl),\n      loc: cloneLocation(loc),\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.data.f[f] = 0;\n    this.meta.last.f += 1;\n    return f;\n  }\n\n  newBranch(type, loc) {\n    const b = this.meta.last.b;\n    this.data.b[b] = [];\n    this.data.branchMap[b] = {\n      loc: cloneLocation(loc),\n      type,\n      locations: [],\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.meta.last.b += 1;\n    return b;\n  }\n\n  addBranchPath(name, location) {\n    const bMeta = this.data.branchMap[name];\n    const counts = this.data.b[name];\n    /* istanbul ignore if: paranoid check */\n\n    if (!bMeta) {\n      throw new Error('Invalid branch ' + name);\n    }\n\n    bMeta.locations.push(cloneLocation(location));\n    counts.push(0);\n    return counts.length - 1;\n  }\n  /**\n   * Assigns an input source map to the coverage that can be used\n   * to remap the coverage output to the original source\n   * @param sourceMap {object} the source map\n   */\n\n\n  inputSourceMap(sourceMap) {\n    this.data.inputSourceMap = sourceMap;\n  }\n\n  freeze() {\n    // prune empty branches\n    const map = this.data.branchMap;\n    const branches = this.data.b;\n    Object.keys(map).forEach(b => {\n      if (map[b].locations.length === 0) {\n        delete map[b];\n        delete branches[b];\n      }\n    });\n  }\n\n}\n\nexports.SourceCoverage = SourceCoverage;","map":null,"metadata":{},"sourceType":"script"}