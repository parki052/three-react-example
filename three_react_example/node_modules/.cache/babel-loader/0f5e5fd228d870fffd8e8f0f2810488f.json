{"ast":null,"code":"'use strict';\n\nvar _path = _interopRequireDefault(require('path'));\n\nvar _jestUtil = require('jest-util');\n\nvar _each = _interopRequireDefault(require('./each'));\n\nvar _errorOnPrivate = require('./errorOnPrivate');\n\nvar _reporter = _interopRequireDefault(require('./reporter'));\n\nvar _jasmineAsyncInstall = _interopRequireDefault(require('./jasmineAsyncInstall'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst JASMINE = require.resolve('./jasmine/jasmineLight');\n\nfunction jasmine2(_x, _x2, _x3, _x4, _x5) {\n  return _jasmine.apply(this, arguments);\n}\n\nfunction _jasmine() {\n  _jasmine = _asyncToGenerator(function* (globalConfig, config, environment, runtime, testPath) {\n    const reporter = new _reporter.default(globalConfig, config, testPath);\n    const jasmineFactory = runtime.requireInternalModule(JASMINE);\n    const jasmine = jasmineFactory.create({\n      process,\n      testPath,\n      testTimeout: globalConfig.testTimeout\n    });\n    const env = jasmine.getEnv();\n    const jasmineInterface = jasmineFactory.interface(jasmine, env);\n    Object.assign(environment.global, jasmineInterface);\n    env.addReporter(jasmineInterface.jsApiReporter); // TODO: Remove config option if V8 exposes some way of getting location of caller\n    // in a future version\n\n    if (config.testLocationInResults === true) {\n      const originalIt = environment.global.it;\n\n      environment.global.it = (...args) => {\n        const stack = (0, _jestUtil.getCallsite)(1, runtime.getSourceMaps());\n        const it = originalIt(...args); // @ts-ignore\n\n        it.result.__callsite = stack;\n        return it;\n      };\n\n      const originalXit = environment.global.xit;\n\n      environment.global.xit = (...args) => {\n        const stack = (0, _jestUtil.getCallsite)(1, runtime.getSourceMaps());\n        const xit = originalXit(...args); // @ts-ignore\n\n        xit.result.__callsite = stack;\n        return xit;\n      };\n\n      const originalFit = environment.global.fit;\n\n      environment.global.fit = (...args) => {\n        const stack = (0, _jestUtil.getCallsite)(1, runtime.getSourceMaps());\n        const fit = originalFit(...args); // @ts-ignore\n\n        fit.result.__callsite = stack;\n        return fit;\n      };\n    }\n\n    (0, _jasmineAsyncInstall.default)(globalConfig, environment.global);\n    (0, _each.default)(environment);\n    environment.global.test = environment.global.it;\n    environment.global.it.only = environment.global.fit;\n    environment.global.it.todo = env.todo;\n    environment.global.it.skip = environment.global.xit;\n    environment.global.xtest = environment.global.xit;\n    environment.global.describe.skip = environment.global.xdescribe;\n    environment.global.describe.only = environment.global.fdescribe;\n\n    if (config.timers === 'fake') {\n      environment.fakeTimers.useFakeTimers();\n    }\n\n    env.beforeEach(() => {\n      if (config.resetModules) {\n        runtime.resetModules();\n      }\n\n      if (config.clearMocks) {\n        runtime.clearAllMocks();\n      }\n\n      if (config.resetMocks) {\n        runtime.resetAllMocks();\n\n        if (config.timers === 'fake') {\n          environment.fakeTimers.useFakeTimers();\n        }\n      }\n\n      if (config.restoreMocks) {\n        runtime.restoreAllMocks();\n      }\n    });\n    env.addReporter(reporter);\n    runtime.requireInternalModule(_path.default.resolve(__dirname, './jestExpect.js')).default({\n      expand: globalConfig.expand\n    });\n\n    if (globalConfig.errorOnDeprecated) {\n      (0, _errorOnPrivate.installErrorOnPrivate)(environment.global);\n    } else {\n      Object.defineProperty(jasmine, 'DEFAULT_TIMEOUT_INTERVAL', {\n        configurable: true,\n        enumerable: true,\n\n        get() {\n          return this._DEFAULT_TIMEOUT_INTERVAL;\n        },\n\n        set(value) {\n          this._DEFAULT_TIMEOUT_INTERVAL = value;\n        }\n\n      });\n    }\n\n    const snapshotState = runtime.requireInternalModule(_path.default.resolve(__dirname, './setup_jest_globals.js')).default({\n      config,\n      globalConfig,\n      localRequire: runtime.requireModule.bind(runtime),\n      testPath\n    });\n    config.setupFilesAfterEnv.forEach(path => runtime.requireModule(path));\n\n    if (globalConfig.enabledTestsMap) {\n      env.specFilter = spec => {\n        const suiteMap = globalConfig.enabledTestsMap && globalConfig.enabledTestsMap[spec.result.testPath];\n        return suiteMap && suiteMap[spec.result.fullName];\n      };\n    } else if (globalConfig.testNamePattern) {\n      const testNameRegex = new RegExp(globalConfig.testNamePattern, 'i');\n\n      env.specFilter = spec => testNameRegex.test(spec.getFullName());\n    }\n\n    runtime.requireModule(testPath);\n    yield env.execute();\n    const results = yield reporter.getResults();\n    return addSnapshotData(results, snapshotState);\n  });\n  return _jasmine.apply(this, arguments);\n}\n\nconst addSnapshotData = (results, snapshotState) => {\n  results.testResults.forEach(({\n    fullName,\n    status\n  }) => {\n    if (status === 'pending' || status === 'failed') {\n      // if test is skipped or failed, we don't want to mark\n      // its snapshots as obsolete.\n      snapshotState.markSnapshotsAsCheckedForTest(fullName);\n    }\n  });\n  const uncheckedCount = snapshotState.getUncheckedCount();\n  const uncheckedKeys = snapshotState.getUncheckedKeys();\n\n  if (uncheckedCount) {\n    snapshotState.removeUncheckedKeys();\n  }\n\n  const status = snapshotState.save();\n  results.snapshot.fileDeleted = status.deleted;\n  results.snapshot.added = snapshotState.added;\n  results.snapshot.matched = snapshotState.matched;\n  results.snapshot.unmatched = snapshotState.unmatched;\n  results.snapshot.updated = snapshotState.updated;\n  results.snapshot.unchecked = !status.deleted ? uncheckedCount : 0; // Copy the array to prevent memory leaks\n\n  results.snapshot.uncheckedKeys = Array.from(uncheckedKeys);\n  return results;\n}; // eslint-disable-next-line no-redeclare\n\n\nmodule.exports = jasmine2;","map":null,"metadata":{},"sourceType":"script"}