{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOpts = defaultOpts;\nexports.default = void 0;\n\nvar parser = _interopRequireWildcard(require(\"@babel/parser\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar _visitor = _interopRequireDefault(require(\"./visitor\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n\nfunction defaultOpts() {\n  return {\n    coverageVariable: '__coverage__',\n    coverageGlobalScope: 'this',\n    coverageGlobalScopeFunc: true,\n    preserveComments: false,\n    compact: true,\n    esModules: false,\n    autoWrap: false,\n    produceSourceMap: false,\n    ignoreClassMethods: [],\n    sourceMapUrlCallback: null,\n    debug: false,\n\n    /* babel parser plugins are to be enabled when the feature is stage 3 and\n     * implemented in a released version of node.js */\n    plugins: ['asyncGenerators', 'bigInt', 'classProperties', 'classPrivateProperties', 'dynamicImport', 'importMeta', 'objectRestSpread', 'optionalCatchBinding', 'flow', 'jsx']\n  };\n}\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on\n * @param {array} [opts.plugins=['asyncGenerators','dynamicImport','objectRestSpread','optionalCatchBinding','flow','jsx']] - set plugins\n */\n\n\nclass Instrumenter {\n  constructor(opts = defaultOpts()) {\n    this.opts = this.normalizeOpts(opts);\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * normalize options passed in and assign defaults.\n   * @param opts\n   * @private\n   */\n\n\n  normalizeOpts(opts) {\n    const normalize = (name, defaultValue) => {\n      if (!opts.hasOwnProperty(name)) {\n        opts[name] = defaultValue;\n      }\n    };\n\n    const defOpts = defaultOpts();\n    Object.keys(defOpts).forEach(k => {\n      normalize(k, defOpts[k]);\n    });\n    return opts;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n\n    filename = filename || String(new Date().getTime()) + '.js';\n    const opts = this.opts;\n    const ast = parser.parse(code, {\n      allowReturnOutsideFunction: opts.autoWrap,\n      sourceType: opts.esModules ? 'module' : 'script',\n      plugins: opts.plugins\n    });\n    const ee = (0, _visitor.default)(t, filename, {\n      coverageVariable: opts.coverageVariable,\n      coverageGlobalScope: opts.coverageGlobalScope,\n      coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n      ignoreClassMethods: opts.ignoreClassMethods,\n      inputSourceMap\n    });\n    let output = {};\n    const visitor = {\n      Program: {\n        enter: ee.enter,\n\n        exit(path) {\n          output = ee.exit(path);\n        }\n\n      }\n    };\n    (0, _traverse.default)(ast, visitor);\n    const generateOptions = {\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      sourceMaps: opts.produceSourceMap,\n      sourceFileName: filename\n    };\n    const codeMap = (0, _generator.default)(ast, generateOptions, code);\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n\n\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n\n\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n\n\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n\n}\n\nvar _default = Instrumenter;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}