{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _sourceCoverage = require(\"./source-coverage\");\n\nvar _constants = require(\"./constants\");\n\nvar _instrumenter = require(\"./instrumenter\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // pattern for istanbul to ignore a section\n\n\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/; // pattern for istanbul to ignore the whole file\n\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/; // source map URL pattern\n\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m; // generate a variable name from hashing the supplied file path\n\nfunction genVar(filename) {\n  const hash = (0, _crypto.createHash)(_constants.SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n} // VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\n\n\nclass VisitState {\n  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = []) {\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);\n\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n  } // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n\n\n  shouldIgnore(path) {\n    return this.nextIgnore || !path.node.loc;\n  } // extract the ignore comment hint (next|if|else) or null\n\n\n  hintFor(node) {\n    let hint = null;\n\n    if (node.leadingComments) {\n      node.leadingComments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(COMMENT_RE);\n\n        if (groups) {\n          hint = groups[1];\n        }\n      });\n    }\n\n    return hint;\n  } // extract a source map URL from comments and keep track of it\n\n\n  maybeAssignSourceMapURL(node) {\n    const extractURL = comments => {\n      if (!comments) {\n        return;\n      }\n\n      comments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(SOURCE_MAP_RE);\n\n        if (groups) {\n          this.sourceMappingURL = groups[1];\n        }\n      });\n    };\n\n    extractURL(node.leadingComments);\n    extractURL(node.trailingComments);\n  } // for these expressions the statement counter needs to be hoisted, so\n  // function name inference can be preserved\n\n\n  counterNeedsHoisting(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n  } // all the generic stuff that needs to be done on enter for every node\n\n\n  onEnter(path) {\n    const n = path.node;\n    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do\n\n    if (this.nextIgnore !== null) {\n      return;\n    } // check hint to see if ignore should be turned on\n\n\n    const hint = this.hintFor(n);\n\n    if (hint === 'next') {\n      this.nextIgnore = n;\n      return;\n    } // else check custom node attribute set by a prior visitor\n\n\n    if (this.getAttr(path.node, 'skip-all') !== null) {\n      this.nextIgnore = n;\n    } // else check for ignored class methods\n\n\n    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n\n    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n  } // all the generic stuff on exit of a node,\n  // including reseting ignores and custom node attrs\n\n\n  onExit(path) {\n    // restore ignore status, if needed\n    if (path.node === this.nextIgnore) {\n      this.nextIgnore = null;\n    } // nuke all attributes for the node\n\n\n    delete path.node.__cov__;\n  } // set a node attribute for the supplied node\n\n\n  setAttr(node, name, value) {\n    node.__cov__ = node.__cov__ || {};\n    node.__cov__[name] = value;\n  } // retrieve a node attribute for the supplied node or null\n\n\n  getAttr(node, name) {\n    const c = node.__cov__;\n\n    if (!c) {\n      return null;\n    }\n\n    return c[name];\n  } //\n\n\n  increase(type, id, index) {\n    const T = this.types;\n    const wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.\n    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;\n    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.identifier(this.varName), T.identifier(type)), T.numericLiteral(id), true)));\n  }\n\n  insertCounter(path, increment) {\n    const T = this.types;\n\n    if (path.isBlockStatement()) {\n      path.node.body.unshift(T.expressionStatement(increment));\n    } else if (path.isStatement()) {\n      path.insertBefore(T.expressionStatement(increment));\n    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n      // make an attempt to hoist the statement counter, so that\n      // function names are maintained.\n      const parent = path.parentPath.parentPath;\n\n      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n        parent.parentPath.insertBefore(T.expressionStatement(increment));\n      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n        parent.insertBefore(T.expressionStatement(increment));\n      } else {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      }\n    }\n    /* istanbul ignore else: not expected */\n    else if (path.isExpression()) {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      } else {\n        console.error('Unable to insert counter for node type:', path.node.type);\n      }\n  }\n\n  insertStatementCounter(path) {\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const index = this.cov.newStatement(path.node.loc);\n    const increment = this.increase('s', index, null);\n    this.insertCounter(path, increment);\n  }\n\n  insertFunctionCounter(path) {\n    const T = this.types;\n    /* istanbul ignore if: paranoid check */\n\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const n = path.node;\n    let dloc = null; // get location for declaration\n\n    switch (n.type) {\n      case 'FunctionDeclaration':\n        /* istanbul ignore else: paranoid check */\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n\n      case 'FunctionExpression':\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n    }\n\n    if (!dloc) {\n      dloc = {\n        start: n.loc.start,\n        end: {\n          line: n.loc.start.line,\n          column: n.loc.start.column + 1\n        }\n      };\n    }\n\n    const name = path.node.id ? path.node.id.name : path.node.name;\n    const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n    const increment = this.increase('f', index, null);\n    const body = path.get('body');\n    /* istanbul ignore else: not expected */\n\n    if (body.isBlockStatement()) {\n      body.node.body.unshift(T.expressionStatement(increment));\n    } else {\n      console.error('Unable to process function body node type:', path.node.type);\n    }\n  }\n\n  getBranchIncrement(branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return this.increase('b', branchName, index);\n  }\n\n  insertBranchCounter(path, branchName, loc) {\n    const increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n    this.insertCounter(path, increment);\n  }\n\n  findLeaves(node, accumulator, parent, property) {\n    if (!node) {\n      return;\n    }\n\n    if (node.type === 'LogicalExpression') {\n      const hint = this.hintFor(node);\n\n      if (hint !== 'next') {\n        this.findLeaves(node.left, accumulator, node, 'left');\n        this.findLeaves(node.right, accumulator, node, 'right');\n      }\n    } else {\n      accumulator.push({\n        node,\n        parent,\n        property\n      });\n    }\n  }\n\n} // generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\n\n\nfunction entries(...enter) {\n  // the enter function\n  const wrappedEntry = function wrappedEntry(path, node) {\n    this.onEnter(path);\n\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n\n    enter.forEach(e => {\n      e.call(this, path, node);\n    });\n  };\n\n  const exit = function exit(path, node) {\n    this.onExit(path, node);\n  };\n\n  return {\n    enter: wrappedEntry,\n    exit\n  };\n}\n\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n/* istanbul ignore next: no node.js support */\n\n\nfunction coverAssignmentPattern(path) {\n  const n = path.node;\n  const b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n  const T = this.types;\n\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n  }\n}\n\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  const T = this.types;\n\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\n\nfunction convertArrowExpression(path) {\n  const n = path.node;\n  const T = this.types;\n\n  if (!T.isBlockStatement(n.body)) {\n    const bloc = n.body.loc;\n\n    if (n.expression === true) {\n      n.expression = false;\n    }\n\n    n.body = T.blockStatement([T.returnStatement(n.body)]); // restore body location\n\n    n.body.loc = bloc; // set up the location for the return statement so it gets\n    // instrumented\n\n    n.body.body[0].loc = bloc;\n  }\n}\n\nfunction coverIfBranches(path) {\n  const n = path.node;\n  const hint = this.hintFor(n);\n  const ignoreIf = hint === 'if';\n  const ignoreElse = hint === 'else';\n  const branch = this.cov.newBranch('if', n.loc);\n\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch, n.loc);\n  }\n}\n\nfunction createSwitchBranch(path) {\n  const b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n  const T = this.types;\n  const b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n\n  const increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n  const n = path.node;\n  const branch = this.cov.newBranch('cond-expr', path.node.loc);\n  const cHint = this.hintFor(n.consequent);\n  const aHint = this.hintFor(n.alternate);\n\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction coverLogicalExpression(path) {\n  const T = this.types;\n\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  const leaves = [];\n  this.findLeaves(path.node, leaves);\n  const b = this.cov.newBranch('binary-expr', path.node.loc);\n\n  for (let i = 0; i < leaves.length; i += 1) {\n    const leaf = leaves[i];\n    const hint = this.hintFor(leaf.node);\n\n    if (hint === 'next') {\n      continue;\n    }\n\n    const increment = this.getBranchIncrement(b, leaf.node.loc);\n\n    if (!increment) {\n      continue;\n    }\n\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\n\nconst codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = (0, _template.default)(\"\\n        var Function = (function(){}).constructor;\\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\\n\");\nconst globalTemplateFunction = (0, _template.default)(\"\\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\\n\");\nconst globalTemplateVariable = (0, _template.default)(\"\\n        var global = GLOBAL_COVERAGE_SCOPE;\\n\"); // the template to insert at the top of the program.\n\nconst coverageTemplate = (0, _template.default)(\"\\n    var COVERAGE_VAR = (function () {\\n        var path = PATH;\\n        var hash = HASH;\\n        GLOBAL_COVERAGE_TEMPLATE\\n        var gcv = GLOBAL_COVERAGE_VAR;\\n        var coverageData = INITIAL;\\n        var coverage = global[gcv] || (global[gcv] = {});\\n        if (coverage[path] && coverage[path].hash === hash) {\\n            return coverage[path];\\n        }\\n        return coverage[path] = coverageData;\\n    })();\\n\"); // the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\n\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\n\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value));\n}\n\nconst defaultProgramVisitorOpts = {\n  inputSourceMap: undefined\n};\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types\n * @param {string} sourceFilePath - the path to source file\n * @param {Object} opts - additional options\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\n\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = defaultProgramVisitorOpts) {\n  const T = types; // This sets some unused options but ensures all required options are initialized\n\n  opts = Object.assign({}, (0, _instrumenter.defaultOpts)(), defaultProgramVisitorOpts, opts);\n  const visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods);\n  return {\n    enter(path) {\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return;\n      }\n\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      path.traverse(codeVisitor, visitState);\n    },\n\n    exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      visitState.cov.freeze();\n      const coverageData = visitState.cov.toJSON();\n\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n\n      coverageData[_constants.MAGIC_KEY] = _constants.MAGIC_VALUE;\n      const hash = (0, _crypto.createHash)(_constants.SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      const coverageNode = T.valueToNode(coverageData);\n      delete coverageData[_constants.MAGIC_KEY];\n      delete coverageData.hash;\n      let gvTemplate;\n\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n\n      const cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_VAR: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      });\n      cv._blockHoist = 5;\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n\n  };\n}\n\nvar _default = programVisitor;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}