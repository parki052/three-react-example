{"ast":null,"code":"'use strict'; // The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\n\nmodule.exports = function (tokens) {\n  var index = 0;\n\n  function hasMore() {\n    return index < tokens.length;\n  }\n\n  function token() {\n    return hasMore() ? tokens[index] : null;\n  }\n\n  function next() {\n    if (!hasMore()) {\n      throw new Error();\n    }\n\n    index++;\n  }\n\n  function parseOperator(operator) {\n    var t = token();\n\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next();\n      return t.string;\n    }\n  }\n\n  function parseWith() {\n    if (parseOperator('WITH')) {\n      var t = token();\n\n      if (t && t.type === 'EXCEPTION') {\n        next();\n        return t.string;\n      }\n\n      throw new Error('Expected exception after `WITH`');\n    }\n  }\n\n  function parseLicenseRef() {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index;\n    var string = '';\n    var t = token();\n\n    if (t.type === 'DOCUMENTREF') {\n      next();\n      string += 'DocumentRef-' + t.string + ':';\n\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`');\n      }\n    }\n\n    t = token();\n\n    if (t.type === 'LICENSEREF') {\n      next();\n      string += 'LicenseRef-' + t.string;\n      return {\n        license: string\n      };\n    }\n\n    index = begin;\n  }\n\n  function parseLicense() {\n    var t = token();\n\n    if (t && t.type === 'LICENSE') {\n      next();\n      var node = {\n        license: t.string\n      };\n\n      if (parseOperator('+')) {\n        node.plus = true;\n      }\n\n      var exception = parseWith();\n\n      if (exception) {\n        node.exception = exception;\n      }\n\n      return node;\n    }\n  }\n\n  function parseParenthesizedExpression() {\n    var left = parseOperator('(');\n\n    if (!left) {\n      return;\n    }\n\n    var expr = parseExpression();\n\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`');\n    }\n\n    return expr;\n  }\n\n  function parseAtom() {\n    return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();\n  }\n\n  function makeBinaryOpParser(operator, nextParser) {\n    return function parseBinaryOp() {\n      var left = nextParser();\n\n      if (!left) {\n        return;\n      }\n\n      if (!parseOperator(operator)) {\n        return left;\n      }\n\n      var right = parseBinaryOp();\n\n      if (!right) {\n        throw new Error('Expected expression');\n      }\n\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      };\n    };\n  }\n\n  var parseAnd = makeBinaryOpParser('AND', parseAtom);\n  var parseExpression = makeBinaryOpParser('OR', parseAnd);\n  var node = parseExpression();\n\n  if (!node || hasMore()) {\n    throw new Error('Syntax error');\n  }\n\n  return node;\n};","map":null,"metadata":{},"sourceType":"script"}