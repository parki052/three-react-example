{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = watch;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _ansiEscapes() {\n  const data = _interopRequireDefault(require('ansi-escapes'));\n\n  _ansiEscapes = function _ansiEscapes() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function _exit() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function _slash() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestValidate() {\n  const data = require('jest-validate');\n\n  _jestValidate = function _jestValidate() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function _jestResolve() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWatcher() {\n  const data = require('jest-watcher');\n\n  _jestWatcher = function _jestWatcher() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _getChangedFilesPromise = _interopRequireDefault(require('./getChangedFilesPromise'));\n\nvar _is_valid_path = _interopRequireDefault(require('./lib/is_valid_path'));\n\nvar _create_context = _interopRequireDefault(require('./lib/create_context'));\n\nvar _runJest = _interopRequireDefault(require('./runJest'));\n\nvar _update_global_config = _interopRequireDefault(require('./lib/update_global_config'));\n\nvar _SearchSource = _interopRequireDefault(require('./SearchSource'));\n\nvar _TestWatcher = _interopRequireDefault(require('./TestWatcher'));\n\nvar _FailedTestsCache = _interopRequireDefault(require('./FailedTestsCache'));\n\nvar _test_path_pattern = _interopRequireDefault(require('./plugins/test_path_pattern'));\n\nvar _test_name_pattern = _interopRequireDefault(require('./plugins/test_name_pattern'));\n\nvar _update_snapshots = _interopRequireDefault(require('./plugins/update_snapshots'));\n\nvar _update_snapshots_interactive = _interopRequireDefault(require('./plugins/update_snapshots_interactive'));\n\nvar _quit = _interopRequireDefault(require('./plugins/quit'));\n\nvar _watch_plugins_helpers = require('./lib/watch_plugins_helpers');\n\nvar _active_filters_message = _interopRequireDefault(require('./lib/active_filters_message'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst preRunMessagePrint = _jestUtil().preRunMessage.print;\n\nlet hasExitListener = false;\nconst INTERNAL_PLUGINS = [_test_path_pattern.default, _test_name_pattern.default, _update_snapshots.default, _update_snapshots_interactive.default, _quit.default];\nconst RESERVED_KEY_PLUGINS = new Map([[_update_snapshots.default, {\n  forbiddenOverwriteMessage: 'updating snapshots',\n  key: 'u'\n}], [_update_snapshots_interactive.default, {\n  forbiddenOverwriteMessage: 'updating snapshots interactively',\n  key: 'i'\n}], [_quit.default, {\n  forbiddenOverwriteMessage: 'quitting watch mode'\n}]]);\n\nfunction watch(initialGlobalConfig, contexts, outputStream, hasteMapInstances, stdin = process.stdin, hooks = new (_jestWatcher().JestHook)(), filter) {\n  // `globalConfig` will be constantly updated and reassigned as a result of\n  // watch mode interactions.\n  let globalConfig = initialGlobalConfig;\n  let activePlugin;\n  globalConfig = (0, _update_global_config.default)(globalConfig, {\n    mode: globalConfig.watch ? 'watch' : 'watchAll',\n    passWithNoTests: true\n  });\n\n  const updateConfigAndRun = ({\n    bail,\n    changedSince,\n    collectCoverage,\n    collectCoverageFrom,\n    collectCoverageOnlyFrom,\n    coverageDirectory,\n    coverageReporters,\n    mode,\n    notify,\n    notifyMode,\n    onlyFailures,\n    reporters,\n    testNamePattern,\n    testPathPattern,\n    updateSnapshot,\n    verbose\n  } = {}) => {\n    const previousUpdateSnapshot = globalConfig.updateSnapshot;\n    globalConfig = (0, _update_global_config.default)(globalConfig, {\n      bail,\n      changedSince,\n      collectCoverage,\n      collectCoverageFrom,\n      collectCoverageOnlyFrom,\n      coverageDirectory,\n      coverageReporters,\n      mode,\n      notify,\n      notifyMode,\n      onlyFailures,\n      reporters,\n      testNamePattern,\n      testPathPattern,\n      updateSnapshot,\n      verbose\n    });\n    startRun(globalConfig);\n    globalConfig = (0, _update_global_config.default)(globalConfig, {\n      // updateSnapshot is not sticky after a run.\n      updateSnapshot: previousUpdateSnapshot === 'all' ? 'none' : previousUpdateSnapshot\n    });\n  };\n\n  const watchPlugins = INTERNAL_PLUGINS.map(InternalPlugin => new InternalPlugin({\n    stdin,\n    stdout: outputStream\n  }));\n  watchPlugins.forEach(plugin => {\n    const hookSubscriber = hooks.getSubscriber();\n\n    if (plugin.apply) {\n      plugin.apply(hookSubscriber);\n    }\n  });\n\n  if (globalConfig.watchPlugins != null) {\n    const watchPluginKeys = new Map();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = watchPlugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const plugin = _step.value;\n        const reservedInfo = RESERVED_KEY_PLUGINS.get(plugin.constructor) || {};\n        const key = reservedInfo.key || getPluginKey(plugin, globalConfig);\n\n        if (!key) {\n          continue;\n        }\n\n        const forbiddenOverwriteMessage = reservedInfo.forbiddenOverwriteMessage;\n        watchPluginKeys.set(key, {\n          forbiddenOverwriteMessage,\n          overwritable: forbiddenOverwriteMessage == null,\n          plugin\n        });\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = globalConfig.watchPlugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        const pluginWithConfig = _step2.value;\n        let plugin;\n\n        try {\n          const ThirdPartyPlugin = require(pluginWithConfig.path);\n\n          plugin = new ThirdPartyPlugin({\n            config: pluginWithConfig.config,\n            stdin,\n            stdout: outputStream\n          });\n        } catch (error) {\n          const errorWithContext = new Error(\"Failed to initialize watch plugin \\\"\".concat(_chalk().default.bold((0, _slash().default)(_path().default.relative(process.cwd(), pluginWithConfig.path))), \"\\\":\\n\\n\").concat((0, _jestMessageUtil().formatExecError)(error, contexts[0].config, {\n            noStackTrace: false\n          })));\n          delete errorWithContext.stack;\n          return Promise.reject(errorWithContext);\n        }\n\n        checkForConflicts(watchPluginKeys, plugin, globalConfig);\n        const hookSubscriber = hooks.getSubscriber();\n\n        if (plugin.apply) {\n          plugin.apply(hookSubscriber);\n        }\n\n        watchPlugins.push(plugin);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  const failedTestsCache = new _FailedTestsCache.default();\n  let searchSources = contexts.map(context => ({\n    context,\n    searchSource: new _SearchSource.default(context)\n  }));\n  let isRunning = false;\n  let testWatcher;\n  let shouldDisplayWatchUsage = true;\n  let isWatchUsageDisplayed = false;\n\n  const emitFileChange = () => {\n    if (hooks.isUsed('onFileChange')) {\n      const projects = searchSources.map(({\n        context,\n        searchSource\n      }) => ({\n        config: context.config,\n        testPaths: searchSource.findMatchingTests('').tests.map(t => t.path)\n      }));\n      hooks.getEmitter().onFileChange({\n        projects\n      });\n    }\n  };\n\n  emitFileChange();\n  hasteMapInstances.forEach((hasteMapInstance, index) => {\n    hasteMapInstance.on('change', ({\n      eventsQueue,\n      hasteFS,\n      moduleMap\n    }) => {\n      const validPaths = eventsQueue.filter(({\n        filePath\n      }) => (0, _is_valid_path.default)(globalConfig, filePath));\n\n      if (validPaths.length) {\n        const context = contexts[index] = (0, _create_context.default)(contexts[index].config, {\n          hasteFS,\n          moduleMap\n        });\n        activePlugin = null;\n        searchSources = searchSources.slice();\n        searchSources[index] = {\n          context,\n          searchSource: new _SearchSource.default(context)\n        };\n        emitFileChange();\n        startRun(globalConfig);\n      }\n    });\n  });\n\n  if (!hasExitListener) {\n    hasExitListener = true;\n    process.on('exit', () => {\n      if (activePlugin) {\n        outputStream.write(_ansiEscapes().default.cursorDown());\n        outputStream.write(_ansiEscapes().default.eraseDown);\n      }\n    });\n  }\n\n  const startRun = globalConfig => {\n    if (isRunning) {\n      return Promise.resolve(null);\n    }\n\n    testWatcher = new _TestWatcher.default({\n      isWatchMode: true\n    });\n    _jestUtil().isInteractive && outputStream.write(_jestUtil().specialChars.CLEAR);\n    preRunMessagePrint(outputStream);\n    isRunning = true;\n    const configs = contexts.map(context => context.config);\n    const changedFilesPromise = (0, _getChangedFilesPromise.default)(globalConfig, configs); // Clear cache for required modules\n\n    _jestResolve().default.clearDefaultResolverCache();\n\n    return (0, _runJest.default)({\n      changedFilesPromise,\n      contexts,\n      failedTestsCache,\n      filter,\n      globalConfig,\n      jestHooks: hooks.getEmitter(),\n      onComplete: results => {\n        isRunning = false;\n        hooks.getEmitter().onTestRunComplete(results); // Create a new testWatcher instance so that re-runs won't be blocked.\n        // The old instance that was passed to Jest will still be interrupted\n        // and prevent test runs from the previous run.\n\n        testWatcher = new _TestWatcher.default({\n          isWatchMode: true\n        }); // Do not show any Watch Usage related stuff when running in a\n        // non-interactive environment\n\n        if (_jestUtil().isInteractive) {\n          if (shouldDisplayWatchUsage) {\n            outputStream.write(usage(globalConfig, watchPlugins));\n            shouldDisplayWatchUsage = false; // hide Watch Usage after first run\n\n            isWatchUsageDisplayed = true;\n          } else {\n            outputStream.write(showToggleUsagePrompt());\n            shouldDisplayWatchUsage = false;\n            isWatchUsageDisplayed = false;\n          }\n        } else {\n          outputStream.write('\\n');\n        }\n\n        failedTestsCache.setTestResults(results.testResults);\n      },\n      outputStream,\n      startRun,\n      testWatcher\n    }).catch((error // Errors thrown inside `runJest`, e.g. by resolvers, are caught here for\n    ) => // continuous watch mode execution. We need to reprint them to the\n    // terminal and give just a little bit of extra space so they fit below\n    // `preRunMessagePrint` message nicely.\n    console.error('\\n\\n' + (0, _jestMessageUtil().formatExecError)(error, contexts[0].config, {\n      noStackTrace: false\n    })));\n  };\n\n  const onKeypress = key => {\n    if (key === _jestWatcher().KEYS.CONTROL_C || key === _jestWatcher().KEYS.CONTROL_D) {\n      if (typeof stdin.setRawMode === 'function') {\n        stdin.setRawMode(false);\n      }\n\n      outputStream.write('\\n');\n      (0, _exit().default)(0);\n      return;\n    }\n\n    if (activePlugin != null && activePlugin.onKey) {\n      // if a plugin is activate, Jest should let it handle keystrokes, so ignore\n      // them here\n      activePlugin.onKey(key);\n      return;\n    } // Abort test run\n\n\n    const pluginKeys = (0, _watch_plugins_helpers.getSortedUsageRows)(watchPlugins, globalConfig).map(usage => Number(usage.key).toString(16));\n\n    if (isRunning && testWatcher && ['q', _jestWatcher().KEYS.ENTER, 'a', 'o', 'f'].concat(pluginKeys).includes(key)) {\n      testWatcher.setState({\n        interrupted: true\n      });\n      return;\n    }\n\n    const matchingWatchPlugin = (0, _watch_plugins_helpers.filterInteractivePlugins)(watchPlugins, globalConfig).find(plugin => getPluginKey(plugin, globalConfig) === key);\n\n    if (matchingWatchPlugin != null) {\n      if (isRunning) {\n        testWatcher.setState({\n          interrupted: true\n        });\n        return;\n      } // \"activate\" the plugin, which has jest ignore keystrokes so the plugin\n      // can handle them\n\n\n      activePlugin = matchingWatchPlugin;\n\n      if (activePlugin.run) {\n        activePlugin.run(globalConfig, updateConfigAndRun).then(shouldRerun => {\n          activePlugin = null;\n\n          if (shouldRerun) {\n            updateConfigAndRun();\n          }\n        }, () => {\n          activePlugin = null;\n          onCancelPatternPrompt();\n        });\n      } else {\n        activePlugin = null;\n      }\n    }\n\n    switch (key) {\n      case _jestWatcher().KEYS.ENTER:\n        startRun(globalConfig);\n        break;\n\n      case 'a':\n        globalConfig = (0, _update_global_config.default)(globalConfig, {\n          mode: 'watchAll',\n          testNamePattern: '',\n          testPathPattern: ''\n        });\n        startRun(globalConfig);\n        break;\n\n      case 'c':\n        updateConfigAndRun({\n          mode: 'watch',\n          testNamePattern: '',\n          testPathPattern: ''\n        });\n        break;\n\n      case 'f':\n        globalConfig = (0, _update_global_config.default)(globalConfig, {\n          onlyFailures: !globalConfig.onlyFailures\n        });\n        startRun(globalConfig);\n        break;\n\n      case 'o':\n        globalConfig = (0, _update_global_config.default)(globalConfig, {\n          mode: 'watch',\n          testNamePattern: '',\n          testPathPattern: ''\n        });\n        startRun(globalConfig);\n        break;\n\n      case '?':\n        break;\n\n      case 'w':\n        if (!shouldDisplayWatchUsage && !isWatchUsageDisplayed) {\n          outputStream.write(_ansiEscapes().default.cursorUp());\n          outputStream.write(_ansiEscapes().default.eraseDown);\n          outputStream.write(usage(globalConfig, watchPlugins));\n          isWatchUsageDisplayed = true;\n          shouldDisplayWatchUsage = false;\n        }\n\n        break;\n    }\n  };\n\n  const onCancelPatternPrompt = () => {\n    outputStream.write(_ansiEscapes().default.cursorHide);\n    outputStream.write(_jestUtil().specialChars.CLEAR);\n    outputStream.write(usage(globalConfig, watchPlugins));\n    outputStream.write(_ansiEscapes().default.cursorShow);\n  };\n\n  if (typeof stdin.setRawMode === 'function') {\n    stdin.setRawMode(true);\n    stdin.resume();\n    stdin.setEncoding('utf8');\n    stdin.on('data', onKeypress);\n  }\n\n  startRun(globalConfig);\n  return Promise.resolve();\n}\n\nconst checkForConflicts = (watchPluginKeys, plugin, globalConfig) => {\n  const key = getPluginKey(plugin, globalConfig);\n\n  if (!key) {\n    return;\n  }\n\n  const conflictor = watchPluginKeys.get(key);\n\n  if (!conflictor || conflictor.overwritable) {\n    watchPluginKeys.set(key, {\n      overwritable: false,\n      plugin\n    });\n    return;\n  }\n\n  let error;\n\n  if (conflictor.forbiddenOverwriteMessage) {\n    error = \"\\n  Watch plugin \".concat(_chalk().default.bold.red(getPluginIdentifier(plugin)), \" attempted to register key \").concat(_chalk().default.bold.red(\"<\".concat(key, \">\")), \",\\n  that is reserved internally for \").concat(_chalk().default.bold.red(conflictor.forbiddenOverwriteMessage), \".\\n  Please change the configuration key for this plugin.\").trim();\n  } else {\n    const plugins = [conflictor.plugin, plugin].map(p => _chalk().default.bold.red(getPluginIdentifier(p))).join(' and ');\n    error = \"\\n  Watch plugins \".concat(plugins, \" both attempted to register key \").concat(_chalk().default.bold.red(\"<\".concat(key, \">\")), \".\\n  Please change the key configuration for one of the conflicting plugins to avoid overlap.\").trim();\n  }\n\n  throw new (_jestValidate().ValidationError)('Watch plugin configuration error', error);\n};\n\nconst getPluginIdentifier = (plugin // This breaks as `displayName` is not defined as a static, but since\n// WatchPlugin is an interface, and it is my understanding interface\n// static fields are not definable anymore, no idea how to circumvent\n// this :-(\n// @ts-ignore: leave `displayName` be.\n) => plugin.constructor.displayName || plugin.constructor.name;\n\nconst getPluginKey = (plugin, globalConfig) => {\n  if (typeof plugin.getUsageInfo === 'function') {\n    return (plugin.getUsageInfo(globalConfig) || {\n      key: null\n    }).key;\n  }\n\n  return null;\n};\n\nconst usage = (globalConfig, watchPlugins, delimiter = '\\n') => {\n  const messages = [(0, _active_filters_message.default)(globalConfig), globalConfig.testPathPattern || globalConfig.testNamePattern ? _chalk().default.dim(' \\u203A Press ') + 'c' + _chalk().default.dim(' to clear filters.') : null, '\\n' + _chalk().default.bold('Watch Usage'), globalConfig.watch ? _chalk().default.dim(' \\u203A Press ') + 'a' + _chalk().default.dim(' to run all tests.') : null, globalConfig.onlyFailures ? _chalk().default.dim(' \\u203A Press ') + 'f' + _chalk().default.dim(' to quit \"only failed tests\" mode.') : _chalk().default.dim(' \\u203A Press ') + 'f' + _chalk().default.dim(' to run only failed tests.'), (globalConfig.watchAll || globalConfig.testPathPattern || globalConfig.testNamePattern) && !globalConfig.noSCM ? _chalk().default.dim(' \\u203A Press ') + 'o' + _chalk().default.dim(' to only run tests related to changed files.') : null, ...(0, _watch_plugins_helpers.getSortedUsageRows)(watchPlugins, globalConfig).map(plugin => _chalk().default.dim(' \\u203A Press') + ' ' + plugin.key + ' ' + _chalk().default.dim(\"to \".concat(plugin.prompt, \".\"))), _chalk().default.dim(' \\u203A Press ') + 'Enter' + _chalk().default.dim(' to trigger a test run.')];\n  return messages.filter(message => !!message).join(delimiter) + '\\n';\n};\n\nconst showToggleUsagePrompt = () => '\\n' + _chalk().default.bold('Watch Usage: ') + _chalk().default.dim('Press ') + 'w' + _chalk().default.dim(' to show more.');","map":null,"metadata":{},"sourceType":"script"}