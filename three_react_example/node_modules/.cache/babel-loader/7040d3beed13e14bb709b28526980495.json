{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _constants = require('./constants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst isFile = filePath => _fs().default.existsSync(filePath) && !_fs().default.lstatSync(filePath).isDirectory();\n\nvar _default = (pathToResolve, cwd) => {\n  if (!_path().default.isAbsolute(cwd)) {\n    throw new Error(\"\\\"cwd\\\" must be an absolute path. cwd: \".concat(cwd));\n  }\n\n  const absolutePath = _path().default.isAbsolute(pathToResolve) ? pathToResolve : _path().default.resolve(cwd, pathToResolve);\n\n  if (isFile(absolutePath)) {\n    return absolutePath;\n  } // This is a guard against passing non existing path as a project/config,\n  // that will otherwise result in a very confusing situation.\n  // e.g.\n  // With a directory structure like this:\n  //   my_project/\n  //     packcage.json\n  //\n  // Passing a `my_project/some_directory_that_doesnt_exist` as a project\n  // name will resolve into a (possibly empty) `my_project/package.json` and\n  // try to run all tests it finds under `my_project` directory.\n\n\n  if (!_fs().default.existsSync(absolutePath)) {\n    throw new Error(\"Can't find a root directory while resolving a config file path.\\n\" + \"Provided path to resolve: \".concat(pathToResolve, \"\\n\") + \"cwd: \".concat(cwd));\n  }\n\n  return resolveConfigPathByTraversing(absolutePath, pathToResolve, cwd);\n};\n\nexports.default = _default;\n\nconst resolveConfigPathByTraversing = (pathToResolve, initialPath, cwd) => {\n  const jestConfig = _path().default.resolve(pathToResolve, _constants.JEST_CONFIG);\n\n  if (isFile(jestConfig)) {\n    return jestConfig;\n  }\n\n  const packageJson = _path().default.resolve(pathToResolve, _constants.PACKAGE_JSON);\n\n  if (isFile(packageJson)) {\n    return packageJson;\n  } // This is the system root.\n  // We tried everything, config is nowhere to be found ¯\\_(ツ)_/¯\n\n\n  if (pathToResolve === _path().default.dirname(pathToResolve)) {\n    throw new Error(makeResolutionErrorMessage(initialPath, cwd));\n  } // go up a level and try it again\n\n\n  return resolveConfigPathByTraversing(_path().default.dirname(pathToResolve), initialPath, cwd);\n};\n\nconst makeResolutionErrorMessage = (initialPath, cwd) => 'Could not find a config file based on provided values:\\n' + \"path: \\\"\".concat(initialPath, \"\\\"\\n\") + \"cwd: \\\"\".concat(cwd, \"\\\"\\n\") + 'Config paths must be specified by either a direct path to a config\\n' + 'file, or a path to a directory. If directory is given, Jest will try to\\n' + \"traverse directory tree up, until it finds either \\\"\".concat(_constants.JEST_CONFIG, \"\\\" or\\n\") + \"\\\"\".concat(_constants.PACKAGE_JSON, \"\\\".\");","map":null,"metadata":{},"sourceType":"script"}