{"ast":null,"code":"'use strict';\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function _jestHasteMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function _jestResolve() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function _transform() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stripBom() {\n  const data = _interopRequireDefault(require('strip-bom'));\n\n  _stripBom = function _stripBom() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _cli = require('./cli');\n\nvar _args = require('./cli/args');\n\nvar _helpers = require('./helpers');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\n\nconst NODE_MODULES = _path().default.sep + 'node_modules' + _path().default.sep;\n\nconst getModuleNameMapper = config => {\n  if (Array.isArray(config.moduleNameMapper) && config.moduleNameMapper.length) {\n    return config.moduleNameMapper.map(([regex, moduleName]) => ({\n      moduleName,\n      regex: new RegExp(regex)\n    }));\n  }\n\n  return null;\n};\n\nconst unmockRegExpCache = new WeakMap();\n/* eslint-disable-next-line no-redeclare */\n\nclass Runtime {\n  constructor(config, environment, resolver, cacheFS, coverageOptions) {\n    _defineProperty(this, '_cacheFS', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_coverageOptions', void 0);\n\n    _defineProperty(this, '_currentlyExecutingModulePath', void 0);\n\n    _defineProperty(this, '_environment', void 0);\n\n    _defineProperty(this, '_explicitShouldMock', void 0);\n\n    _defineProperty(this, '_internalModuleRegistry', void 0);\n\n    _defineProperty(this, '_isCurrentlyExecutingManualMock', void 0);\n\n    _defineProperty(this, '_mockFactories', void 0);\n\n    _defineProperty(this, '_mockMetaDataCache', void 0);\n\n    _defineProperty(this, '_mockRegistry', void 0);\n\n    _defineProperty(this, '_isolatedMockRegistry', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_isolatedModuleRegistry', void 0);\n\n    _defineProperty(this, '_moduleRegistry', void 0);\n\n    _defineProperty(this, '_needsCoverageMapped', void 0);\n\n    _defineProperty(this, '_resolver', void 0);\n\n    _defineProperty(this, '_shouldAutoMock', void 0);\n\n    _defineProperty(this, '_shouldMockModuleCache', void 0);\n\n    _defineProperty(this, '_shouldUnmockTransitiveDependenciesCache', void 0);\n\n    _defineProperty(this, '_sourceMapRegistry', void 0);\n\n    _defineProperty(this, '_scriptTransformer', void 0);\n\n    _defineProperty(this, '_transitiveShouldMock', void 0);\n\n    _defineProperty(this, '_unmockList', void 0);\n\n    _defineProperty(this, '_virtualMocks', void 0);\n\n    this._cacheFS = cacheFS || Object.create(null);\n    this._config = config;\n    this._coverageOptions = coverageOptions || {\n      changedFiles: undefined,\n      collectCoverage: false,\n      collectCoverageFrom: [],\n      collectCoverageOnlyFrom: null\n    };\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._explicitShouldMock = Object.create(null);\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mockFactories = Object.create(null);\n    this._mockRegistry = new Map(); // during setup, this cannot be null (and it's fine to explode if it is)\n\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._needsCoverageMapped = new Set();\n    this._resolver = resolver;\n    this._scriptTransformer = new (_transform().ScriptTransformer)(config);\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = Object.create(null);\n    this._virtualMocks = Object.create(null);\n    this._mockMetaDataCache = Object.create(null);\n    this._shouldMockModuleCache = Object.create(null);\n    this._shouldUnmockTransitiveDependenciesCache = Object.create(null);\n    this._transitiveShouldMock = Object.create(null);\n    this._unmockList = unmockRegExpCache.get(config);\n\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(config.unmockedModulePathPatterns.join('|'));\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    if (config.automock) {\n      config.setupFiles.forEach(filePath => {\n        if (filePath && filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(this._virtualMocks, filePath);\n\n          this._transitiveShouldMock[moduleID] = false;\n        }\n      });\n    }\n\n    this.resetModules();\n\n    if (config.setupFiles.length) {\n      for (let i = 0; i < config.setupFiles.length; i++) {\n        this.requireModule(config.setupFiles[i]);\n      }\n    }\n  } // TODO: Make this `static shouldInstrument = shouldInstrument;` after https://github.com/facebook/jest/issues/7846\n\n\n  static shouldInstrument(filename, options, config) {\n    return (0, _transform().shouldInstrument)(filename, options, config);\n  }\n\n  static createContext(config, options) {\n    (0, _jestUtil().createDirectory)(config.cacheDirectory);\n    const instance = Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman\n    });\n    return instance.build().then(hasteMap => ({\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap)\n    }), error => {\n      throw error;\n    });\n  }\n\n  static createHasteMap(config, options) {\n    const ignorePatternParts = [...config.modulePathIgnorePatterns, ...(options && options.watch ? config.watchPathIgnorePatterns : []), config.cacheDirectory.startsWith(config.rootDir + _path().default.sep) && config.cacheDirectory].filter(Boolean);\n    const ignorePattern = ignorePatternParts.length > 0 ? new RegExp(ignorePatternParts.join('|')) : undefined;\n    return new (_jestHasteMap().default)({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console: options && options.console,\n      dependencyExtractor: config.dependencyExtractor,\n      extensions: [_jestSnapshot().default.EXTENSION].concat(config.moduleFileExtensions),\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      ignorePattern,\n      maxWorkers: options && options.maxWorkers || 1,\n      mocksPattern: (0, _jestRegexUtil().escapePathForRegex)(_path().default.sep + '__mocks__' + _path().default.sep),\n      name: config.name,\n      platforms: config.haste.platforms || ['ios', 'android'],\n      providesModuleNodeModules: config.haste.providesModuleNodeModules,\n      resetCache: options && options.resetCache,\n      retainAllFiles: false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman: options && options.watchman,\n      watch: options && options.watch\n    });\n  }\n\n  static createResolver(config, moduleMap) {\n    return new (_jestResolve().default)(moduleMap, {\n      browser: config.browser,\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => '.' + extension),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir\n    });\n  }\n\n  static runCLI(args, info) {\n    return (0, _cli.run)(args, info);\n  }\n\n  static getCLIOptions() {\n    return _args.options;\n  }\n\n  requireModule(from, moduleName, options, isRequireActual) {\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n    let modulePath; // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n\n    const manualMock = moduleName && this._resolver.getMockModule(from, moduleName);\n\n    if ((!options || !options.isInternalModule) && !isRequireActual && !moduleResource && manualMock && manualMock !== this._isCurrentlyExecutingManualMock && this._explicitShouldMock[moduleID] !== false) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(moduleName);\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveModule(from, moduleName);\n    }\n\n    let moduleRegistry;\n\n    if (!options || !options.isInternalModule) {\n      if (this._moduleRegistry.get(modulePath) || !this._isolatedModuleRegistry) {\n        moduleRegistry = this._moduleRegistry;\n      } else {\n        moduleRegistry = this._isolatedModuleRegistry;\n      }\n    } else {\n      moduleRegistry = this._internalModuleRegistry;\n    }\n\n    const module = moduleRegistry.get(modulePath);\n\n    if (module) {\n      return module.exports;\n    } // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n\n\n    const localModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      loaded: false\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    this._loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry);\n\n    return localModule.exports;\n  }\n\n  requireInternalModule(from, to) {\n    return this.requireModule(from, to, {\n      isInternalModule: true\n    });\n  }\n\n  requireActual(from, moduleName) {\n    return this.requireModule(from, moduleName, undefined, true);\n  }\n\n  requireMock(from, moduleName) {\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n    if (this._isolatedMockRegistry && this._isolatedMockRegistry.get(moduleID)) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.get(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (moduleID in this._mockFactories) {\n      const module = this._mockFactories[moduleID]();\n\n      mockRegistry.set(moduleID, module);\n      return module;\n    }\n\n    const manualMockOrStub = this._resolver.getMockModule(from, moduleName);\n\n    let modulePath;\n\n    if (manualMockOrStub) {\n      modulePath = this._resolveModule(from, manualMockOrStub);\n    } else {\n      modulePath = this._resolveModule(from, moduleName);\n    }\n\n    let isManualMock = manualMockOrStub && !this._resolver.resolveStubModuleName(from, moduleName);\n\n    if (!isManualMock) {\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      const moduleDir = _path().default.dirname(modulePath);\n\n      const moduleFileName = _path().default.basename(modulePath);\n\n      const potentialManualMock = _path().default.join(moduleDir, '__mocks__', moduleFileName);\n\n      if (_gracefulFs().default.existsSync(potentialManualMock)) {\n        isManualMock = true;\n        modulePath = potentialManualMock;\n      }\n    }\n\n    if (isManualMock) {\n      const localModule = {\n        children: [],\n        exports: {},\n        filename: modulePath,\n        id: modulePath,\n        loaded: false\n      };\n\n      this._loadModule(localModule, from, moduleName, modulePath, undefined, mockRegistry);\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  _loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry) {\n    if (_path().default.extname(modulePath) === '.json') {\n      const text = (0, _stripBom().default)(_gracefulFs().default.readFileSync(modulePath, 'utf8'));\n\n      const transformedFile = this._scriptTransformer.transformJson(modulePath, this._getFullTransformationOptions(options), text);\n\n      localModule.exports = this._environment.global.JSON.parse(transformedFile);\n    } else if (_path().default.extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n\n      this._execModule(localModule, options, moduleRegistry, fromPath);\n    }\n\n    localModule.loaded = true;\n  }\n\n  _getFullTransformationOptions(options) {\n    return _objectSpread({}, options, {\n      changedFiles: this._coverageOptions.changedFiles,\n      collectCoverage: this._coverageOptions.collectCoverage,\n      collectCoverageFrom: this._coverageOptions.collectCoverageFrom,\n      collectCoverageOnlyFrom: this._coverageOptions.collectCoverageOnlyFrom,\n      extraGlobals: this._config.extraGlobals || []\n    });\n  }\n\n  requireModuleOrMock(from, moduleName) {\n    try {\n      if (this._shouldMock(from, moduleName)) {\n        return this.requireMock(from, moduleName);\n      } else {\n        return this.requireModule(from, moduleName);\n      }\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND') {\n        const appendedMessage = (0, _helpers.findSiblingsWithFileExtension)(this._config.moduleFileExtensions, from, moduleName);\n\n        if (appendedMessage) {\n          e.message += appendedMessage;\n        }\n      }\n\n      throw e;\n    }\n  }\n\n  isolateModules(fn) {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error('isolateModules cannot be nested inside another isolateModules.');\n    }\n\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n    fn();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n  }\n\n  resetModules() {\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n\n    this._mockRegistry.clear();\n\n    this._moduleRegistry.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        Object.keys(envGlobal).forEach(key => {\n          const globalMock = envGlobal[key];\n\n          if ((typeof globalMock === 'object' && globalMock !== null || typeof globalMock === 'function') && globalMock._isMockFunction === true) {\n            globalMock.mockClear();\n          }\n        });\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  getAllCoverageInfoCopy() {\n    return (0, _jestUtil().deepCyclicCopy)(this._environment.global.__coverage__);\n  }\n\n  getSourceMapInfo(coveredFiles) {\n    return Object.keys(this._sourceMapRegistry).reduce((result, sourcePath) => {\n      if (coveredFiles.has(sourcePath) && this._needsCoverageMapped.has(sourcePath) && _gracefulFs().default.existsSync(this._sourceMapRegistry[sourcePath])) {\n        result[sourcePath] = this._sourceMapRegistry[sourcePath];\n      }\n\n      return result;\n    }, {});\n  }\n\n  getSourceMaps() {\n    return this._sourceMapRegistry;\n  }\n\n  setMock(from, moduleName, mockFactory, options) {\n    if (options && options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks[mockPath] = true;\n    }\n\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n    this._explicitShouldMock[moduleID] = true;\n    this._mockFactories[moduleID] = mockFactory;\n  }\n\n  restoreAllMocks() {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks() {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks() {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  _resolveModule(from, to) {\n    return to ? this._resolver.resolveModule(from, to) : from;\n  }\n\n  _requireResolve(from, moduleName, options = {}) {\n    if (moduleName == null) {\n      throw new Error('The first argument to require.resolve must be a string. Received null or undefined.');\n    }\n\n    const paths = options.paths;\n\n    if (paths) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          const p = _step.value;\n\n          const absolutePath = _path().default.resolve(from, '..', p);\n\n          const module = this._resolver.resolveModuleFromDirIfExists(absolutePath, moduleName, // required to also resolve files without leading './' directly in the path\n          {\n            paths: [absolutePath]\n          });\n\n          if (module) {\n            return module;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      throw new Error(\"Cannot resolve module '\".concat(moduleName, \"' from paths ['\").concat(paths.join(\"', '\"), \"'] from \").concat(from));\n    }\n\n    try {\n      return this._resolveModule(from, moduleName);\n    } catch (err) {\n      const module = this._resolver.getMockModule(from, moduleName);\n\n      if (module) {\n        return module;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _requireResolvePaths(from, moduleName) {\n    if (moduleName == null) {\n      throw new Error('The first argument to require.resolve.paths must be a string. Received null or undefined.');\n    }\n\n    if (!moduleName.length) {\n      throw new Error('The first argument to require.resolve.paths must not be the empty string.');\n    }\n\n    if (moduleName[0] === '.') {\n      return [_path().default.resolve(from, '..')];\n    }\n\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n\n    return this._resolver.getModulePaths(_path().default.resolve(from, '..'));\n  }\n\n  _execModule(localModule, options, moduleRegistry, from) {\n    // If the environment was disposed, prevent this module from being executed.\n    if (!this._environment.global) {\n      return;\n    }\n\n    const filename = localModule.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n\n    const dirname = _path().default.dirname(filename);\n\n    localModule.children = [];\n    Object.defineProperty(localModule, 'parent', {\n      enumerable: true,\n\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      }\n\n    });\n    localModule.paths = this._resolver.getModulePaths(dirname);\n    Object.defineProperty(localModule, 'require', {\n      value: this._createRequireImplementation(localModule, options)\n    });\n    const extraGlobals = this._config.extraGlobals || [];\n\n    const transformedFile = this._scriptTransformer.transform(filename, this._getFullTransformationOptions(options), this._cacheFS[filename]);\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry[filename] = transformedFile.sourceMapPath;\n\n      if (transformedFile.mapCoverage) {\n        this._needsCoverageMapped.add(filename);\n      }\n    }\n\n    const runScript = this._environment.runScript(transformedFile.script);\n\n    if (runScript === null) {\n      this._logFormattedReferenceError('You are trying to `import` a file after the Jest environment has been torn down.');\n\n      process.exitCode = 1;\n      return;\n    } //Wrapper\n\n\n    runScript[_transform().ScriptTransformer.EVAL_RESULT_VARIABLE].call(localModule.exports, localModule, // module object\n    localModule.exports, // module exports\n    localModule.require, // require implementation\n    dirname, // __dirname\n    filename, // __filename\n    this._environment.global, // global object\n    this._createJestObjectFor(filename, localModule.require), // jest object\n    ...extraGlobals.map(globalVariable => {\n      if (this._environment.global[globalVariable]) {\n        return this._environment.global[globalVariable];\n      }\n\n      throw new Error(\"You have requested '\".concat(globalVariable, \"' as a global variable, but it was not present. Please check your config or your global environment.\"));\n    }));\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  _requireCoreModule(moduleName) {\n    if (moduleName === 'process') {\n      return this._environment.global.process;\n    }\n\n    return require(moduleName);\n  }\n\n  _generateMock(from, moduleName) {\n    const modulePath = this._resolver.resolveStubModuleName(from, moduleName) || this._resolveModule(from, moduleName);\n\n    if (!(modulePath in this._mockMetaDataCache)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n      this._mockMetaDataCache[modulePath] = this._moduleMocker.getMetadata({}) || {}; // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n      const moduleExports = this.requireModule(from, moduleName); // Restore the \"real\" module/mock registries\n\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n\n      if (mockMetadata == null) {\n        throw new Error(\"Failed to get mock metadata: \".concat(modulePath, \"\\n\\n\") + \"See: https://jestjs.io/docs/manual-mocks.html#content\");\n      }\n\n      this._mockMetaDataCache[modulePath] = mockMetadata;\n    }\n\n    return this._moduleMocker.generateFromMetadata(this._mockMetaDataCache[modulePath]);\n  }\n\n  _shouldMock(from, moduleName) {\n    const explicitShouldMock = this._explicitShouldMock;\n\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n    const key = from + _path().default.delimiter + moduleID;\n\n    if (moduleID in explicitShouldMock) {\n      return explicitShouldMock[moduleID];\n    }\n\n    if (!this._shouldAutoMock || this._resolver.isCoreModule(moduleName) || this._shouldUnmockTransitiveDependenciesCache[key]) {\n      return false;\n    }\n\n    if (moduleID in this._shouldMockModuleCache) {\n      return this._shouldMockModuleCache[moduleID];\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = this._resolveModule(from, moduleName);\n    } catch (e) {\n      const manualMock = this._resolver.getMockModule(from, moduleName);\n\n      if (manualMock) {\n        this._shouldMockModuleCache[moduleID] = true;\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache[moduleID] = false;\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n\n    const currentModuleID = this._resolver.getModuleID(this._virtualMocks, from);\n\n    if (this._transitiveShouldMock[currentModuleID] === false || from.includes(NODE_MODULES) && modulePath.includes(NODE_MODULES) && (this._unmockList && this._unmockList.test(from) || explicitShouldMock[currentModuleID] === false)) {\n      this._transitiveShouldMock[moduleID] = false;\n      this._shouldUnmockTransitiveDependenciesCache[key] = true;\n      return false;\n    }\n\n    return this._shouldMockModuleCache[moduleID] = true;\n  }\n\n  _createRequireImplementation(from, options) {\n    // TODO: somehow avoid having to type the arguments - they should come from `NodeRequire/LocalModuleRequire.resolve`\n    const resolve = (moduleName, options) => this._requireResolve(from.filename, moduleName, options);\n\n    resolve.paths = moduleName => this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire = options && options.isInternalModule ? moduleName => this.requireInternalModule(from.filename, moduleName) : this.requireModuleOrMock.bind(this, from.filename);\n    moduleRequire.cache = Object.create(null);\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.requireActual = this.requireActual.bind(this, from.filename);\n    moduleRequire.requireMock = this.requireMock.bind(this, from.filename);\n    moduleRequire.resolve = resolve;\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n\n      get() {\n        let mainModule = from.parent;\n\n        while (mainModule && mainModule.parent && mainModule.id !== mainModule.parent.id) {\n          mainModule = mainModule.parent;\n        }\n\n        return mainModule;\n      }\n\n    });\n    return moduleRequire;\n  }\n\n  _createJestObjectFor(from, localRequire) {\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n\n    const unmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n      this._explicitShouldMock[moduleID] = false;\n      return jestObject;\n    };\n\n    const deepUnmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n      this._explicitShouldMock[moduleID] = false;\n      this._transitiveShouldMock[moduleID] = false;\n      return jestObject;\n    };\n\n    const mock = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n      this._explicitShouldMock[moduleID] = true;\n      return jestObject;\n    };\n\n    const setMockFactory = (moduleName, mockFactory, options) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n\n    const useFakeTimers = () => {\n      _getFakeTimers().useFakeTimers();\n\n      return jestObject;\n    };\n\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n\n      return jestObject;\n    };\n\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n\n    const isolateModules = fn => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n\n    const setTimeout = timeout => {\n      if (this._environment.global.jasmine) {\n        this._environment.global.jasmine._DEFAULT_TIMEOUT_INTERVAL = timeout;\n      } else {\n        // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/24587\n        this._environment.global[testTimeoutSymbol] = timeout;\n      }\n\n      return jestObject;\n    };\n\n    const retryTimes = numTestRetries => {\n      // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/24587\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      return jestObject;\n    };\n\n    const _getFakeTimers = () => {\n      if (!this._environment.fakeTimers) {\n        this._logFormattedReferenceError('You are trying to access a property or method of the Jest environment after it has been torn down.');\n\n        process.exitCode = 1;\n      } // We've logged a user message above, so it doesn't matter if we return `null` here\n\n\n      return this._environment.fakeTimers;\n    };\n\n    const jestObject = {\n      addMatchers: matchers => this._environment.global.jasmine.addMatchers(matchers),\n      advanceTimersByTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersToNextTimer: steps => _getFakeTimers().advanceTimersToNextTimer(steps),\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      genMockFromModule: moduleName => this._generateMock(from, moduleName),\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      mock,\n      requireActual: localRequire.requireActual,\n      requireMock: localRequire.requireMock,\n      resetAllMocks,\n      resetModuleRegistry: resetModules,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => _getFakeTimers().runAllImmediates(),\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      runTimersToTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      setMock: (moduleName, mock) => setMockFactory(moduleName, () => mock),\n      setTimeout,\n      spyOn,\n      unmock,\n      useFakeTimers,\n      useRealTimers\n    };\n    return jestObject;\n  }\n\n  _logFormattedReferenceError(errorMessage) {\n    const originalStack = new ReferenceError(errorMessage).stack.split('\\n') // Remove this file from the stack (jest-message-utils will keep one line)\n    .filter(line => line.indexOf(__filename) === -1).join('\\n');\n\n    const _separateMessageFromS = (0, _jestMessageUtil().separateMessageFromStack)(originalStack),\n          message = _separateMessageFromS.message,\n          stack = _separateMessageFromS.stack;\n\n    console.error(\"\\n\".concat(message, \"\\n\") + (0, _jestMessageUtil().formatStackTrace)(stack, this._config, {\n      noStackTrace: false\n    }));\n  }\n\n}\n\n_defineProperty(Runtime, 'ScriptTransformer', void 0);\n\nRuntime.ScriptTransformer = _transform().ScriptTransformer;\nmodule.exports = Runtime;","map":null,"metadata":{},"sourceType":"script"}