{"ast":null,"code":"'use strict';\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _child_process() {\n  const data = require('child_process');\n\n  _child_process = function _child_process() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _constants = _interopRequireDefault(require('../constants'));\n\nvar fastPath = _interopRequireWildcard(require('../lib/fast_path'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction find(roots, extensions, ignore, callback) {\n  const result = [];\n  let activeCalls = 0;\n\n  function search(directory) {\n    activeCalls++;\n\n    _fs().default.readdir(directory, (err, names) => {\n      activeCalls--;\n\n      if (err) {\n        callback(result);\n        return;\n      }\n\n      names.forEach(file => {\n        file = _path().default.join(directory, file);\n\n        if (ignore(file)) {\n          return;\n        }\n\n        activeCalls++;\n\n        _fs().default.lstat(file, (err, stat) => {\n          activeCalls--;\n\n          if (!err && stat && !stat.isSymbolicLink()) {\n            if (stat.isDirectory()) {\n              search(file);\n            } else {\n              const ext = _path().default.extname(file).substr(1);\n\n              if (extensions.indexOf(ext) !== -1) {\n                result.push([file, stat.mtime.getTime(), stat.size]);\n              }\n            }\n          }\n\n          if (activeCalls === 0) {\n            callback(result);\n          }\n        });\n      });\n\n      if (activeCalls === 0) {\n        callback(result);\n      }\n    });\n  }\n\n  if (roots.length > 0) {\n    roots.forEach(search);\n  } else {\n    callback(result);\n  }\n}\n\nfunction findNative(roots, extensions, ignore, callback) {\n  const args = Array.from(roots);\n  args.push('-type', 'f');\n\n  if (extensions.length) {\n    args.push('(');\n  }\n\n  extensions.forEach((ext, index) => {\n    if (index) {\n      args.push('-o');\n    }\n\n    args.push('-iname');\n    args.push('*.' + ext);\n  });\n\n  if (extensions.length) {\n    args.push(')');\n  }\n\n  const child = (0, _child_process().spawn)('find', args);\n  let stdout = '';\n\n  if (child.stdout === null) {\n    throw new Error('stdout is null - this should never happen. Please open up an issue at https://github.com/facebook/jest');\n  }\n\n  child.stdout.setEncoding('utf-8');\n  child.stdout.on('data', data => stdout += data);\n  child.stdout.on('close', () => {\n    const lines = stdout.trim().split('\\n').filter(x => !ignore(x));\n    const result = [];\n    let count = lines.length;\n\n    if (!count) {\n      callback([]);\n    } else {\n      lines.forEach(path => {\n        _fs().default.stat(path, (err, stat) => {\n          if (!err && stat) {\n            result.push([path, stat.mtime.getTime(), stat.size]);\n          }\n\n          if (--count === 0) {\n            callback(result);\n          }\n        });\n      });\n    }\n  });\n}\n\nmodule.exports = function nodeCrawl(options) {\n  const data = options.data,\n        extensions = options.extensions,\n        forceNodeFilesystemAPI = options.forceNodeFilesystemAPI,\n        ignore = options.ignore,\n        rootDir = options.rootDir,\n        roots = options.roots;\n  return new Promise(resolve => {\n    const callback = list => {\n      const files = new Map();\n      const removedFiles = new Map(data.files);\n      list.forEach(fileData => {\n        const _fileData = _slicedToArray(fileData, 3),\n              filePath = _fileData[0],\n              mtime = _fileData[1],\n              size = _fileData[2];\n\n        const relativeFilePath = fastPath.relative(rootDir, filePath);\n        const existingFile = data.files.get(relativeFilePath);\n\n        if (existingFile && existingFile[_constants.default.MTIME] === mtime) {\n          files.set(relativeFilePath, existingFile);\n        } else {\n          // See ../constants.js; SHA-1 will always be null and fulfilled later.\n          files.set(relativeFilePath, ['', mtime, size, 0, '', null]);\n        }\n\n        removedFiles.delete(relativeFilePath);\n      });\n      data.files = files;\n      resolve({\n        hasteMap: data,\n        removedFiles\n      });\n    };\n\n    if (forceNodeFilesystemAPI || process.platform === 'win32') {\n      find(roots, extensions, ignore, callback);\n    } else {\n      findNative(roots, extensions, ignore, callback);\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}