{"ast":null,"code":"'use strict';\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function _fbWatchman() {\n    return data;\n  };\n\n  return data;\n}\n\nvar fastPath = _interopRequireWildcard(require('../lib/fast_path'));\n\nvar _normalizePathSep = _interopRequireDefault(require('../lib/normalizePathSep'));\n\nvar _constants = _interopRequireDefault(require('../constants'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting.html';\n\nfunction WatchmanError(error) {\n  error.message = \"Watchman error: \".concat(error.message.trim(), \". Make sure watchman \") + \"is running for this project. See \".concat(watchmanURL, \".\");\n  return error;\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  var _watchmanCrawl = _asyncToGenerator(function* (options) {\n    const fields = ['name', 'exists', 'mtime_ms', 'size'];\n    const data = options.data,\n          extensions = options.extensions,\n          ignore = options.ignore,\n          rootDir = options.rootDir,\n          roots = options.roots;\n    const defaultWatchExpression = ['allof', ['type', 'f'], ['anyof', ...extensions.map(extension => ['suffix', extension])]];\n    const clocks = data.clocks;\n    const client = new (_fbWatchman().default.Client)();\n    let clientError;\n    client.on('error', error => clientError = WatchmanError(error)); // TODO: type better than `any`\n\n    const cmd = (...args) => new Promise((resolve, reject) => client.command(args, (error, result) => error ? reject(WatchmanError(error)) : resolve(result)));\n\n    if (options.computeSha1) {\n      const _ref = yield cmd('list-capabilities'),\n            capabilities = _ref.capabilities;\n\n      if (capabilities.indexOf('field-content.sha1hex') !== -1) {\n        fields.push('content.sha1hex');\n      }\n    }\n\n    function getWatchmanRoots(_x2) {\n      return _getWatchmanRoots.apply(this, arguments);\n    }\n\n    function _getWatchmanRoots() {\n      _getWatchmanRoots = _asyncToGenerator(function* (roots) {\n        const watchmanRoots = new Map();\n        yield Promise.all(roots.map(\n        /*#__PURE__*/\n        function () {\n          var _ref2 = _asyncToGenerator(function* (root) {\n            const response = yield cmd('watch-project', root);\n            const existing = watchmanRoots.get(response.watch); // A root can only be filtered if it was never seen with a\n            // relative_path before.\n\n            const canBeFiltered = !existing || existing.length > 0;\n\n            if (canBeFiltered) {\n              if (response.relative_path) {\n                watchmanRoots.set(response.watch, (existing || []).concat(response.relative_path));\n              } else {\n                // Make the filter directories an empty array to signal that this\n                // root was already seen and needs to be watched for all files or\n                // directories.\n                watchmanRoots.set(response.watch, []);\n              }\n            }\n          });\n\n          return function (_x4) {\n            return _ref2.apply(this, arguments);\n          };\n        }()));\n        return watchmanRoots;\n      });\n      return _getWatchmanRoots.apply(this, arguments);\n    }\n\n    function queryWatchmanForDirs(_x3) {\n      return _queryWatchmanForDirs.apply(this, arguments);\n    }\n\n    function _queryWatchmanForDirs() {\n      _queryWatchmanForDirs = _asyncToGenerator(function* (rootProjectDirMappings) {\n        const files = new Map();\n        let isFresh = false;\n        yield Promise.all(Array.from(rootProjectDirMappings).map(\n        /*#__PURE__*/\n        function () {\n          var _ref3 = _asyncToGenerator(function* ([root, directoryFilters]) {\n            const expression = Array.from(defaultWatchExpression);\n            const glob = [];\n\n            if (directoryFilters.length > 0) {\n              expression.push(['anyof', ...directoryFilters.map(dir => ['dirname', dir])]);\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n              var _iteratorError2 = undefined;\n\n              try {\n                for (var _iterator2 = directoryFilters[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  const directory = _step2.value;\n                  var _iteratorNormalCompletion3 = true;\n                  var _didIteratorError3 = false;\n                  var _iteratorError3 = undefined;\n\n                  try {\n                    for (var _iterator3 = extensions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                      const extension = _step3.value;\n                      glob.push(\"\".concat(directory, \"/**/*.\").concat(extension));\n                    }\n                  } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                        _iterator3.return();\n                      }\n                    } finally {\n                      if (_didIteratorError3) {\n                        throw _iteratorError3;\n                      }\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    _iterator2.return();\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            } else {\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  const extension = _step4.value;\n                  glob.push(\"**/*.\".concat(extension));\n                }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n            }\n\n            const relativeRoot = fastPath.relative(rootDir, root);\n            const query = clocks.has(relativeRoot) // Use the `since` generator if we have a clock available\n            ? {\n              expression,\n              fields,\n              since: clocks.get(relativeRoot) // Otherwise use the `glob` filter\n\n            } : {\n              expression,\n              fields,\n              glob\n            };\n            const response = yield cmd('query', root, query);\n\n            if ('warning' in response) {\n              console.warn('watchman warning: ', response.warning);\n            }\n\n            isFresh = isFresh || response.is_fresh_instance;\n            files.set(root, response);\n          });\n\n          return function (_x5) {\n            return _ref3.apply(this, arguments);\n          };\n        }()));\n        return {\n          files,\n          isFresh\n        };\n      });\n      return _queryWatchmanForDirs.apply(this, arguments);\n    }\n\n    let files = data.files;\n    let removedFiles = new Map();\n    const changedFiles = new Map();\n    let watchmanFiles;\n    let isFresh = false;\n\n    try {\n      const watchmanRoots = yield getWatchmanRoots(roots);\n      const watchmanFileResults = yield queryWatchmanForDirs(watchmanRoots); // Reset the file map if watchman was restarted and sends us a list of\n      // files.\n\n      if (watchmanFileResults.isFresh) {\n        files = new Map();\n        removedFiles = new Map(data.files);\n        isFresh = true;\n      }\n\n      watchmanFiles = watchmanFileResults.files;\n    } finally {\n      client.end();\n    }\n\n    if (clientError) {\n      throw clientError;\n    } // TODO: remove non-null\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = watchmanFiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const _step$value = _slicedToArray(_step.value, 2),\n              watchRoot = _step$value[0],\n              response = _step$value[1];\n\n        const fsRoot = (0, _normalizePathSep.default)(watchRoot);\n        const relativeFsRoot = fastPath.relative(rootDir, fsRoot);\n        clocks.set(relativeFsRoot, response.clock);\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = response.files[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            const fileData = _step5.value;\n            const filePath = fsRoot + _path().default.sep + (0, _normalizePathSep.default)(fileData.name);\n            const relativeFilePath = fastPath.relative(rootDir, filePath);\n            const existingFileData = data.files.get(relativeFilePath); // If watchman is fresh, the removed files map starts with all files\n            // and we remove them as we verify they still exist.\n\n            if (isFresh && existingFileData && fileData.exists) {\n              removedFiles.delete(relativeFilePath);\n            }\n\n            if (!fileData.exists) {\n              // No need to act on files that do not exist and were not tracked.\n              if (existingFileData) {\n                files.delete(relativeFilePath); // If watchman is not fresh, we will know what specific files were\n                // deleted since we last ran and can track only those files.\n\n                if (!isFresh) {\n                  removedFiles.set(relativeFilePath, existingFileData);\n                }\n              }\n            } else if (!ignore(filePath)) {\n              const mtime = typeof fileData.mtime_ms === 'number' ? fileData.mtime_ms : fileData.mtime_ms.toNumber();\n              const size = fileData.size;\n              let sha1hex = fileData['content.sha1hex'];\n\n              if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {\n                sha1hex = null;\n              }\n\n              let nextData;\n\n              if (existingFileData && existingFileData[_constants.default.MTIME] === mtime) {\n                nextData = existingFileData;\n              } else if (existingFileData && sha1hex && existingFileData[_constants.default.SHA1] === sha1hex) {\n                nextData = [existingFileData[0], mtime, existingFileData[2], existingFileData[3], existingFileData[4], existingFileData[5]];\n              } else {\n                // See ../constants.ts\n                nextData = ['', mtime, size, 0, '', sha1hex];\n              }\n\n              const mappings = options.mapper ? options.mapper(filePath) : null;\n\n              if (mappings) {\n                var _iteratorNormalCompletion6 = true;\n                var _didIteratorError6 = false;\n                var _iteratorError6 = undefined;\n\n                try {\n                  for (var _iterator6 = mappings[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    const absoluteVirtualFilePath = _step6.value;\n\n                    if (!ignore(absoluteVirtualFilePath)) {\n                      const relativeVirtualFilePath = fastPath.relative(rootDir, absoluteVirtualFilePath);\n                      files.set(relativeVirtualFilePath, nextData);\n                      changedFiles.set(relativeVirtualFilePath, nextData);\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError6 = true;\n                  _iteratorError6 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                      _iterator6.return();\n                    }\n                  } finally {\n                    if (_didIteratorError6) {\n                      throw _iteratorError6;\n                    }\n                  }\n                }\n              } else {\n                files.set(relativeFilePath, nextData);\n                changedFiles.set(relativeFilePath, nextData);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    data.files = files;\n    return {\n      changedFiles: isFresh ? undefined : changedFiles,\n      hasteMap: data,\n      removedFiles\n    };\n  });\n\n  function watchmanCrawl(_x) {\n    return _watchmanCrawl.apply(this, arguments);\n  }\n\n  return watchmanCrawl;\n}();","map":null,"metadata":{},"sourceType":"script"}