{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _fs = require(\"fs\");\n\nvar _path = require(\"path\");\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _istanbulLibInstrument = require(\"istanbul-lib-instrument\");\n\nconst testExclude = require('test-exclude');\n\nconst findUp = require('find-up');\n\nfunction getRealpath(n) {\n  try {\n    return (0, _fs.realpathSync)(n) || n;\n  } catch (e) {\n    return n;\n  }\n}\n\nfunction makeShouldSkip() {\n  let exclude;\n  return function shouldSkip(file, opts) {\n    if (!exclude || exclude.cwd !== opts.cwd) {\n      const cwd = getRealpath(process.env.NYC_CWD || process.cwd());\n      const nycConfig = process.env.NYC_CONFIG ? JSON.parse(process.env.NYC_CONFIG) : {};\n      let config = {};\n\n      if (Object.keys(opts).length > 0) {\n        // explicitly configuring options in babel\n        // takes precedence.\n        config = opts;\n      } else if (nycConfig.include || nycConfig.exclude) {\n        // nyc was configured in a parent process (keep these settings).\n        config = {\n          include: nycConfig.include,\n          exclude: nycConfig.exclude,\n          // Make sure this is true unless explicitly set to `false`. `undefined` is still `true`.\n          excludeNodeModules: nycConfig.excludeNodeModules !== false\n        };\n      } else {\n        // fallback to loading config from key in package.json.\n        config = {\n          configKey: 'nyc',\n          configPath: (0, _path.dirname)(findUp.sync('package.json', {\n            cwd\n          }))\n        };\n      }\n\n      exclude = testExclude(Object.assign({\n        cwd\n      }, config));\n    }\n\n    return !exclude.shouldInstrument(file);\n  };\n}\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  const t = api.types;\n  const shouldSkip = makeShouldSkip();\n  return {\n    visitor: {\n      Program: {\n        enter(path) {\n          this.__dv__ = null;\n          const realPath = getRealpath(this.file.opts.filename);\n\n          if (shouldSkip(realPath, this.opts)) {\n            return;\n          }\n\n          let inputSourceMap = this.opts.inputSourceMap;\n\n          if (this.opts.useInlineSourceMaps !== false) {\n            if (!inputSourceMap && this.file.inputMap) {\n              inputSourceMap = this.file.inputMap.sourcemap;\n            }\n          }\n\n          this.__dv__ = (0, _istanbulLibInstrument.programVisitor)(t, realPath, {\n            coverageVariable: '__coverage__',\n            inputSourceMap\n          });\n\n          this.__dv__.enter(path);\n        },\n\n        exit(path) {\n          if (!this.__dv__) {\n            return;\n          }\n\n          const result = this.__dv__.exit(path);\n\n          if (this.opts.onCover) {\n            this.opts.onCover(getRealpath(this.file.opts.filename), result.fileCoverage);\n          }\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}