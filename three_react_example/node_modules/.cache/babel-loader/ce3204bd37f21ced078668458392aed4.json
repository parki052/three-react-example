{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.saveInlineSnapshots = void 0;\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _path = _interopRequireDefault(require('path'));\n\nvar _semver = _interopRequireDefault(require('semver'));\n\nvar _types = require('@babel/types');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestWriteFile = global[Symbol.for('jest-native-write-file')] || _fs.default.writeFileSync;\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestReadFile = global[Symbol.for('jest-native-read-file')] || _fs.default.readFileSync;\n\nconst saveInlineSnapshots = (snapshots, prettier, babelTraverse) => {\n  if (!prettier) {\n    throw new Error(\"Jest: Inline Snapshots requires Prettier.\\n\" + \"Please ensure \\\"prettier\\\" is installed in your project.\");\n  } // Custom parser API was added in 1.5.0\n\n\n  if (_semver.default.lt(prettier.version, '1.5.0')) {\n    throw new Error(\"Jest: Inline Snapshots require prettier>=1.5.0.\\n\" + \"Please upgrade \\\"prettier\\\".\");\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  var _arr = Object.keys(snapshotsByFile);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    const sourceFilePath = _arr[_i];\n    saveSnapshotsForFile(snapshotsByFile[sourceFilePath], sourceFilePath, prettier, babelTraverse);\n  }\n};\n\nexports.saveInlineSnapshots = saveInlineSnapshots;\n\nconst saveSnapshotsForFile = (snapshots, sourceFilePath, prettier, babelTraverse) => {\n  const sourceFile = jestReadFile(sourceFilePath, 'utf8'); // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n\n  const config = prettier.resolveConfig ? prettier.resolveConfig.sync(sourceFilePath, {\n    editorconfig: true\n  }) : null; // Detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n\n  const inferredParser = prettier.getFileInfo ? prettier.getFileInfo.sync(sourceFilePath).inferredParser : config && config.parser || simpleDetectParser(sourceFilePath); // Insert snapshots using the custom parser API. After insertion, the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation).\n\n  const newSourceFile = prettier.format(sourceFile, _objectSpread({}, config, {\n    filepath: sourceFilePath,\n    parser: createInsertionParser(snapshots, inferredParser, babelTraverse)\n  })); // Format the snapshots using the custom parser API.\n\n  const formattedNewSourceFile = prettier.format(newSourceFile, _objectSpread({}, config, {\n    filepath: sourceFilePath,\n    parser: createFormattingParser(inferredParser, babelTraverse)\n  }));\n\n  if (formattedNewSourceFile !== sourceFile) {\n    jestWriteFile(sourceFilePath, formattedNewSourceFile);\n  }\n};\n\nconst groupSnapshotsBy = createKey => snapshots => snapshots.reduce((object, inlineSnapshot) => {\n  const key = createKey(inlineSnapshot);\n  return _objectSpread({}, object, {\n    [key]: (object[key] || []).concat(inlineSnapshot)\n  });\n}, {});\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(({\n  frame: {\n    line,\n    column\n  }\n}) => typeof line === 'number' && typeof column === 'number' ? \"\".concat(line, \":\").concat(column - 1) : '');\nconst groupSnapshotsByFile = groupSnapshotsBy(({\n  frame: {\n    file\n  }\n}) => file);\n\nconst indent = (snapshot, numIndents, indentation) => {\n  const lines = snapshot.split('\\n'); // Prevent re-identation of inline snapshots.\n\n  if (lines.length >= 2 && lines[1].startsWith(indentation.repeat(numIndents + 1))) {\n    return snapshot;\n  }\n\n  return lines.map((line, index) => {\n    if (index === 0) {\n      // First line is either a 1-line snapshot or a blank line.\n      return line;\n    } else if (index !== lines.length - 1) {\n      // Do not indent empty lines.\n      if (line === '') {\n        return line;\n      } // Not last line, indent one level deeper than expect call.\n\n\n      return indentation.repeat(numIndents + 1) + line;\n    } else {\n      // The last line should be placed on the same level as the expect call.\n      return indentation.repeat(numIndents) + line;\n    }\n  }).join('\\n');\n};\n\nconst getAst = (parsers, inferredParser, text) => {\n  // Flow uses a 'Program' parent node, babel expects a 'File'.\n  let ast = parsers[inferredParser](text);\n\n  if (ast.type !== 'File') {\n    ast = (0, _types.file)(ast, ast.comments, ast.tokens);\n    delete ast.program.comments;\n  }\n\n  return ast;\n}; // This parser inserts snapshots into the AST.\n\n\nconst createInsertionParser = (snapshots, inferredParser, babelTraverse) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(({\n    snapshot\n  }) => snapshot));\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({\n      node: {\n        arguments: args,\n        callee\n      }\n    }) {\n      if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier') {\n        return;\n      }\n\n      const _callee$property$loc$ = callee.property.loc.start,\n            line = _callee$property$loc$.line,\n            column = _callee$property$loc$.column;\n      const snapshotsForFrame = groupedSnapshots[\"\".concat(line, \":\").concat(column)];\n\n      if (!snapshotsForFrame) {\n        return;\n      }\n\n      if (snapshotsForFrame.length > 1) {\n        throw new Error('Jest: Multiple inline snapshots for the same call are not supported.');\n      }\n\n      const snapshotIndex = args.findIndex(({\n        type\n      }) => type === 'TemplateLiteral');\n      const values = snapshotsForFrame.map(({\n        snapshot\n      }) => {\n        remainingSnapshots.delete(snapshot);\n        return (0, _types.templateLiteral)([(0, _types.templateElement)({\n          raw: (0, _utils.escapeBacktickString)(snapshot)\n        })], []);\n      });\n      const replacementNode = values[0];\n\n      if (snapshotIndex > -1) {\n        args[snapshotIndex] = replacementNode;\n      } else {\n        args.push(replacementNode);\n      }\n    }\n\n  });\n\n  if (remainingSnapshots.size) {\n    throw new Error(\"Jest: Couldn't locate all inline snapshots.\");\n  }\n\n  return ast;\n}; // This parser formats snapshots to the correct indentation.\n\n\nconst createFormattingParser = (inferredParser, babelTraverse) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({\n      node: {\n        arguments: args,\n        callee\n      }\n    }) {\n      if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier' || callee.property.name !== 'toMatchInlineSnapshot' || !callee.loc || callee.computed) {\n        return;\n      }\n\n      let snapshotIndex;\n      let snapshot;\n\n      for (let i = 0; i < args.length; i++) {\n        const node = args[i];\n\n        if (node.type === 'TemplateLiteral') {\n          snapshotIndex = i;\n          snapshot = node.quasis[0].value.raw;\n        }\n      }\n\n      if (snapshot === undefined || snapshotIndex === undefined) {\n        return;\n      }\n\n      const useSpaces = !options.useTabs;\n      snapshot = indent(snapshot, Math.ceil(useSpaces ? callee.loc.start.column / options.tabWidth : callee.loc.start.column / 2 // Each tab is 2 characters.\n      ), useSpaces ? ' '.repeat(options.tabWidth) : '\\t');\n      const replacementNode = (0, _types.templateLiteral)([(0, _types.templateElement)({\n        raw: snapshot\n      })], []);\n      args[snapshotIndex] = replacementNode;\n    }\n\n  });\n  return ast;\n};\n\nconst simpleDetectParser = filePath => {\n  const extname = _path.default.extname(filePath);\n\n  if (/tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n\n  return 'babylon';\n};","map":null,"metadata":{},"sourceType":"script"}