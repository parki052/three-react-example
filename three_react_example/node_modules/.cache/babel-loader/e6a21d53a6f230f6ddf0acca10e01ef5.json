{"ast":null,"code":"'use strict';\n\nconst color = require('kleur');\n\nconst Prompt = require('./prompt');\n\nconst _require = require('sisteransi'),\n      erase = _require.erase,\n      cursor = _require.cursor;\n\nconst _require2 = require('../util'),\n      style = _require2.style,\n      clear = _require2.clear,\n      wrap = _require2.wrap;\n\nconst getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);\n\nconst getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);\n\nconst getIndex = (arr, valOrTitle) => {\n  const index = arr.findIndex(el => el.value === valOrTitle || el.title === valOrTitle);\n  return index > -1 ? index : undefined;\n};\n/**\n * TextPrompt Base Element\n * @param {Object} opts Options\n * @param {String} opts.message Message\n * @param {Array} opts.choices Array of auto-complete choices objects\n * @param {Function} [opts.suggest] Filter function. Defaults to sort by title\n * @param {Number} [opts.limit=10] Max number of results to show\n * @param {Number} [opts.cursor=0] Cursor start position\n * @param {String} [opts.style='default'] Render style\n * @param {String} [opts.fallback] Fallback message - initial to default value\n * @param {String} [opts.initial] Index of the default value\n * @param {Stream} [opts.stdin] The Readable stream to listen to\n * @param {Stream} [opts.stdout] The Writable stream to write readline data to\n * @param {String} [opts.noMatches] The no matches found label\n */\n\n\nclass AutocompletePrompt extends Prompt {\n  constructor(opts = {}) {\n    super(opts);\n    this.msg = opts.message;\n    this.suggest = opts.suggest;\n    this.choices = opts.choices;\n    this.initial = typeof opts.initial === 'number' ? opts.initial : getIndex(opts.choices, opts.initial);\n    this.select = this.initial || opts.cursor || 0;\n    this.i18n = {\n      noMatches: opts.noMatches || 'no matches found'\n    };\n    this.fallback = opts.fallback || this.initial;\n    this.suggestions = [[]];\n    this.page = 0;\n    this.input = '';\n    this.limit = opts.limit || 10;\n    this.cursor = 0;\n    this.transform = style.render(opts.style);\n    this.scale = this.transform.scale;\n    this.render = this.render.bind(this);\n    this.complete = this.complete.bind(this);\n    this.clear = clear('');\n    this.complete(this.render);\n    this.render();\n  }\n\n  set fallback(fb) {\n    this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;\n  }\n\n  get fallback() {\n    let choice;\n    if (typeof this._fb === 'number') choice = this.choices[this._fb];else if (typeof this._fb === 'string') choice = {\n      title: this._fb\n    };\n    return choice || this._fb || {\n      title: this.i18n.noMatches\n    };\n  }\n\n  moveSelect(i) {\n    this.select = i;\n    if (this.suggestions[this.page].length > 0) this.value = getVal(this.suggestions[this.page], i);else this.value = this.fallback.value;\n    this.fire();\n  }\n\n  async complete(cb) {\n    const p = this.completing = this.suggest(this.input, this.choices);\n    const suggestions = await p;\n    if (this.completing !== p) return;\n    this.suggestions = suggestions.map((s, i, arr) => ({\n      title: getTitle(arr, i),\n      value: getVal(arr, i),\n      description: s.description\n    })).reduce((arr, sug) => {\n      if (arr[arr.length - 1].length < this.limit) arr[arr.length - 1].push(sug);else arr.push([sug]);\n      return arr;\n    }, [[]]);\n    this.completing = false;\n    if (!this.suggestions[this.page]) this.page = 0; // if (!this.suggestions.length && this.fallback) {\n    //   const index = getIndex(this.choices, this.fallback);\n    //   this.suggestions = [[]];\n    //   if (index !== undefined)\n    //     this.suggestions[0].push({ title: getTitle(this.choices, index), value: getVal(this.choices, index) });\n    //   this.isFallback = true;\n    // }\n\n    const l = Math.max(suggestions.length - 1, 0);\n    this.moveSelect(Math.min(l, this.select));\n    cb && cb();\n  }\n\n  reset() {\n    this.input = '';\n    this.complete(() => {\n      this.moveSelect(this.initial !== void 0 ? this.initial : 0);\n      this.render();\n    });\n    this.render();\n  }\n\n  abort() {\n    this.done = this.aborted = true;\n    this.fire();\n    this.render();\n    this.out.write('\\n');\n    this.close();\n  }\n\n  submit() {\n    this.done = true;\n    this.aborted = false;\n    this.fire();\n    this.render();\n    this.out.write('\\n');\n    this.close();\n  }\n\n  _(c, key) {\n    // TODO on ctrl+# go to page #\n    let s1 = this.input.slice(0, this.cursor);\n    let s2 = this.input.slice(this.cursor);\n    this.input = \"\".concat(s1).concat(c).concat(s2);\n    this.cursor = s1.length + 1;\n    this.complete(this.render);\n    this.render();\n  }\n\n  delete() {\n    if (this.cursor === 0) return this.bell();\n    let s1 = this.input.slice(0, this.cursor - 1);\n    let s2 = this.input.slice(this.cursor);\n    this.input = \"\".concat(s1).concat(s2);\n    this.complete(this.render);\n    this.cursor = this.cursor - 1;\n    this.render();\n  }\n\n  deleteForward() {\n    if (this.cursor * this.scale >= this.rendered.length) return this.bell();\n    let s1 = this.input.slice(0, this.cursor);\n    let s2 = this.input.slice(this.cursor + 1);\n    this.input = \"\".concat(s1).concat(s2);\n    this.complete(this.render);\n    this.render();\n  }\n\n  first() {\n    this.moveSelect(0);\n    this.render();\n  }\n\n  last() {\n    this.moveSelect(this.suggestions[this.page].length - 1);\n    this.render();\n  }\n\n  up() {\n    if (this.select <= 0) return this.bell();\n    this.moveSelect(this.select - 1);\n    this.render();\n  }\n\n  down() {\n    if (this.select >= this.suggestions[this.page].length - 1) return this.bell();\n    this.moveSelect(this.select + 1);\n    this.render();\n  }\n\n  next() {\n    if (this.select === this.suggestions[this.page].length - 1) {\n      this.page = (this.page + 1) % this.suggestions.length;\n      this.moveSelect(0);\n    } else this.moveSelect(this.select + 1);\n\n    this.render();\n  }\n\n  nextPage() {\n    if (this.page >= this.suggestions.length - 1) return this.bell();\n    this.page++;\n    this.moveSelect(0);\n    this.render();\n  }\n\n  prevPage() {\n    if (this.page <= 0) return this.bell();\n    this.page--;\n    this.moveSelect(0);\n    this.render();\n  }\n\n  left() {\n    if (this.cursor <= 0) return this.bell();\n    this.cursor = this.cursor - 1;\n    this.render();\n  }\n\n  right() {\n    if (this.cursor * this.scale >= this.rendered.length) return this.bell();\n    this.cursor = this.cursor + 1;\n    this.render();\n  }\n\n  renderOption(v, hovered) {\n    let desc,\n        title = v.title;\n\n    if (hovered) {\n      title = color.cyan(v.title);\n\n      if (v.description) {\n        desc = \" - \".concat(v.description);\n\n        if (title.length + desc.length >= this.out.columns || v.description.split(/\\r?\\n/).length > 1) {\n          desc = '\\n' + wrap(v.description, {\n            width: this.out.columns\n          });\n        }\n      }\n    }\n\n    return title + color.gray(desc || '');\n  }\n\n  render() {\n    if (this.closed) return;\n    if (!this.firstRender) this.out.write(clear(this.outputText));\n    super.render();\n    this.outputText = [color.bold(style.symbol(this.done, this.aborted)), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.page][this.select] ? this.suggestions[this.page][this.select].title : this.rendered = this.transform.render(this.input)].join(' ');\n\n    if (!this.done) {\n      const suggestions = this.suggestions[this.page].map((item, i) => this.renderOption(item, this.select === i)).join('\\n');\n      this.outputText += \"\\n\" + (suggestions || color.gray(this.fallback.title));\n\n      if (this.suggestions[this.page].length > 1) {\n        this.outputText += color.blue(\"\\nPage \".concat(this.page + 1, \"/\").concat(this.suggestions.length));\n      }\n    }\n\n    this.out.write(erase.line + cursor.to(0) + this.outputText);\n  }\n\n}\n\nmodule.exports = AutocompletePrompt;","map":null,"metadata":{},"sourceType":"script"}