{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = runTest;\n\nfunction _console() {\n  const data = require('@jest/console');\n\n  _console = function _console() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestLeakDetector() {\n  const data = _interopRequireDefault(require('jest-leak-detector'));\n\n  _jestLeakDetector = function _jestLeakDetector() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function _jestConfig() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction docblock() {\n  const data = _interopRequireWildcard(require('jest-docblock'));\n\n  docblock = function docblock() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sourceMapSupport() {\n  const data = _interopRequireDefault(require('source-map-support'));\n\n  _sourceMapSupport = function _sourceMapSupport() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction freezeConsole(testConsole, config) {\n  // @ts-ignore: `_log` is `private` - we should figure out some proper API here\n  testConsole._log = function fakeConsolePush(_type, message) {\n    const error = new (_jestUtil().ErrorWithStack)(\"\".concat(_chalk().default.red(\"\".concat(_chalk().default.bold('Cannot log after tests are done.'), \" Did you forget to wait for something async in your test?\")), \"\\nAttempted to log \\\"\").concat(message, \"\\\".\"), fakeConsolePush);\n    const formattedError = (0, _jestMessageUtil().formatExecError)(error, config, {\n      noStackTrace: false\n    }, undefined, true);\n    process.stderr.write('\\n' + formattedError + '\\n'); // TODO: set exit code in Jest 25\n    // process.exitCode = 1;\n  };\n} // Keeping the core of \"runTest\" as a separate function (as \"runTestInternal\")\n// is key to be able to detect memory leaks. Since all variables are local to\n// the function, when \"runTestInternal\" finishes its execution, they can all be\n// freed, UNLESS something else is leaking them (and that's why we can detect\n// the leak!).\n//\n// If we had all the code in a single function, we should manually nullify all\n// references to verify if there is a leak, which is not maintainable and error\n// prone. That's why \"runTestInternal\" CANNOT be inlined inside \"runTest\".\n\n\nfunction runTestInternal(_x, _x2, _x3, _x4, _x5) {\n  return _runTestInternal.apply(this, arguments);\n}\n\nfunction _runTestInternal() {\n  _runTestInternal = _asyncToGenerator(function* (path, globalConfig, config, resolver, context) {\n    const testSource = _gracefulFs().default.readFileSync(path, 'utf8');\n\n    const docblockPragmas = docblock().parse(docblock().extract(testSource));\n    const customEnvironment = docblockPragmas['jest-environment'];\n    let testEnvironment = config.testEnvironment;\n\n    if (customEnvironment) {\n      if (Array.isArray(customEnvironment)) {\n        throw new Error(\"You can only define a single test environment through docblocks, got \\\"\".concat(customEnvironment.join(', '), \"\\\"\"));\n      }\n\n      testEnvironment = (0, _jestConfig().getTestEnvironment)(_objectSpread({}, config, {\n        testEnvironment: customEnvironment\n      }));\n    }\n\n    const TestEnvironment = (0, _jestUtil().interopRequireDefault)(require(testEnvironment)).default;\n    const testFramework = process.env.JEST_CIRCUS === '1' ? require('jest-circus/runner') // eslint-disable-line import/no-extraneous-dependencies\n    : require(config.testRunner);\n    const Runtime = config.moduleLoader ? require(config.moduleLoader) : require('jest-runtime');\n    let runtime = undefined;\n    const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;\n\n    const consoleFormatter = (type, message) => (0, _console().getConsoleOutput)(config.cwd, !!globalConfig.verbose, // 4 = the console call is buried 4 stack frames deep\n    _console().BufferedConsole.write([], type, message, 4, runtime && runtime.getSourceMaps()));\n\n    let testConsole;\n\n    if (globalConfig.silent) {\n      testConsole = new (_console().NullConsole)(consoleOut, consoleOut, consoleFormatter);\n    } else if (globalConfig.verbose) {\n      testConsole = new (_console().CustomConsole)(consoleOut, consoleOut, consoleFormatter);\n    } else {\n      testConsole = new (_console().BufferedConsole)(() => runtime && runtime.getSourceMaps());\n    }\n\n    const environment = new TestEnvironment(config, {\n      console: testConsole,\n      docblockPragmas,\n      testPath: path\n    });\n    const leakDetector = config.detectLeaks ? new (_jestLeakDetector().default)(environment) : null;\n    const cacheFS = {\n      [path]: testSource\n    };\n    (0, _jestUtil().setGlobal)(environment.global, 'console', testConsole);\n    runtime = new Runtime(config, environment, resolver, cacheFS, {\n      changedFiles: context && context.changedFiles,\n      collectCoverage: globalConfig.collectCoverage,\n      collectCoverageFrom: globalConfig.collectCoverageFrom,\n      collectCoverageOnlyFrom: globalConfig.collectCoverageOnlyFrom\n    });\n    const start = Date.now();\n    const sourcemapOptions = {\n      environment: 'node',\n      handleUncaughtExceptions: false,\n      retrieveSourceMap: source => {\n        const sourceMaps = runtime && runtime.getSourceMaps();\n        const sourceMapSource = sourceMaps && sourceMaps[source];\n\n        if (sourceMapSource) {\n          try {\n            return {\n              map: JSON.parse(_gracefulFs().default.readFileSync(sourceMapSource, 'utf8')),\n              url: source\n            };\n          } catch (e) {}\n        }\n\n        return null;\n      }\n    }; // For tests\n\n    runtime.requireInternalModule(require.resolve('source-map-support'), 'source-map-support').install(sourcemapOptions); // For runtime errors\n\n    _sourceMapSupport().default.install(sourcemapOptions);\n\n    if (environment.global && environment.global.process && environment.global.process.exit) {\n      const realExit = environment.global.process.exit;\n\n      environment.global.process.exit = function exit(...args) {\n        const error = new (_jestUtil().ErrorWithStack)(\"process.exit called with \\\"\".concat(args.join(', '), \"\\\"\"), exit);\n        const formattedError = (0, _jestMessageUtil().formatExecError)(error, config, {\n          noStackTrace: false\n        }, undefined, true);\n        process.stderr.write(formattedError);\n        return realExit(...args);\n      };\n    }\n\n    try {\n      yield environment.setup();\n      let result;\n\n      try {\n        result = yield testFramework(globalConfig, config, environment, runtime, path);\n      } catch (err) {\n        // Access stack before uninstalling sourcemaps\n        err.stack;\n        throw err;\n      }\n\n      freezeConsole(testConsole, config);\n      const testCount = result.numPassingTests + result.numFailingTests + result.numPendingTests + result.numTodoTests;\n      result.perfStats = {\n        end: Date.now(),\n        start\n      };\n      result.testFilePath = path;\n      result.console = testConsole.getBuffer();\n      result.skipped = testCount === result.numPendingTests;\n      result.displayName = config.displayName;\n      const coverage = runtime.getAllCoverageInfoCopy();\n\n      if (coverage) {\n        const coverageKeys = Object.keys(coverage);\n\n        if (coverageKeys.length) {\n          result.coverage = coverage;\n          result.sourceMaps = runtime.getSourceMapInfo(new Set(coverageKeys));\n        }\n      }\n\n      if (globalConfig.logHeapUsage) {\n        if (global.gc) {\n          global.gc();\n        }\n\n        result.memoryUsage = process.memoryUsage().heapUsed;\n      } // Delay the resolution to allow log messages to be output.\n\n\n      return new Promise(resolve => {\n        setImmediate(() => resolve({\n          leakDetector,\n          result\n        }));\n      });\n    } finally {\n      yield environment.teardown();\n\n      _sourceMapSupport().default.resetRetrieveHandlers();\n    }\n  });\n  return _runTestInternal.apply(this, arguments);\n}\n\nfunction runTest(_x6, _x7, _x8, _x9, _x10) {\n  return _runTest.apply(this, arguments);\n}\n\nfunction _runTest() {\n  _runTest = _asyncToGenerator(function* (path, globalConfig, config, resolver, context) {\n    const _ref = yield runTestInternal(path, globalConfig, config, resolver, context),\n          leakDetector = _ref.leakDetector,\n          result = _ref.result;\n\n    if (leakDetector) {\n      // We wanna allow a tiny but time to pass to allow last-minute cleanup\n      yield new Promise(resolve => setTimeout(resolve, 100)); // Resolve leak detector, outside the \"runTestInternal\" closure.\n\n      result.leaks = leakDetector.isLeaking();\n    } else {\n      result.leaks = false;\n    }\n\n    return result;\n  });\n  return _runTest.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}