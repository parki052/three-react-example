{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst path = require('path');\n\nconst fs = require('fs');\n\nconst debug = require('debug')('istanbuljs');\n\nconst SMC = require('source-map').SourceMapConsumer;\n\nconst pathutils = require('./pathutils');\n\nconst sourceStore = require('./source-store');\n\nconst transformer = require('./transformer');\n/**\n * Tracks source maps for registered files\n */\n\n\nclass MapStore {\n  /**\n   * @param {Object} opts [opts=undefined] options.\n   * @param {Boolean} opts.verbose [opts.verbose=false] verbose mode\n   * @param {String} opts.baseDir [opts.baseDir=null] alternate base directory\n   *  to resolve sourcemap files\n   * @param {String} opts.sourceStore [opts.sourceStore='memory'] - store that tracks\n   *  embedded sources found in source maps, one of 'memory' or 'file'\n   * @param {String} opts.tmpdir [opts.tmpdir=undefined] - temporary directory\n   *   to use for storing files.\n   * @constructor\n   */\n  constructor(opts = {}) {\n    this.baseDir = opts.baseDir || null;\n    this.verbose = opts.verbose || false;\n    this.sourceStore = sourceStore.create(opts.sourceStore, {\n      tmpdir: opts.tmpdir\n    });\n    this.data = Object.create(null);\n  }\n  /**\n   * Registers a source map URL with this store. It makes some input sanity checks\n   * and silently fails on malformed input.\n   * @param transformedFilePath - the file path for which the source map is valid.\n   *  This must *exactly* match the path stashed for the coverage object to be\n   *  useful.\n   * @param sourceMapUrl - the source map URL, **not** a comment\n   */\n\n\n  registerURL(transformedFilePath, sourceMapUrl) {\n    const d = 'data:';\n\n    if (sourceMapUrl.length > d.length && sourceMapUrl.substring(0, d.length) === d) {\n      const b64 = 'base64,';\n      const pos = sourceMapUrl.indexOf(b64);\n\n      if (pos > 0) {\n        this.data[transformedFilePath] = {\n          type: 'encoded',\n          data: sourceMapUrl.substring(pos + b64.length)\n        };\n      } else {\n        debug(\"Unable to interpret source map URL: \".concat(sourceMapUrl));\n      }\n\n      return;\n    }\n\n    const dir = path.dirname(path.resolve(transformedFilePath));\n    const file = path.resolve(dir, sourceMapUrl);\n    this.data[transformedFilePath] = {\n      type: 'file',\n      data: file\n    };\n  }\n  /**\n   * Registers a source map object with this store. Makes some basic sanity checks\n   * and silently fails on malformed input.\n   * @param transformedFilePath - the file path for which the source map is valid\n   * @param sourceMap - the source map object\n   */\n\n\n  registerMap(transformedFilePath, sourceMap) {\n    if (sourceMap && sourceMap.version) {\n      this.data[transformedFilePath] = {\n        type: 'object',\n        data: sourceMap\n      };\n    } else {\n      debug('Invalid source map object: ' + JSON.stringify(sourceMap, null, 2));\n    }\n  }\n  /**\n   * Transforms the coverage map provided into one that refers to original\n   * sources when valid mappings have been registered with this store.\n   * @param {CoverageMap} coverageMap - the coverage map to transform\n   * @returns {Object} an object with 2 properties. `map` for the transformed\n   * coverage map and `sourceFinder` which is a function to return the source\n   * text for a file.\n   */\n\n\n  transformCoverage(coverageMap) {\n    const sourceFinder = filePath => {\n      const content = this.sourceStore.getSource(filePath);\n\n      if (content !== null) {\n        return content;\n      }\n\n      if (path.isAbsolute(filePath)) {\n        return fs.readFileSync(filePath, 'utf8');\n      }\n\n      return fs.readFileSync(pathutils.asAbsolute(filePath, this.baseDir));\n    };\n\n    coverageMap.files().forEach(file => {\n      const coverage = coverageMap.fileCoverageFor(file);\n\n      if (coverage.data.inputSourceMap && !this.data[file]) {\n        this.registerMap(file, coverage.data.inputSourceMap);\n      }\n    });\n\n    if (Object.keys(this.data).length === 0) {\n      return {\n        map: coverageMap,\n        sourceFinder\n      };\n    }\n\n    const mappedCoverage = transformer.create(filePath => {\n      try {\n        if (!this.data[filePath]) {\n          return null;\n        }\n\n        const d = this.data[filePath];\n        let obj;\n\n        if (d.type === 'file') {\n          obj = JSON.parse(fs.readFileSync(d.data, 'utf8'));\n        } else if (d.type === 'encoded') {\n          obj = JSON.parse(Buffer.from(d.data, 'base64').toString());\n        } else {\n          obj = d.data;\n        }\n\n        const smc = new SMC(obj);\n        smc.sources.forEach(s => {\n          const content = smc.sourceContentFor(s);\n\n          if (content) {\n            const sourceFilePath = pathutils.relativeTo(s, filePath);\n            this.sourceStore.registerSource(sourceFilePath, content);\n          }\n        });\n        return smc;\n      } catch (error) {\n        debug('Error returning source map for ' + filePath);\n        debug(error.stack);\n        return null;\n      }\n    }).transform(coverageMap);\n    return {\n      map: mappedCoverage,\n      sourceFinder\n    };\n  }\n  /**\n   * Disposes temporary resources allocated by this map store\n   */\n\n\n  dispose() {\n    this.sourceStore.dispose();\n  }\n\n}\n\nmodule.exports = {\n  MapStore\n};","map":null,"metadata":{},"sourceType":"script"}