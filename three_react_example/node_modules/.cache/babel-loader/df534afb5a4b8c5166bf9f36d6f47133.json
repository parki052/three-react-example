{"ast":null,"code":"// Copyright 2010-2011 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\nvar sys = require('util'),\n    fs = require('fs'),\n    path = require('path'),\n    events = require('events');\n\nfunction walk(dir, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!callback.files) callback.files = {};\n  if (!callback.pending) callback.pending = 0;\n  callback.pending += 1;\n  fs.stat(dir, function (err, stat) {\n    if (err) return callback(err);\n    callback.files[dir] = stat;\n    fs.readdir(dir, function (err, files) {\n      if (err) {\n        if (err.code === 'EACCES' && options.ignoreUnreadableDir) return callback();\n        return callback(err);\n      }\n\n      callback.pending -= 1;\n      files.forEach(function (f, index) {\n        f = path.join(dir, f);\n        callback.pending += 1;\n        fs.stat(f, function (err, stat) {\n          var enoent = false,\n              done = false;\n\n          if (err) {\n            if (err.code !== 'ENOENT' && err.code !== 'EPERM' && options.ignoreNotPermitted) {\n              return callback(err);\n            } else {\n              enoent = true;\n            }\n          }\n\n          callback.pending -= 1;\n          done = callback.pending === 0;\n\n          if (!enoent) {\n            if (options.ignoreDotFiles && path.basename(f)[0] === '.') return done && callback(null, callback.files);\n            if (options.filter && !options.filter(f, stat)) return done && callback(null, callback.files);\n            callback.files[f] = stat;\n            if (stat.isDirectory() && !(options.ignoreDirectoryPattern && options.ignoreDirectoryPattern.test(f))) walk(f, options, callback);\n            done = callback.pending === 0;\n            if (done) callback(null, callback.files);\n          }\n        });\n      });\n      if (callback.pending === 0) callback(null, callback.files);\n    });\n    if (callback.pending === 0) callback(null, callback.files);\n  });\n}\n\nvar watchedFiles = Object.create(null);\n\nexports.watchTree = function (root, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  walk(root, options, function (err, files) {\n    if (err) throw err;\n\n    var fileWatcher = function (f) {\n      var fsOptions = {};\n\n      if (options.interval) {\n        fsOptions.interval = options.interval * 1000;\n      }\n\n      fs.watchFile(f, fsOptions, function (c, p) {\n        // Check if anything actually changed in stat\n        if (files[f] && !files[f].isDirectory() && c.nlink !== 0 && files[f].mtime.getTime() == c.mtime.getTime()) return;\n        files[f] = c;\n        if (!files[f].isDirectory()) callback(f, c, p);else {\n          fs.readdir(f, function (err, nfiles) {\n            if (err) return;\n            nfiles.forEach(function (b) {\n              var file = path.join(f, b);\n\n              if (!files[file] && (options.ignoreDotFiles !== true || b[0] != '.')) {\n                fs.stat(file, function (err, stat) {\n                  if (options.filter && !options.filter(file, stat)) return;\n                  callback(file, stat, null);\n                  files[file] = stat;\n                  fileWatcher(file);\n                });\n              }\n            });\n          });\n        }\n\n        if (c.nlink === 0) {\n          // unwatch removed files.\n          delete files[f];\n          fs.unwatchFile(f);\n        }\n      });\n    };\n\n    fileWatcher(root);\n\n    for (var i in files) {\n      fileWatcher(i);\n    }\n\n    watchedFiles[root] = files;\n    callback(files, null, null);\n  });\n};\n\nexports.unwatchTree = function (root) {\n  if (!watchedFiles[root]) return;\n  Object.keys(watchedFiles[root]).forEach(fs.unwatchFile);\n  watchedFiles[root] = false;\n};\n\nexports.createMonitor = function (root, options, cb) {\n  if (!cb) {\n    cb = options;\n    options = {};\n  }\n\n  var monitor = new events.EventEmitter();\n  monitor.stop = exports.unwatchTree.bind(null, root);\n  var prevFile = {\n    file: null,\n    action: null,\n    stat: null\n  };\n  exports.watchTree(root, options, function (f, curr, prev) {\n    // if not curr, prev, but f is an object\n    if (typeof f == \"object\" && prev == null && curr === null) {\n      monitor.files = f;\n      return cb(monitor);\n    } // if not prev and either prevFile.file is not f or prevFile.action is not created\n\n\n    if (!prev) {\n      if (prevFile.file != f || prevFile.action != \"created\") {\n        prevFile = {\n          file: f,\n          action: \"created\",\n          stat: curr\n        };\n        return monitor.emit(\"created\", f, curr);\n      }\n    } // if curr.nlink is 0 and either prevFile.file is not f or prevFile.action is not removed\n\n\n    if (curr) {\n      if (curr.nlink === 0) {\n        if (prevFile.file != f || prevFile.action != \"removed\") {\n          prevFile = {\n            file: f,\n            action: \"removed\",\n            stat: curr\n          };\n          return monitor.emit(\"removed\", f, curr);\n        }\n      }\n    } // if prevFile.file is null or prevFile.stat.mtime is not the same as curr.mtime\n\n\n    if (prevFile.file === null) {\n      return monitor.emit(\"changed\", f, curr, prev);\n    } // stat might return null, so catch errors\n\n\n    try {\n      if (prevFile.stat.mtime.getTime() !== curr.mtime.getTime()) {\n        return monitor.emit(\"changed\", f, curr, prev);\n      }\n    } catch (e) {\n      return monitor.emit(\"changed\", f, curr, prev);\n    }\n  });\n};\n\nexports.walk = walk;","map":null,"metadata":{},"sourceType":"script"}