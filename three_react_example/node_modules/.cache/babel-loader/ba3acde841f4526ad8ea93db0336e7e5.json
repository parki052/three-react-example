{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst EMPTY_OBJ = {};\nconst EMPTY_MAP = new Map();\n\nclass ModuleMap {\n  static mapToArrayRecursive(map) {\n    let arr = Array.from(map);\n\n    if (arr[0] && arr[0][1] instanceof Map) {\n      arr = arr.map(el => [el[0], this.mapToArrayRecursive(el[1])]);\n    }\n\n    return arr;\n  }\n\n  static mapFromArrayRecursive(arr) {\n    if (arr[0] && Array.isArray(arr[1])) {\n      arr = arr.map(el => [el[0], this.mapFromArrayRecursive(el[1])]);\n    }\n\n    return new Map(arr);\n  }\n\n  constructor(raw) {\n    _defineProperty(this, '_raw', void 0);\n\n    _defineProperty(this, 'json', void 0);\n\n    this._raw = raw;\n  }\n\n  getModule(name, platform, supportsNativePlatform, type) {\n    if (type == null) {\n      type = _constants.default.MODULE;\n    }\n\n    const module = this._getModuleMetadata(name, platform, !!supportsNativePlatform);\n\n    if (module && module[_constants.default.TYPE] === type) {\n      const modulePath = module[_constants.default.PATH];\n      return modulePath && fastPath.resolve(this._raw.rootDir, modulePath);\n    }\n\n    return null;\n  }\n\n  getPackage(name, platform, _supportsNativePlatform) {\n    return this.getModule(name, platform, null, _constants.default.PACKAGE);\n  }\n\n  getMockModule(name) {\n    const mockPath = this._raw.mocks.get(name) || this._raw.mocks.get(name + '/index');\n\n    return mockPath && fastPath.resolve(this._raw.rootDir, mockPath);\n  }\n\n  getRawModuleMap() {\n    return {\n      duplicates: this._raw.duplicates,\n      map: this._raw.map,\n      mocks: this._raw.mocks,\n      rootDir: this._raw.rootDir\n    };\n  }\n\n  toJSON() {\n    if (!this.json) {\n      this.json = {\n        duplicates: ModuleMap.mapToArrayRecursive(this._raw.duplicates),\n        map: Array.from(this._raw.map),\n        mocks: Array.from(this._raw.mocks),\n        rootDir: this._raw.rootDir\n      };\n    }\n\n    return this.json;\n  }\n\n  static fromJSON(serializableModuleMap) {\n    return new ModuleMap({\n      duplicates: ModuleMap.mapFromArrayRecursive(serializableModuleMap.duplicates),\n      map: new Map(serializableModuleMap.map),\n      mocks: new Map(serializableModuleMap.mocks),\n      rootDir: serializableModuleMap.rootDir\n    });\n  }\n  /**\n   * When looking up a module's data, we walk through each eligible platform for\n   * the query. For each platform, we want to check if there are known\n   * duplicates for that name+platform pair. The duplication logic normally\n   * removes elements from the `map` object, but we want to check upfront to be\n   * extra sure. If metadata exists both in the `duplicates` object and the\n   * `map`, this would be a bug.\n   */\n\n\n  _getModuleMetadata(name, platform, supportsNativePlatform) {\n    const map = this._raw.map.get(name) || EMPTY_OBJ;\n    const dupMap = this._raw.duplicates.get(name) || EMPTY_MAP;\n\n    if (platform != null) {\n      this._assertNoDuplicates(name, platform, supportsNativePlatform, dupMap.get(platform));\n\n      if (map[platform] != null) {\n        return map[platform];\n      }\n    }\n\n    if (supportsNativePlatform) {\n      this._assertNoDuplicates(name, _constants.default.NATIVE_PLATFORM, supportsNativePlatform, dupMap.get(_constants.default.NATIVE_PLATFORM));\n\n      if (map[_constants.default.NATIVE_PLATFORM]) {\n        return map[_constants.default.NATIVE_PLATFORM];\n      }\n    }\n\n    this._assertNoDuplicates(name, _constants.default.GENERIC_PLATFORM, supportsNativePlatform, dupMap.get(_constants.default.GENERIC_PLATFORM));\n\n    if (map[_constants.default.GENERIC_PLATFORM]) {\n      return map[_constants.default.GENERIC_PLATFORM];\n    }\n\n    return null;\n  }\n\n  _assertNoDuplicates(name, platform, supportsNativePlatform, relativePathSet) {\n    if (relativePathSet == null) {\n      return;\n    } // Force flow refinement\n\n\n    const previousSet = relativePathSet;\n    const duplicates = new Map();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = previousSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const _step$value = _slicedToArray(_step.value, 2),\n              relativePath = _step$value[0],\n              type = _step$value[1];\n\n        const duplicatePath = fastPath.resolve(this._raw.rootDir, relativePath);\n        duplicates.set(duplicatePath, type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    throw new DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, duplicates);\n  }\n\n  static create(rootDir) {\n    return new ModuleMap({\n      duplicates: new Map(),\n      map: new Map(),\n      mocks: new Map(),\n      rootDir\n    });\n  }\n\n}\n\nexports.default = ModuleMap;\n\n_defineProperty(ModuleMap, 'DuplicateHasteCandidatesError', void 0);\n\nclass DuplicateHasteCandidatesError extends Error {\n  constructor(name, platform, supportsNativePlatform, duplicatesSet) {\n    const platformMessage = getPlatformMessage(platform);\n    super(\"The name `\".concat(name, \"` was looked up in the Haste module map. It \") + \"cannot be resolved, because there exists several different \" + \"files, or packages, that provide a module for \" + \"that particular name and platform. \".concat(platformMessage, \" You must \") + \"delete or blacklist files until there remains only one of these:\\n\\n\" + Array.from(duplicatesSet).map(([dupFilePath, dupFileType]) => \"  * `\".concat(dupFilePath, \"` (\").concat(getTypeMessage(dupFileType), \")\\n\")).sort().join(''));\n\n    _defineProperty(this, 'hasteName', void 0);\n\n    _defineProperty(this, 'platform', void 0);\n\n    _defineProperty(this, 'supportsNativePlatform', void 0);\n\n    _defineProperty(this, 'duplicatesSet', void 0);\n\n    this.hasteName = name;\n    this.platform = platform;\n    this.supportsNativePlatform = supportsNativePlatform;\n    this.duplicatesSet = duplicatesSet;\n  }\n\n}\n\nfunction getPlatformMessage(platform) {\n  if (platform === _constants.default.GENERIC_PLATFORM) {\n    return 'The platform is generic (no extension).';\n  }\n\n  return \"The platform extension is `\".concat(platform, \"`.\");\n}\n\nfunction getTypeMessage(type) {\n  switch (type) {\n    case _constants.default.MODULE:\n      return 'module';\n\n    case _constants.default.PACKAGE:\n      return 'package';\n  }\n\n  return 'unknown';\n}\n\nModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;","map":null,"metadata":{},"sourceType":"script"}