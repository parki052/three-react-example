{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.deepMerge = exports.saveSnapshotFile = exports.ensureDirectoryExists = exports.escapeBacktickString = exports.unescape = exports.serialize = exports.getSnapshotData = exports.keyToTestName = exports.testNameToKey = exports.SNAPSHOT_VERSION_WARNING = exports.SNAPSHOT_GUIDE_LINK = exports.SNAPSHOT_VERSION = void 0;\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _path = _interopRequireDefault(require('path'));\n\nvar _mkdirp = _interopRequireDefault(require('mkdirp'));\n\nvar _naturalCompare = _interopRequireDefault(require('natural-compare'));\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _prettyFormat = _interopRequireDefault(require('pretty-format'));\n\nvar _plugins = require('./plugins');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestWriteFile = global[Symbol.for('jest-native-write-file')] || _fs.default.writeFileSync;\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestReadFile = global[Symbol.for('jest-native-read-file')] || _fs.default.readFileSync;\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestExistsFile = global[Symbol.for('jest-native-exists-file')] || _fs.default.existsSync;\n\nconst SNAPSHOT_VERSION = '1';\nexports.SNAPSHOT_VERSION = SNAPSHOT_VERSION;\nconst SNAPSHOT_VERSION_REGEXP = /^\\/\\/ Jest Snapshot v(.+),/;\nconst SNAPSHOT_GUIDE_LINK = 'https://goo.gl/fbAQLP';\nexports.SNAPSHOT_GUIDE_LINK = SNAPSHOT_GUIDE_LINK;\n\nconst SNAPSHOT_VERSION_WARNING = _chalk.default.yellow(\"\".concat(_chalk.default.bold('Warning'), \": Before you upgrade snapshots, \") + \"we recommend that you revert any local changes to tests or other code, \" + \"to ensure that you do not store invalid state.\");\n\nexports.SNAPSHOT_VERSION_WARNING = SNAPSHOT_VERSION_WARNING;\n\nconst writeSnapshotVersion = () => \"// Jest Snapshot v\".concat(SNAPSHOT_VERSION, \", \").concat(SNAPSHOT_GUIDE_LINK);\n\nconst validateSnapshotVersion = snapshotContents => {\n  const versionTest = SNAPSHOT_VERSION_REGEXP.exec(snapshotContents);\n  const version = versionTest && versionTest[1];\n\n  if (!version) {\n    return new Error(_chalk.default.red(\"\".concat(_chalk.default.bold('Outdated snapshot'), \": No snapshot header found. \") + \"Jest 19 introduced versioned snapshots to ensure all developers \" + \"on a project are using the same version of Jest. \" + \"Please update all snapshots during this upgrade of Jest.\\n\\n\") + SNAPSHOT_VERSION_WARNING);\n  }\n\n  if (version < SNAPSHOT_VERSION) {\n    return new Error(_chalk.default.red(\"\".concat(_chalk.default.red.bold('Outdated snapshot'), \": The version of the snapshot \") + \"file associated with this test is outdated. The snapshot file \" + \"version ensures that all developers on a project are using \" + \"the same version of Jest. \" + \"Please update all snapshots during this upgrade of Jest.\\n\\n\") + \"Expected: v\".concat(SNAPSHOT_VERSION, \"\\n\") + \"Received: v\".concat(version, \"\\n\\n\") + SNAPSHOT_VERSION_WARNING);\n  }\n\n  if (version > SNAPSHOT_VERSION) {\n    return new Error(_chalk.default.red(\"\".concat(_chalk.default.red.bold('Outdated Jest version'), \": The version of this \") + \"snapshot file indicates that this project is meant to be used \" + \"with a newer version of Jest. The snapshot file version ensures \" + \"that all developers on a project are using the same version of \" + \"Jest. Please update your version of Jest and re-run the tests.\\n\\n\") + \"Expected: v\".concat(SNAPSHOT_VERSION, \"\\n\") + \"Received: v\".concat(version));\n  }\n\n  return null;\n};\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nconst testNameToKey = (testName, count) => testName + ' ' + count;\n\nexports.testNameToKey = testNameToKey;\n\nconst keyToTestName = key => {\n  if (!/ \\d+$/.test(key)) {\n    throw new Error('Snapshot keys must end with a number.');\n  }\n\n  return key.replace(/ \\d+$/, '');\n};\n\nexports.keyToTestName = keyToTestName;\n\nconst getSnapshotData = (snapshotPath, update) => {\n  const data = Object.create(null);\n  let snapshotContents = '';\n  let dirty = false;\n\n  if (jestExistsFile(snapshotPath)) {\n    try {\n      snapshotContents = jestReadFile(snapshotPath, 'utf8'); // eslint-disable-next-line no-new-func\n\n      const populate = new Function('exports', snapshotContents);\n      populate(data);\n    } catch (e) {}\n  }\n\n  const validationResult = validateSnapshotVersion(snapshotContents);\n  const isInvalid = snapshotContents && validationResult;\n\n  if (update === 'none' && isInvalid) {\n    throw validationResult;\n  }\n\n  if ((update === 'all' || update === 'new') && isInvalid) {\n    dirty = true;\n  }\n\n  return {\n    data,\n    dirty\n  };\n}; // Extra line breaks at the beginning and at the end of the snapshot are useful\n// to make the content of the snapshot easier to read\n\n\nexports.getSnapshotData = getSnapshotData;\n\nconst addExtraLineBreaks = string => string.includes('\\n') ? \"\\n\".concat(string, \"\\n\") : string;\n\nconst serialize = data => addExtraLineBreaks(normalizeNewlines((0, _prettyFormat.default)(data, {\n  escapeRegex: true,\n  plugins: (0, _plugins.getSerializers)(),\n  printFunctionName: false\n}))); // unescape double quotes\n\n\nexports.serialize = serialize;\n\nconst unescape = data => data.replace(/\\\\(\")/g, '$1');\n\nexports.unescape = unescape;\n\nconst escapeBacktickString = str => str.replace(/`|\\\\|\\${/g, '\\\\$&');\n\nexports.escapeBacktickString = escapeBacktickString;\n\nconst printBacktickString = str => '`' + escapeBacktickString(str) + '`';\n\nconst ensureDirectoryExists = filePath => {\n  try {\n    _mkdirp.default.sync(_path.default.join(_path.default.dirname(filePath)), '777');\n  } catch (e) {}\n};\n\nexports.ensureDirectoryExists = ensureDirectoryExists;\n\nconst normalizeNewlines = string => string.replace(/\\r\\n|\\r/g, '\\n');\n\nconst saveSnapshotFile = (snapshotData, snapshotPath) => {\n  const snapshots = Object.keys(snapshotData).sort(_naturalCompare.default).map(key => 'exports[' + printBacktickString(key) + '] = ' + printBacktickString(normalizeNewlines(snapshotData[key])) + ';');\n  ensureDirectoryExists(snapshotPath);\n  jestWriteFile(snapshotPath, writeSnapshotVersion() + '\\n\\n' + snapshots.join('\\n\\n') + '\\n');\n};\n\nexports.saveSnapshotFile = saveSnapshotFile;\n\nconst deepMergeArray = (target, source) => {\n  const mergedOutput = Array.from(target);\n  source.forEach((sourceElement, index) => {\n    const targetElement = mergedOutput[index];\n\n    if (Array.isArray(target[index])) {\n      mergedOutput[index] = deepMergeArray(target[index], sourceElement);\n    } else if (isObject(targetElement)) {\n      mergedOutput[index] = deepMerge(target[index], sourceElement);\n    } else {\n      // Source does not exist in target or target is primitive and cannot be deep merged\n      mergedOutput[index] = sourceElement;\n    }\n  });\n  return mergedOutput;\n};\n\nconst deepMerge = (target, source) => {\n  const mergedOutput = _objectSpread({}, target);\n\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isObject(source[key]) && !source[key].$$typeof) {\n        if (!(key in target)) Object.assign(mergedOutput, {\n          [key]: source[key]\n        });else mergedOutput[key] = deepMerge(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        mergedOutput[key] = deepMergeArray(target[key], source[key]);\n      } else {\n        Object.assign(mergedOutput, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n\n  return mergedOutput;\n};\n\nexports.deepMerge = deepMerge;","map":null,"metadata":{},"sourceType":"script"}