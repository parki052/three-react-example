{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _CallTracker = _interopRequireDefault(require('./CallTracker'));\n\nvar _createSpy = _interopRequireDefault(require('./createSpy'));\n\nvar _SpyStrategy = _interopRequireDefault(require('./SpyStrategy'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst formatErrorMsg = (domain, usage) => {\n  const usageDefinition = usage ? '\\nUsage: ' + usage : '';\n  return msg => domain + ' : ' + msg + usageDefinition;\n};\n\nfunction isSpy(putativeSpy) {\n  if (!putativeSpy) {\n    return false;\n  }\n\n  return putativeSpy.and instanceof _SpyStrategy.default && putativeSpy.calls instanceof _CallTracker.default;\n}\n\nconst getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\n\nclass SpyRegistry {\n  constructor({\n    currentSpies = () => []\n  } = {}) {\n    _defineProperty(this, 'allowRespy', void 0);\n\n    _defineProperty(this, 'spyOn', void 0);\n\n    _defineProperty(this, 'clearSpies', void 0);\n\n    _defineProperty(this, 'respy', void 0);\n\n    _defineProperty(this, '_spyOnProperty', void 0);\n\n    this.allowRespy = function (allow) {\n      this.respy = allow;\n    };\n\n    this.spyOn = (obj, methodName, accessType) => {\n      if (accessType) {\n        return this._spyOnProperty(obj, methodName, accessType);\n      }\n\n      if (obj === void 0) {\n        throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));\n      }\n\n      if (methodName === void 0) {\n        throw new Error(getErrorMsg('No method name supplied'));\n      }\n\n      if (obj[methodName] === void 0) {\n        throw new Error(getErrorMsg(methodName + '() method does not exist'));\n      }\n\n      if (obj[methodName] && isSpy(obj[methodName])) {\n        if (this.respy) {\n          return obj[methodName];\n        } else {\n          throw new Error(getErrorMsg(methodName + ' has already been spied upon'));\n        }\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n      } catch (e) {// IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));\n      }\n\n      const originalMethod = obj[methodName];\n      const spiedMethod = (0, _createSpy.default)(methodName, originalMethod);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\n        restoreStrategy = function restoreStrategy() {\n          obj[methodName] = originalMethod;\n        };\n      } else {\n        restoreStrategy = function restoreStrategy() {\n          if (!delete obj[methodName]) {\n            obj[methodName] = originalMethod;\n          }\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n      obj[methodName] = spiedMethod;\n      return spiedMethod;\n    };\n\n    this._spyOnProperty = function (obj, propertyName, accessType = 'get') {\n      if (!obj) {\n        throw new Error(getErrorMsg('could not find an object to spy upon for ' + propertyName));\n      }\n\n      if (!propertyName) {\n        throw new Error(getErrorMsg('No property name supplied'));\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n      } catch (e) {// IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (!descriptor) {\n        throw new Error(getErrorMsg(propertyName + ' property does not exist'));\n      }\n\n      if (!descriptor.configurable) {\n        throw new Error(getErrorMsg(propertyName + ' is not declared configurable'));\n      }\n\n      if (!descriptor[accessType]) {\n        throw new Error(getErrorMsg('Property ' + propertyName + ' does not have access type ' + accessType));\n      }\n\n      if (obj[propertyName] && isSpy(obj[propertyName])) {\n        if (this.respy) {\n          return obj[propertyName];\n        } else {\n          throw new Error(getErrorMsg(propertyName + ' has already been spied upon'));\n        }\n      }\n\n      const originalDescriptor = descriptor;\n      const spiedProperty = (0, _createSpy.default)(propertyName, descriptor[accessType]);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {\n        restoreStrategy = function restoreStrategy() {\n          Object.defineProperty(obj, propertyName, originalDescriptor);\n        };\n      } else {\n        restoreStrategy = function restoreStrategy() {\n          delete obj[propertyName];\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n\n      const spiedDescriptor = _objectSpread({}, descriptor, {\n        [accessType]: spiedProperty\n      });\n\n      Object.defineProperty(obj, propertyName, spiedDescriptor);\n      return spiedProperty;\n    };\n\n    this.clearSpies = function () {\n      const spies = currentSpies();\n\n      for (let i = spies.length - 1; i >= 0; i--) {\n        const spyEntry = spies[i];\n        spyEntry.restoreObjectToOriginalState();\n      }\n    };\n  }\n\n}\n\nexports.default = SpyRegistry;","map":null,"metadata":{},"sourceType":"script"}