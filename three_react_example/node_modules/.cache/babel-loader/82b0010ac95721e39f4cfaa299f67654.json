{"ast":null,"code":"var net = require('net'),\n    crypto = require('crypto'),\n    format = require('util').format,\n    fs = require('fs');\n\nvar nl = '\\r\\n';\n/**\n * Create a new GNTP request of the given `type`.\n *\n * @param {String} type either NOTIFY or REGISTER\n * @api private\n */\n\nfunction GNTP(type, opts) {\n  opts = opts || {};\n  this.type = type;\n  this.host = opts.host || 'localhost';\n  this.port = opts.port || 23053;\n  this.request = 'GNTP/1.0 ' + type + ' NONE' + nl;\n  this.resources = [];\n  this.attempts = 0;\n  this.maxAttempts = 5;\n}\n/**\n * Build a response object from the given `resp` response string.\n *\n * The response object has a key/value pair for every header in the response, and \n * a `.state` property equal to either OK, ERROR, or CALLBACK.\n *\n * An example GNTP response:\n *\n *     GNTP/1.0 -OK NONE\\r\\n\n *     Response-Action: REGISTER\\r\\n\n *     \\r\\n\n *\n *  Which would parse to:\n *      \n *      { state: 'OK', 'Response-Action': 'REGISTER' }\n *\n * @param {String} resp\n * @return {Object}\n * @api private\n */\n\n\nGNTP.prototype.parseResp = function (resp) {\n  var parsed = {},\n      head,\n      body;\n  resp = resp.slice(0, resp.indexOf(nl + nl)).split(nl);\n  head = resp[0];\n  body = resp.slice(1);\n  parsed.state = head.match(/-(OK|ERROR|CALLBACK)/)[0].slice(1);\n  body.forEach(function (ln) {\n    ln = ln.split(': ');\n    parsed[ln[0]] = ln[1];\n  });\n  return parsed;\n};\n/**\n * Call `GNTP.send()` with the given arguments after a certain delay.\n *\n * @api private\n */\n\n\nGNTP.prototype.retry = function () {\n  var self = this,\n      args = arguments;\n  setTimeout(function () {\n    self.send.apply(self, args);\n  }, 750);\n};\n/**\n * Add a resource to the GNTP request.\n *\n * @param {Buffer} file\n * @return {String}\n * @api private\n */\n\n\nGNTP.prototype.addResource = function (file) {\n  var id = crypto.createHash('md5').update(file).digest('hex'),\n      header = 'Identifier: ' + id + nl + 'Length: ' + file.length + nl + nl;\n  this.resources.push({\n    header: header,\n    file: file\n  });\n  return 'x-growl-resource://' + id;\n};\n/**\n * Append another header `name` with a value of `val` to the request. If `val` is\n * undefined, the header will be left out.\n *\n * @param {String} name\n * @param {String} val\n * @api public\n */\n\n\nGNTP.prototype.add = function (name, val) {\n  if (val === undefined) return;\n  /* Handle icon files when they're image paths or Buffers. */\n\n  if (/-Icon/.test(name) && !/^https?:\\/\\//.test(val)) {\n    if (/\\.(png|gif|jpe?g)$/.test(val)) val = this.addResource(fs.readFileSync(val));else if (val instanceof Buffer) val = this.addResource(val);\n  }\n\n  this.request += name + ': ' + val + nl;\n};\n/**\n * Append a newline to the request.\n *\n * @api public\n */\n\n\nGNTP.prototype.newline = function () {\n  this.request += nl;\n};\n/**\n * Send the GNTP request, calling `callback` after successfully sending the \n * request.\n *\n * An example GNTP request:\n *\n *     GNTP/1.0 REGISTER NONE\\r\\n\n *     Application-Name: Growly.js\\r\\n\n *     Notifications-Count: 1\\r\\n\n *     \\r\\n\n *     Notification-Name: default\\r\\n\n *     Notification-Display-Name: Default Notification\\r\\n\n *     Notification-Enabled: True\\r\\n\n *     \\r\\n\n * \n * @param {Function} callback which will be passed the parsed response\n * @api public\n */\n\n\nGNTP.prototype.send = function (callback) {\n  var self = this,\n      socket = net.connect(this.port, this.host),\n      resp = '';\n\n  callback = callback || function () {};\n\n  this.attempts += 1;\n  socket.on('connect', function () {\n    socket.write(self.request);\n    self.resources.forEach(function (res) {\n      socket.write(res.header);\n      socket.write(res.file);\n      socket.write(nl + nl);\n    });\n  });\n  socket.on('data', function (data) {\n    resp += data.toString();\n    /* Wait until we have a complete response which is signaled by two CRLF's. */\n\n    if (resp.slice(resp.length - 4) !== nl + nl) return;\n    resp = self.parseResp(resp);\n    /* We have to manually close the connection for certain responses; otherwise,\n       reset `resp` to prepare for the next response chunk.  */\n\n    if (resp.state === 'ERROR' || resp.state === 'CALLBACK') socket.end();else resp = '';\n  });\n  socket.on('end', function () {\n    /* Retry on 200 (timed out), 401 (unknown app), or 402 (unknown notification). */\n    if (['200', '401', '402'].indexOf(resp['Error-Code']) >= 0) {\n      if (self.attempts <= self.maxAttempts) {\n        self.retry(callback);\n      } else {\n        var msg = 'GNTP request to \"%s:%d\" failed with error code %s (%s)';\n        callback(new Error(format(msg, self.host, self.port, resp['Error-Code'], resp['Error-Description'])));\n      }\n    } else {\n      callback(undefined, resp);\n    }\n  });\n  socket.on('error', function () {\n    callback(new Error(format('Error while sending GNTP request to \"%s:%d\"', self.host, self.port)));\n    socket.destroy();\n  });\n};\n\nmodule.exports = GNTP;","map":null,"metadata":{},"sourceType":"script"}