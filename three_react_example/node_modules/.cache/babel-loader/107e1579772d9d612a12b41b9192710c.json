{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst watch = require('@cnakazawa/watch');\n\nconst common = require('./common');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Constants\n */\n\n\nconst DEFAULT_DELAY = common.DEFAULT_DELAY;\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\n/**\n * Export `PollWatcher` class.\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nmodule.exports = class PollWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n    opts = common.assignOptions(this, opts);\n    this.watched = Object.create(null);\n    this.root = path.resolve(dir);\n    watch.createMonitor(this.root, {\n      interval: (opts.interval || DEFAULT_DELAY) / 1000,\n      filter: this.filter.bind(this)\n    }, this.init.bind(this));\n  }\n  /**\n   * Given a fullpath of a file or directory check if we need to watch it.\n   *\n   * @param {string} filepath\n   * @param {object} stat\n   * @private\n   */\n\n\n  filter(filepath, stat) {\n    return stat.isDirectory() || common.isFileIncluded(this.globs, this.dot, this.doIgnore, path.relative(this.root, filepath));\n  }\n  /**\n   * Initiate the polling file watcher with the event emitter passed from\n   * `watch.watchTree`.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n\n\n  init(monitor) {\n    this.watched = monitor.files;\n    monitor.on('changed', this.emitEvent.bind(this, CHANGE_EVENT));\n    monitor.on('removed', this.emitEvent.bind(this, DELETE_EVENT));\n    monitor.on('created', this.emitEvent.bind(this, ADD_EVENT)); // 1 second wait because mtime is second-based.\n\n    setTimeout(this.emit.bind(this, 'ready'), 1000);\n  }\n  /**\n   * Transform and emit an event comming from the poller.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n\n\n  emitEvent(type, file, stat) {\n    file = path.relative(this.root, file);\n\n    if (type === DELETE_EVENT) {\n      // Matching the non-polling API\n      stat = null;\n    }\n\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n  /**\n   * End watching.\n   *\n   * @public\n   */\n\n\n  close(callback) {\n    Object.keys(this.watched).forEach(filepath => fs.unwatchFile(filepath));\n    this.removeAllListeners();\n\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}