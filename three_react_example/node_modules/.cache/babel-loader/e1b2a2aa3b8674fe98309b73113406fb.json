{"ast":null,"code":"'use strict';\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// Only used for types\n// eslint-disable-next-line\n// eslint-disable-next-line\n\nconst invariant = (condition, message) => {\n  if (!condition) {\n    throw new Error('babel-plugin-jest-hoist: ' + message);\n  }\n}; // We allow `jest`, `expect`, `require`, all default Node.js globals and all\n// ES2015 built-ins to be used inside of a `jest.mock` factory.\n// We also allow variables prefixed with `mock` as an escape-hatch.\n\n\nconst WHITELISTED_IDENTIFIERS = new Set(['Array', 'ArrayBuffer', 'Boolean', 'DataView', 'Date', 'Error', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'Generator', 'GeneratorFunction', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'InternalError', 'Intl', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'Promise', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'SyntaxError', 'TypeError', 'URIError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'WeakMap', 'WeakSet', 'arguments', 'console', 'expect', 'isNaN', 'jest', 'parseFloat', 'parseInt', 'require', 'undefined']);\nObject.getOwnPropertyNames(global).forEach(name => {\n  WHITELISTED_IDENTIFIERS.add(name);\n});\nconst JEST_GLOBAL = {\n  name: 'jest'\n}; // TODO: Should be Visitor<{ids: Set<NodePath<Identifier>>}>, but `ReferencedIdentifier` doesn't exist\n\nconst IDVisitor = {\n  ReferencedIdentifier(path) {\n    // @ts-ignore: passed as Visitor State\n    this.ids.add(path);\n  },\n\n  blacklist: ['TypeAnnotation', 'TSTypeAnnotation', 'TSTypeReference']\n};\nconst FUNCTIONS = Object.create(null);\n\nFUNCTIONS.mock = args => {\n  if (args.length === 1) {\n    return args[0].isStringLiteral() || args[0].isLiteral();\n  } else if (args.length === 2 || args.length === 3) {\n    const moduleFactory = args[1];\n    invariant(moduleFactory.isFunction(), 'The second argument of `jest.mock` must be an inline function.');\n    const ids = new Set();\n    const parentScope = moduleFactory.parentPath.scope; // @ts-ignore: Same as above: ReferencedIdentifier doesn't exist\n\n    moduleFactory.traverse(IDVisitor, {\n      ids\n    });\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = ids[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const id = _step.value;\n        const name = id.node.name;\n        let found = false;\n        let scope = id.scope;\n\n        while (scope !== parentScope) {\n          if (scope.bindings[name]) {\n            found = true;\n            break;\n          }\n\n          scope = scope.parent;\n        }\n\n        if (!found) {\n          invariant(scope.hasGlobal(name) && WHITELISTED_IDENTIFIERS.has(name) || /^mock/i.test(name) || // Allow istanbul's coverage variable to pass.\n          /^(?:__)?cov/.test(name), 'The module factory of `jest.mock()` is not allowed to ' + 'reference any out-of-scope variables.\\n' + 'Invalid variable access: ' + name + '\\n' + 'Whitelisted objects: ' + Array.from(WHITELISTED_IDENTIFIERS).join(', ') + '.\\n' + 'Note: This is a precaution to guard against uninitialized mock ' + 'variables. If it is ensured that the mock is required lazily, ' + 'variable names prefixed with `mock` (case insensitive) are permitted.');\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nFUNCTIONS.unmock = args => args.length === 1 && args[0].isStringLiteral();\n\nFUNCTIONS.deepUnmock = args => args.length === 1 && args[0].isStringLiteral();\n\nFUNCTIONS.disableAutomock = FUNCTIONS.enableAutomock = args => args.length === 0;\n\nmodule.exports = () => {\n  const shouldHoistExpression = expr => {\n    if (!expr.isCallExpression()) {\n      return false;\n    }\n\n    const callee = expr.get('callee');\n    const expressionArguments = expr.get('arguments'); // TODO: avoid type casts - the types can be arrays (is it possible to ignore that without casting?)\n\n    const object = callee.get('object');\n    const property = callee.get('property');\n    return property.isIdentifier() && FUNCTIONS[property.node.name] && (object.isIdentifier(JEST_GLOBAL) || callee.isMemberExpression() && shouldHoistExpression(object)) && FUNCTIONS[property.node.name](expressionArguments);\n  };\n\n  const visitor = {\n    ExpressionStatement(path) {\n      if (shouldHoistExpression(path.get('expression'))) {\n        // @ts-ignore: private, magical property\n        path.node._blockHoist = Infinity;\n      }\n    }\n\n  };\n  return {\n    visitor\n  };\n};","map":null,"metadata":{},"sourceType":"script"}