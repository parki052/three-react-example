{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst debug = require('debug')('istanbuljs');\n\nconst libCoverage = require('istanbul-lib-coverage');\n\nconst _require = require('./mapped'),\n      MappedCoverage = _require.MappedCoverage;\n\nconst getMapping = require('./get-mapping');\n\nconst _require2 = require('./transform-utils'),\n      getUniqueKey = _require2.getUniqueKey,\n      getOutput = _require2.getOutput;\n\nclass SourceMapTransformer {\n  constructor(finder, opts = {}) {\n    this.finder = finder;\n    this.baseDir = opts.baseDir || process.cwd();\n  }\n\n  processFile(fc, sourceMap, coverageMapper) {\n    let changes = 0;\n    Object.keys(fc.statementMap).forEach(s => {\n      const loc = fc.statementMap[s];\n      const hits = fc.s[s];\n      const mapping = getMapping(sourceMap, loc, fc.path);\n\n      if (mapping) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(mapping.source);\n        mappedCoverage.addStatement(mapping.loc, hits);\n      }\n    });\n    Object.keys(fc.fnMap).forEach(f => {\n      const fnMeta = fc.fnMap[f];\n      const hits = fc.f[f];\n      const mapping = getMapping(sourceMap, fnMeta.decl, fc.path);\n      const spanMapping = getMapping(sourceMap, fnMeta.loc, fc.path);\n\n      if (mapping && spanMapping && mapping.source === spanMapping.source) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(mapping.source);\n        mappedCoverage.addFunction(fnMeta.name, mapping.loc, spanMapping.loc, hits);\n      }\n    });\n    Object.keys(fc.branchMap).forEach(b => {\n      const branchMeta = fc.branchMap[b];\n      const hits = fc.b[b];\n      const locs = [];\n      const mappedHits = [];\n      let source;\n      let skip;\n      branchMeta.locations.forEach((loc, i) => {\n        const mapping = getMapping(sourceMap, loc, fc.path);\n\n        if (mapping) {\n          if (!source) {\n            source = mapping.source;\n          }\n\n          if (mapping.source !== source) {\n            skip = true;\n          }\n\n          locs.push(mapping.loc);\n          mappedHits.push(hits[i]);\n        }\n      });\n\n      if (!skip && locs.length > 0) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(source);\n        mappedCoverage.addBranch(branchMeta.type, locs[0]\n        /* XXX */\n        , locs, mappedHits);\n      }\n    });\n    return changes > 0;\n  }\n\n  transform(coverageMap) {\n    const uniqueFiles = {};\n\n    const getMappedCoverage = file => {\n      const key = getUniqueKey(file);\n\n      if (!uniqueFiles[key]) {\n        uniqueFiles[key] = {\n          file,\n          mappedCoverage: new MappedCoverage(file)\n        };\n      }\n\n      return uniqueFiles[key].mappedCoverage;\n    };\n\n    coverageMap.files().forEach(file => {\n      const fc = coverageMap.fileCoverageFor(file);\n      const sourceMap = this.finder(file);\n\n      if (!sourceMap) {\n        uniqueFiles[getUniqueKey(file)] = {\n          file,\n          mappedCoverage: fc\n        };\n        return;\n      }\n\n      const changed = this.processFile(fc, sourceMap, getMappedCoverage);\n\n      if (!changed) {\n        debug(\"File [\".concat(file, \"] ignored, nothing could be mapped\"));\n      }\n    });\n    return libCoverage.createCoverageMap(getOutput(uniqueFiles));\n  }\n\n}\n\nmodule.exports = {\n  create(finder, opts) {\n    return new SourceMapTransformer(finder, opts);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}