{"ast":null,"code":"'use strict';\n\nconst argsert = require('./lib/argsert');\n\nconst fs = require('fs');\n\nconst Command = require('./lib/command');\n\nconst Completion = require('./lib/completion');\n\nconst Parser = require('yargs-parser');\n\nconst path = require('path');\n\nconst Usage = require('./lib/usage');\n\nconst Validation = require('./lib/validation');\n\nconst Y18n = require('y18n');\n\nconst objFilter = require('./lib/obj-filter');\n\nconst setBlocking = require('set-blocking');\n\nconst applyExtends = require('./lib/apply-extends');\n\nconst _require = require('./lib/middleware'),\n      globalMiddlewareFactory = _require.globalMiddlewareFactory;\n\nconst YError = require('./lib/yerror');\n\nexports = module.exports = Yargs;\n\nfunction Yargs(processArgs, cwd, parentRequire) {\n  processArgs = processArgs || []; // handle calling yargs().\n\n  const self = {};\n  let command = null;\n  let completion = null;\n  let groups = {};\n  let globalMiddleware = [];\n  let output = '';\n  let preservedGroups = {};\n  let usage = null;\n  let validation = null;\n  const y18n = Y18n({\n    directory: path.resolve(__dirname, './locales'),\n    updateFiles: false\n  });\n  self.middleware = globalMiddlewareFactory(globalMiddleware, self);\n  if (!cwd) cwd = process.cwd();\n\n  self.scriptName = function scriptName(scriptName) {\n    self.$0 = scriptName;\n    return self;\n  }; // ignore the node bin, specify this in your\n  // bin file with #!/usr/bin/env node\n\n\n  if (/\\b(node|iojs|electron)(\\.exe)?$/.test(process.argv[0])) {\n    self.$0 = process.argv.slice(1, 2);\n  } else {\n    self.$0 = process.argv.slice(0, 1);\n  }\n\n  self.$0 = self.$0.map((x, i) => {\n    const b = rebase(cwd, x);\n    return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n  }).join(' ').trim();\n\n  if (process.env._ !== undefined && process.argv[1] === process.env._) {\n    self.$0 = process.env._.replace(\"\".concat(path.dirname(process.execPath), \"/\"), '');\n  } // use context object to keep track of resets, subcommand execution, etc\n  // submodules should modify and check the state of context as necessary\n\n\n  const context = {\n    resets: -1,\n    commands: [],\n    fullCommands: [],\n    files: []\n  };\n\n  self.getContext = () => context; // puts yargs back into an initial state. any keys\n  // that have been set to \"global\" will not be reset\n  // by this action.\n\n\n  let options;\n\n  self.resetOptions = self.reset = function resetOptions(aliases) {\n    context.resets++;\n    aliases = aliases || {};\n    options = options || {}; // put yargs back into an initial state, this\n    // logic is used to build a nested command\n    // hierarchy.\n\n    const tmpOptions = {};\n    tmpOptions.local = options.local ? options.local : [];\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : []; // if a key has been explicitly set as local,\n    // we should reset it before passing options to command.\n\n    const localLookup = {};\n    tmpOptions.local.forEach(l => {\n      localLookup[l] = true;\n      (aliases[l] || []).forEach(a => {\n        localLookup[a] = true;\n      });\n    }); // preserve all groups not set to local.\n\n    preservedGroups = Object.keys(groups).reduce((acc, groupName) => {\n      const keys = groups[groupName].filter(key => !(key in localLookup));\n\n      if (keys.length > 0) {\n        acc[groupName] = keys;\n      }\n\n      return acc;\n    }, {}); // groups can now be reset\n\n    groups = {};\n    const arrayOptions = ['array', 'boolean', 'string', 'skipValidation', 'count', 'normalize', 'number', 'hiddenOptions'];\n    const objectOptions = ['narg', 'key', 'alias', 'default', 'defaultDescription', 'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce'];\n    arrayOptions.forEach(k => {\n      tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k]);\n    });\n    objectOptions.forEach(k => {\n      tmpOptions[k] = objFilter(options[k], (k, v) => !localLookup[k]);\n    });\n    tmpOptions.envPrefix = options.envPrefix;\n    options = tmpOptions; // if this is the first time being executed, create\n    // instances of all our helpers -- otherwise just reset.\n\n    usage = usage ? usage.reset(localLookup) : Usage(self, y18n);\n    validation = validation ? validation.reset(localLookup) : Validation(self, usage, y18n);\n    command = command ? command.reset() : Command(self, usage, validation, globalMiddleware);\n    if (!completion) completion = Completion(self, usage, command);\n    completionCommand = null;\n    output = '';\n    exitError = null;\n    hasOutput = false;\n    self.parsed = false;\n    return self;\n  };\n\n  self.resetOptions(); // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n\n  let frozen;\n\n  function freeze() {\n    frozen = {};\n    frozen.options = options;\n    frozen.configObjects = options.configObjects.slice(0);\n    frozen.exitProcess = exitProcess;\n    frozen.groups = groups;\n    usage.freeze();\n    validation.freeze();\n    command.freeze();\n    frozen.strict = strict;\n    frozen.completionCommand = completionCommand;\n    frozen.output = output;\n    frozen.exitError = exitError;\n    frozen.hasOutput = hasOutput;\n    frozen.parsed = self.parsed;\n  }\n\n  function unfreeze() {\n    options = frozen.options;\n    options.configObjects = frozen.configObjects;\n    exitProcess = frozen.exitProcess;\n    groups = frozen.groups;\n    output = frozen.output;\n    exitError = frozen.exitError;\n    hasOutput = frozen.hasOutput;\n    self.parsed = frozen.parsed;\n    usage.unfreeze();\n    validation.unfreeze();\n    command.unfreeze();\n    strict = frozen.strict;\n    completionCommand = frozen.completionCommand;\n    parseFn = null;\n    parseContext = null;\n    frozen = undefined;\n  }\n\n  self.boolean = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('boolean', keys);\n    return self;\n  };\n\n  self.array = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('array', keys);\n    return self;\n  };\n\n  self.number = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('number', keys);\n    return self;\n  };\n\n  self.normalize = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('normalize', keys);\n    return self;\n  };\n\n  self.count = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('count', keys);\n    return self;\n  };\n\n  self.string = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('string', keys);\n    return self;\n  };\n\n  self.requiresArg = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintObject(self.nargs, false, 'narg', keys, 1);\n    return self;\n  };\n\n  self.skipValidation = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('skipValidation', keys);\n    return self;\n  };\n\n  function populateParserHintArray(type, keys, value) {\n    keys = [].concat(keys);\n    keys.forEach(key => {\n      options[type].push(key);\n    });\n  }\n\n  self.nargs = function (key, value) {\n    argsert('<string|object|array> [number]', [key, value], arguments.length);\n    populateParserHintObject(self.nargs, false, 'narg', key, value);\n    return self;\n  };\n\n  self.choices = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintObject(self.choices, true, 'choices', key, value);\n    return self;\n  };\n\n  self.alias = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintObject(self.alias, true, 'alias', key, value);\n    return self;\n  }; // TODO: actually deprecate self.defaults.\n\n\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n    if (defaultDescription) options.defaultDescription[key] = defaultDescription;\n\n    if (typeof value === 'function') {\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value);\n      value = value.call();\n    }\n\n    populateParserHintObject(self.default, false, 'default', key, value);\n    return self;\n  };\n\n  self.describe = function (key, desc) {\n    argsert('<object|string|array> [string]', [key, desc], arguments.length);\n    populateParserHintObject(self.describe, false, 'key', key, true);\n    usage.describe(key, desc);\n    return self;\n  };\n\n  self.demandOption = function (keys, msg) {\n    argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n    populateParserHintObject(self.demandOption, false, 'demandedOptions', keys, msg);\n    return self;\n  };\n\n  self.coerce = function (keys, value) {\n    argsert('<object|string|array> [function]', [keys, value], arguments.length);\n    populateParserHintObject(self.coerce, false, 'coerce', keys, value);\n    return self;\n  };\n\n  function populateParserHintObject(builder, isArray, type, key, value) {\n    if (Array.isArray(key)) {\n      // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n      const temp = {};\n      key.forEach(k => {\n        temp[k] = value;\n      });\n      builder(temp);\n    } else if (typeof key === 'object') {\n      // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n      Object.keys(key).forEach(k => {\n        builder(k, key[k]);\n      });\n    } else {\n      // a single key value pair 'x', parse() {}\n      if (isArray) {\n        options[type][key] = (options[type][key] || []).concat(value);\n      } else {\n        options[type][key] = value;\n      }\n    }\n  }\n\n  function deleteFromParserHintObject(optionKey) {\n    // delete from all parsing hints:\n    // boolean, array, key, alias, etc.\n    Object.keys(options).forEach(hintKey => {\n      const hint = options[hintKey];\n\n      if (Array.isArray(hint)) {\n        if (~hint.indexOf(optionKey)) hint.splice(hint.indexOf(optionKey), 1);\n      } else if (typeof hint === 'object') {\n        delete hint[optionKey];\n      }\n    }); // now delete the description from usage.js.\n\n    delete usage.getDescriptions()[optionKey];\n  }\n\n  self.config = function config(key, msg, parseFn) {\n    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length); // allow a config object to be provided directly.\n\n    if (typeof key === 'object') {\n      key = applyExtends(key, cwd);\n      options.configObjects = (options.configObjects || []).concat(key);\n      return self;\n    } // allow for a custom parsing function.\n\n\n    if (typeof msg === 'function') {\n      parseFn = msg;\n      msg = null;\n    }\n\n    key = key || 'config';\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n    (Array.isArray(key) ? key : [key]).forEach(k => {\n      options.config[k] = parseFn || true;\n    });\n    return self;\n  };\n\n  self.example = function (cmd, description) {\n    argsert('<string> [string]', [cmd, description], arguments.length);\n    usage.example(cmd, description);\n    return self;\n  };\n\n  self.command = function (cmd, description, builder, handler, middlewares) {\n    argsert('<string|array|object> [string|boolean] [function|object] [function] [array]', [cmd, description, builder, handler, middlewares], arguments.length);\n    command.addHandler(cmd, description, builder, handler, middlewares);\n    return self;\n  };\n\n  self.commandDir = function (dir, opts) {\n    argsert('<string> [object]', [dir, opts], arguments.length);\n    const req = parentRequire || require;\n    command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts);\n    return self;\n  }; // TODO: deprecate self.demand in favor of\n  // .demandCommand() .demandOption().\n\n\n  self.demand = self.required = self.require = function demand(keys, max, msg) {\n    // you can optionally provide a 'max' key,\n    // which will raise an exception if too many '_'\n    // options are provided.\n    if (Array.isArray(max)) {\n      max.forEach(key => {\n        self.demandOption(key, msg);\n      });\n      max = Infinity;\n    } else if (typeof max !== 'number') {\n      msg = max;\n      max = Infinity;\n    }\n\n    if (typeof keys === 'number') {\n      self.demandCommand(keys, max, msg, msg);\n    } else if (Array.isArray(keys)) {\n      keys.forEach(key => {\n        self.demandOption(key, msg);\n      });\n    } else {\n      if (typeof msg === 'string') {\n        self.demandOption(keys, msg);\n      } else if (msg === true || typeof msg === 'undefined') {\n        self.demandOption(keys);\n      }\n    }\n\n    return self;\n  };\n\n  self.demandCommand = function demandCommand(min, max, minMsg, maxMsg) {\n    argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n    if (typeof min === 'undefined') min = 1;\n\n    if (typeof max !== 'number') {\n      minMsg = max;\n      max = Infinity;\n    }\n\n    self.global('_', false);\n    options.demandedCommands._ = {\n      min,\n      max,\n      minMsg,\n      maxMsg\n    };\n    return self;\n  };\n\n  self.getDemandedOptions = () => {\n    argsert([], 0);\n    return options.demandedOptions;\n  };\n\n  self.getDemandedCommands = () => {\n    argsert([], 0);\n    return options.demandedCommands;\n  };\n\n  self.implies = function (key, value) {\n    argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n    validation.implies(key, value);\n    return self;\n  };\n\n  self.conflicts = function (key1, key2) {\n    argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n    validation.conflicts(key1, key2);\n    return self;\n  };\n\n  self.usage = function (msg, description, builder, handler) {\n    argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n\n    if (description !== undefined) {\n      // .usage() can be used as an alias for defining\n      // a default command.\n      if ((msg || '').match(/^\\$0( |$)/)) {\n        return self.command(msg, description, builder, handler);\n      } else {\n        throw new YError('.usage() description must start with $0 if being used as alias for .command()');\n      }\n    } else {\n      usage.usage(msg);\n      return self;\n    }\n  };\n\n  self.epilogue = self.epilog = function (msg) {\n    argsert('<string>', [msg], arguments.length);\n    usage.epilog(msg);\n    return self;\n  };\n\n  self.fail = function (f) {\n    argsert('<function>', [f], arguments.length);\n    usage.failFn(f);\n    return self;\n  };\n\n  self.check = function (f, _global) {\n    argsert('<function> [boolean]', [f, _global], arguments.length);\n    validation.check(f, _global !== false);\n    return self;\n  };\n\n  self.global = function global(globals, global) {\n    argsert('<string|array> [boolean]', [globals, global], arguments.length);\n    globals = [].concat(globals);\n\n    if (global !== false) {\n      options.local = options.local.filter(l => globals.indexOf(l) === -1);\n    } else {\n      globals.forEach(g => {\n        if (options.local.indexOf(g) === -1) options.local.push(g);\n      });\n    }\n\n    return self;\n  };\n\n  self.pkgConf = function pkgConf(key, rootPath) {\n    argsert('<string> [string]', [key, rootPath], arguments.length);\n    let conf = null; // prefer cwd to require-main-filename in this method\n    // since we're looking for e.g. \"nyc\" config in nyc consumer\n    // rather than \"yargs\" config in nyc (where nyc is the main filename)\n\n    const obj = pkgUp(rootPath || cwd); // If an object exists in the key, add it to options.configObjects\n\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = applyExtends(obj[key], rootPath || cwd);\n      options.configObjects = (options.configObjects || []).concat(conf);\n    }\n\n    return self;\n  };\n\n  const pkgs = {};\n\n  function pkgUp(rootPath) {\n    const npath = rootPath || '*';\n    if (pkgs[npath]) return pkgs[npath];\n\n    const findUp = require('find-up');\n\n    let obj = {};\n\n    try {\n      let startDir = rootPath || require('require-main-filename')(parentRequire || require); // When called in an environment that lacks require.main.filename, such as a jest test runner,\n      // startDir is already process.cwd(), and should not be shortened.\n      // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.\n\n\n      if (!rootPath && path.extname(startDir)) {\n        startDir = path.dirname(startDir);\n      }\n\n      const pkgJsonPath = findUp.sync('package.json', {\n        cwd: startDir\n      });\n      obj = JSON.parse(fs.readFileSync(pkgJsonPath));\n    } catch (noop) {}\n\n    pkgs[npath] = obj || {};\n    return pkgs[npath];\n  }\n\n  let parseFn = null;\n  let parseContext = null;\n\n  self.parse = function parse(args, shortCircuit, _parseFn) {\n    argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n\n    if (typeof args === 'undefined') {\n      return self._parseArgs(processArgs);\n    } // a context object can optionally be provided, this allows\n    // additional information to be passed to a command handler.\n\n\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit;\n      shortCircuit = _parseFn;\n    } // by providing a function as a second argument to\n    // parse you can capture output that would otherwise\n    // default to printing to stdout/stderr.\n\n\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit;\n      shortCircuit = null;\n    } // completion short-circuits the parsing process,\n    // skipping validation, etc.\n\n\n    if (!shortCircuit) processArgs = args;\n    freeze();\n    if (parseFn) exitProcess = false;\n\n    const parsed = self._parseArgs(args, shortCircuit);\n\n    if (parseFn) parseFn(exitError, parsed, output);\n    unfreeze();\n    return parsed;\n  };\n\n  self._getParseContext = () => parseContext || {};\n\n  self._hasParseCallback = () => !!parseFn;\n\n  self.option = self.options = function option(key, opt) {\n    argsert('<string|object> [object]', [key, opt], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.options(k, key[k]);\n      });\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {};\n      }\n\n      options.key[key] = true; // track manually set keys.\n\n      if (opt.alias) self.alias(key, opt.alias);\n      const demand = opt.demand || opt.required || opt.require; // deprecated, use 'demandOption' instead\n\n      if (demand) {\n        self.demand(key, demand);\n      }\n\n      if (opt.demandOption) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n      }\n\n      if ('conflicts' in opt) {\n        self.conflicts(key, opt.conflicts);\n      }\n\n      if ('default' in opt) {\n        self.default(key, opt.default);\n      }\n\n      if ('implies' in opt) {\n        self.implies(key, opt.implies);\n      }\n\n      if ('nargs' in opt) {\n        self.nargs(key, opt.nargs);\n      }\n\n      if (opt.config) {\n        self.config(key, opt.configParser);\n      }\n\n      if (opt.normalize) {\n        self.normalize(key);\n      }\n\n      if ('choices' in opt) {\n        self.choices(key, opt.choices);\n      }\n\n      if ('coerce' in opt) {\n        self.coerce(key, opt.coerce);\n      }\n\n      if ('group' in opt) {\n        self.group(key, opt.group);\n      }\n\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key);\n        if (opt.alias) self.boolean(opt.alias);\n      }\n\n      if (opt.array || opt.type === 'array') {\n        self.array(key);\n        if (opt.alias) self.array(opt.alias);\n      }\n\n      if (opt.number || opt.type === 'number') {\n        self.number(key);\n        if (opt.alias) self.number(opt.alias);\n      }\n\n      if (opt.string || opt.type === 'string') {\n        self.string(key);\n        if (opt.alias) self.string(opt.alias);\n      }\n\n      if (opt.count || opt.type === 'count') {\n        self.count(key);\n      }\n\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global);\n      }\n\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription;\n      }\n\n      if (opt.skipValidation) {\n        self.skipValidation(key);\n      }\n\n      const desc = opt.describe || opt.description || opt.desc;\n      self.describe(key, desc);\n\n      if (opt.hidden) {\n        self.hide(key);\n      }\n\n      if (opt.requiresArg) {\n        self.requiresArg(key);\n      }\n    }\n\n    return self;\n  };\n\n  self.getOptions = () => options;\n\n  self.positional = function (key, opts) {\n    argsert('<string> <object>', [key, opts], arguments.length);\n\n    if (context.resets === 0) {\n      throw new YError(\".positional() can only be called in a command's builder function\");\n    } // .positional() only supports a subset of the configuration\n    // options available to .option().\n\n\n    const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize', 'choices', 'conflicts', 'coerce', 'type', 'describe', 'desc', 'description', 'alias'];\n    opts = objFilter(opts, (k, v) => {\n      let accept = supportedOpts.indexOf(k) !== -1; // type can be one of string|number|boolean.\n\n      if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1) accept = false;\n      return accept;\n    }); // copy over any settings that can be inferred from the command string.\n\n    const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n    const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\n      array: [],\n      alias: {},\n      default: {},\n      demand: {}\n    };\n    Object.keys(parseOptions).forEach(pk => {\n      if (Array.isArray(parseOptions[pk])) {\n        if (parseOptions[pk].indexOf(key) !== -1) opts[pk] = true;\n      } else {\n        if (parseOptions[pk][key] && !(pk in opts)) opts[pk] = parseOptions[pk][key];\n      }\n    });\n    self.group(key, usage.getPositionalGroupName());\n    return self.option(key, opts);\n  };\n\n  self.group = function group(opts, groupName) {\n    argsert('<string|array> <string>', [opts, groupName], arguments.length);\n    const existing = preservedGroups[groupName] || groups[groupName];\n\n    if (preservedGroups[groupName]) {\n      // we now only need to track this group name in groups.\n      delete preservedGroups[groupName];\n    }\n\n    const seen = {};\n    groups[groupName] = (existing || []).concat(opts).filter(key => {\n      if (seen[key]) return false;\n      return seen[key] = true;\n    });\n    return self;\n  }; // combine explicit and preserved groups. explicit groups should be first\n\n\n  self.getGroups = () => Object.assign({}, groups, preservedGroups); // as long as options.envPrefix is not undefined,\n  // parser will apply env vars matching prefix to argv\n\n\n  self.env = function (prefix) {\n    argsert('[string|boolean]', [prefix], arguments.length);\n    if (prefix === false) options.envPrefix = undefined;else options.envPrefix = prefix || '';\n    return self;\n  };\n\n  self.wrap = function (cols) {\n    argsert('<number|null|undefined>', [cols], arguments.length);\n    usage.wrap(cols);\n    return self;\n  };\n\n  let strict = false;\n\n  self.strict = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strict = enabled !== false;\n    return self;\n  };\n\n  self.getStrict = () => strict;\n\n  let parserConfig = {};\n\n  self.parserConfiguration = function parserConfiguration(config) {\n    argsert('<object>', [config], arguments.length);\n    parserConfig = config;\n    return self;\n  };\n\n  self.getParserConfiguration = () => parserConfig;\n\n  self.showHelp = function (level) {\n    argsert('[string|function]', [level], arguments.length);\n    if (!self.parsed) self._parseArgs(processArgs); // run parser, if it has not already been executed.\n\n    if (command.hasDefaultCommand()) {\n      context.resets++; // override the restriction on top-level positoinals.\n\n      command.runDefaultBuilderOn(self, true);\n    }\n\n    usage.showHelp(level);\n    return self;\n  };\n\n  let versionOpt = null;\n\n  self.version = function version(opt, msg, ver) {\n    const defaultVersionOpt = 'version';\n    argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length); // nuke the key previously configured\n    // to return version #.\n\n    if (versionOpt) {\n      deleteFromParserHintObject(versionOpt);\n      usage.version(undefined);\n      versionOpt = null;\n    }\n\n    if (arguments.length === 0) {\n      ver = guessVersion();\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 1) {\n      if (opt === false) {\n        // disable default 'version' key.\n        return self;\n      }\n\n      ver = opt;\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 2) {\n      ver = msg;\n      msg = null;\n    }\n\n    versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n    msg = msg || usage.deferY18nLookup('Show version number');\n    usage.version(ver || undefined);\n    self.boolean(versionOpt);\n    self.describe(versionOpt, msg);\n    return self;\n  };\n\n  function guessVersion() {\n    const obj = pkgUp();\n    return obj.version || 'unknown';\n  }\n\n  let helpOpt = null;\n\n  self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n    const defaultHelpOpt = 'help';\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length); // nuke the key previously configured\n    // to return help.\n\n    if (helpOpt) {\n      deleteFromParserHintObject(helpOpt);\n      helpOpt = null;\n    }\n\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    } // use arguments, fallback to defaults for opt and msg\n\n\n    helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n    self.boolean(helpOpt);\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n    return self;\n  };\n\n  const defaultShowHiddenOpt = 'show-hidden';\n  options.showHiddenOpt = defaultShowHiddenOpt;\n\n  self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    }\n\n    const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n    self.boolean(showHiddenOpt);\n    self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));\n    options.showHiddenOpt = showHiddenOpt;\n    return self;\n  };\n\n  self.hide = function hide(key) {\n    argsert('<string|object>', [key], arguments.length);\n    options.hiddenOptions.push(key);\n    return self;\n  };\n\n  self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n    argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n    usage.showHelpOnFail(enabled, message);\n    return self;\n  };\n\n  var exitProcess = true;\n\n  self.exitProcess = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n\n    if (typeof enabled !== 'boolean') {\n      enabled = true;\n    }\n\n    exitProcess = enabled;\n    return self;\n  };\n\n  self.getExitProcess = () => exitProcess;\n\n  var completionCommand = null;\n\n  self.completion = function (cmd, desc, fn) {\n    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length); // a function to execute when generating\n    // completions can be provided as the second\n    // or third argument to completion.\n\n    if (typeof desc === 'function') {\n      fn = desc;\n      desc = null;\n    } // register the completion command.\n\n\n    completionCommand = cmd || 'completion';\n\n    if (!desc && desc !== false) {\n      desc = 'generate completion script';\n    }\n\n    self.command(completionCommand, desc); // a function can be provided\n\n    if (fn) completion.registerFunction(fn);\n    return self;\n  };\n\n  self.showCompletionScript = function ($0) {\n    argsert('[string]', [$0], arguments.length);\n    $0 = $0 || self.$0;\n\n    _logger.log(completion.generateCompletionScript($0, completionCommand));\n\n    return self;\n  };\n\n  self.getCompletion = function (args, done) {\n    argsert('<array> <function>', [args, done], arguments.length);\n    completion.getCompletion(args, done);\n  };\n\n  self.locale = function (locale) {\n    argsert('[string]', [locale], arguments.length);\n\n    if (arguments.length === 0) {\n      guessLocale();\n      return y18n.getLocale();\n    }\n\n    detectLocale = false;\n    y18n.setLocale(locale);\n    return self;\n  };\n\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert('<object>', [obj], arguments.length);\n    detectLocale = false;\n    y18n.updateLocale(obj);\n    return self;\n  };\n\n  let detectLocale = true;\n\n  self.detectLocale = function (detect) {\n    argsert('<boolean>', [detect], arguments.length);\n    detectLocale = detect;\n    return self;\n  };\n\n  self.getDetectLocale = () => detectLocale;\n\n  var hasOutput = false;\n  var exitError = null; // maybe exit, always capture\n  // context about why we wanted to exit.\n\n  self.exit = (code, err) => {\n    hasOutput = true;\n    exitError = err;\n    if (exitProcess) process.exit(code);\n  }; // we use a custom logger that buffers output,\n  // so that we can print to non-CLIs, e.g., chat-bots.\n\n\n  const _logger = {\n    log() {\n      const args = [];\n\n      for (let i = 0; i < arguments.length; i++) args.push(arguments[i]);\n\n      if (!self._hasParseCallback()) console.log.apply(console, args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    },\n\n    error() {\n      const args = [];\n\n      for (let i = 0; i < arguments.length; i++) args.push(arguments[i]);\n\n      if (!self._hasParseCallback()) console.error.apply(console, args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    }\n\n  };\n\n  self._getLoggerInstance = () => _logger; // has yargs output an error our help\n  // message in the current execution context.\n\n\n  self._hasOutput = () => hasOutput;\n\n  self._setHasOutput = () => {\n    hasOutput = true;\n  };\n\n  let recommendCommands;\n\n  self.recommendCommands = function (recommend) {\n    argsert('[boolean]', [recommend], arguments.length);\n    recommendCommands = typeof recommend === 'boolean' ? recommend : true;\n    return self;\n  };\n\n  self.getUsageInstance = () => usage;\n\n  self.getValidationInstance = () => validation;\n\n  self.getCommandInstance = () => command;\n\n  self.terminalWidth = () => {\n    argsert([], 0);\n    return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null;\n  };\n\n  Object.defineProperty(self, 'argv', {\n    get: () => self._parseArgs(processArgs),\n    enumerable: true\n  });\n\n  self._parseArgs = function parseArgs(args, shortCircuit, _skipValidation, commandIndex) {\n    let skipValidation = !!_skipValidation;\n    args = args || processArgs;\n    options.__ = y18n.__;\n    options.configuration = self.getParserConfiguration(); // Deprecated\n\n    let pkgConfig = pkgUp()['yargs'];\n\n    if (pkgConfig) {\n      console.warn('Configuring yargs through package.json is deprecated and will be removed in the next major release, please use the JS API instead.');\n      options.configuration = Object.assign({}, pkgConfig, options.configuration);\n    }\n\n    const parsed = Parser.detailed(args, options);\n    let argv = parsed.argv;\n    if (parseContext) argv = Object.assign({}, argv, parseContext);\n    const aliases = parsed.aliases;\n    argv.$0 = self.$0;\n    self.parsed = parsed;\n\n    try {\n      guessLocale(); // guess locale lazily, so that it can be turned off in chain.\n      // while building up the argv object, there\n      // are two passes through the parser. If completion\n      // is being performed short-circuit on the first pass.\n\n      if (shortCircuit) {\n        return argv;\n      } // if there's a handler associated with a\n      // command defer processing to it.\n\n\n      if (helpOpt) {\n        // consider any multi-char helpOpt alias as a valid help command\n        // unless all helpOpt aliases are single-char\n        // note that parsed.aliases is a normalized bidirectional map :)\n        const helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter(k => k.length > 1); // check if help should trigger and strip it from _.\n\n        if (~helpCmds.indexOf(argv._[argv._.length - 1])) {\n          argv._.pop();\n\n          argv[helpOpt] = true;\n        }\n      }\n\n      const handlerKeys = command.getCommands();\n      const requestCompletions = completion.completionKey in argv;\n      const skipRecommendation = argv[helpOpt] || requestCompletions;\n      const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n\n      if (argv._.length) {\n        if (handlerKeys.length) {\n          let firstUnknownCommand;\n\n          for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {\n            cmd = String(argv._[i]);\n\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              // commands are executed using a recursive algorithm that executes\n              // the deepest command first; we keep track of the position in the\n              // argv._ array that is currently being executed.\n              return command.runCommand(cmd, self, parsed, i + 1);\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd;\n              break;\n            }\n          } // run the default command, if defined\n\n\n          if (command.hasDefaultCommand() && !skipDefaultCommand) {\n            return command.runCommand(null, self, parsed);\n          } // recommend a command if recommendCommands() has\n          // been enabled, and no commands were found to execute\n\n\n          if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n            validation.recommendCommands(firstUnknownCommand, handlerKeys);\n          }\n        } // generate a completion script for adding to ~/.bashrc.\n\n\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\n          if (exitProcess) setBlocking(true);\n          self.showCompletionScript();\n          self.exit(0);\n        }\n      } else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n        return command.runCommand(null, self, parsed);\n      } // we must run completions first, a user might\n      // want to complete the --help or --version option.\n\n\n      if (requestCompletions) {\n        if (exitProcess) setBlocking(true); // we allow for asynchronous completions,\n        // e.g., loading in a list of commands from an API.\n\n        const completionArgs = args.slice(args.indexOf(\"--\".concat(completion.completionKey)) + 1);\n        completion.getCompletion(completionArgs, completions => {\n          ;\n          (completions || []).forEach(completion => {\n            _logger.log(completion);\n          });\n          self.exit(0);\n        });\n        return argv;\n      } // Handle 'help' and 'version' options\n      // if we haven't already output help!\n\n\n      if (!hasOutput) {\n        Object.keys(argv).forEach(key => {\n          if (key === helpOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            self.showHelp('log');\n            self.exit(0);\n          } else if (key === versionOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            usage.showVersion();\n            self.exit(0);\n          }\n        });\n      } // Check if any of the options to skip validation were provided\n\n\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n      } // If the help or version options where used and exitProcess is false,\n      // or if explicitly skipped, we won't run validations.\n\n\n      if (!skipValidation) {\n        if (parsed.error) throw new YError(parsed.error.message); // if we're executed via bash completion, don't\n        // bother with validation.\n\n        if (!requestCompletions) {\n          self._runValidation(argv, aliases, {}, parsed.error);\n        }\n      }\n    } catch (err) {\n      if (err instanceof YError) usage.fail(err.message, err);else throw err;\n    }\n\n    return argv;\n  };\n\n  self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors) {\n    if (parseErrors) throw new YError(parseErrors.message || parseErrors);\n    validation.nonOptionCount(argv);\n    validation.requiredArguments(argv);\n    if (strict) validation.unknownArguments(argv, aliases, positionalMap);\n    validation.customChecks(argv, aliases);\n    validation.limitedChoices(argv);\n    validation.implications(argv);\n    validation.conflicting(argv);\n  };\n\n  function guessLocale() {\n    if (!detectLocale) return;\n\n    try {\n      const _process = process,\n            env = _process.env;\n      const locale = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE || 'en_US';\n      self.locale(locale.replace(/[.:].*/, ''));\n    } catch (err) {// if we explode looking up locale just noop\n      // we'll keep using the default language 'en'.\n    }\n  } // an app should almost always have --version and --help,\n  // if you *really* want to disable this use .help(false)/.version(false).\n\n\n  self.help();\n  self.version();\n  return self;\n} // rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\n\n\nexports.rebase = rebase;\n\nfunction rebase(base, dir) {\n  return path.relative(base, dir);\n}","map":null,"metadata":{},"sourceType":"script"}