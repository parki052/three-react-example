{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _default_reporter = _interopRequireDefault(require('./default_reporter'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst ICONS = _jestUtil().specialChars.ICONS;\n\nclass VerboseReporter extends _default_reporter.default {\n  constructor(globalConfig) {\n    super(globalConfig);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    this._globalConfig = globalConfig;\n  }\n\n  static filterTestResults(testResults) {\n    return testResults.filter(({\n      status\n    }) => status !== 'pending');\n  }\n\n  static groupTestsBySuites(testResults) {\n    const root = {\n      suites: [],\n      tests: [],\n      title: ''\n    };\n    testResults.forEach(testResult => {\n      let targetSuite = root; // Find the target suite for this test,\n      // creating nested suites as necessary.\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = testResult.ancestorTitles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          const title = _step.value;\n          let matchingSuite = targetSuite.suites.find(s => s.title === title);\n\n          if (!matchingSuite) {\n            matchingSuite = {\n              suites: [],\n              tests: [],\n              title\n            };\n            targetSuite.suites.push(matchingSuite);\n          }\n\n          targetSuite = matchingSuite;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      targetSuite.tests.push(testResult);\n    });\n    return root;\n  }\n\n  onTestResult(test, result, aggregatedResults) {\n    super.testFinished(test.context.config, result, aggregatedResults);\n\n    if (!result.skipped) {\n      this.printTestFileHeader(result.testFilePath, test.context.config, result);\n\n      if (!result.testExecError && !result.skipped) {\n        this._logTestResults(result.testResults);\n      }\n\n      this.printTestFileFailureMessage(result.testFilePath, test.context.config, result);\n    }\n\n    super.forceFlushBufferedOutput();\n  }\n\n  _logTestResults(testResults) {\n    this._logSuite(VerboseReporter.groupTestsBySuites(testResults), 0);\n\n    this._logLine();\n  }\n\n  _logSuite(suite, indentLevel) {\n    if (suite.title) {\n      this._logLine(suite.title, indentLevel);\n    }\n\n    this._logTests(suite.tests, indentLevel + 1);\n\n    suite.suites.forEach(suite => this._logSuite(suite, indentLevel + 1));\n  }\n\n  _getIcon(status) {\n    if (status === 'failed') {\n      return _chalk().default.red(ICONS.failed);\n    } else if (status === 'pending') {\n      return _chalk().default.yellow(ICONS.pending);\n    } else if (status === 'todo') {\n      return _chalk().default.magenta(ICONS.todo);\n    } else {\n      return _chalk().default.green(ICONS.success);\n    }\n  }\n\n  _logTest(test, indentLevel) {\n    const status = this._getIcon(test.status);\n\n    const time = test.duration ? \" (\".concat(test.duration.toFixed(0), \"ms)\") : '';\n\n    this._logLine(status + ' ' + _chalk().default.dim(test.title + time), indentLevel);\n  }\n\n  _logTests(tests, indentLevel) {\n    if (this._globalConfig.expand) {\n      tests.forEach(test => this._logTest(test, indentLevel));\n    } else {\n      const summedTests = tests.reduce((result, test) => {\n        if (test.status === 'pending') {\n          result.pending.push(test);\n        } else if (test.status === 'todo') {\n          result.todo.push(test);\n        } else {\n          this._logTest(test, indentLevel);\n        }\n\n        return result;\n      }, {\n        pending: [],\n        todo: []\n      });\n\n      if (summedTests.pending.length > 0) {\n        summedTests.pending.forEach(this._logTodoOrPendingTest(indentLevel));\n      }\n\n      if (summedTests.todo.length > 0) {\n        summedTests.todo.forEach(this._logTodoOrPendingTest(indentLevel));\n      }\n    }\n  }\n\n  _logTodoOrPendingTest(indentLevel) {\n    return test => {\n      const printedTestStatus = test.status === 'pending' ? 'skipped' : test.status;\n\n      const icon = this._getIcon(test.status);\n\n      const text = _chalk().default.dim(\"\".concat(printedTestStatus, \" \").concat(test.title));\n\n      this._logLine(\"\".concat(icon, \" \").concat(text), indentLevel);\n    };\n  }\n\n  _logLine(str, indentLevel) {\n    const indentation = '  '.repeat(indentLevel || 0);\n    this.log(indentation + (str || ''));\n  }\n\n}\n\nexports.default = VerboseReporter;","map":null,"metadata":{},"sourceType":"script"}