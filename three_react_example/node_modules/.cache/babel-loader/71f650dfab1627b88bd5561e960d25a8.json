{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _types = require('./types');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass Farm {\n  constructor(numOfWorkers, callback, computeWorkerKey) {\n    _defineProperty(this, '_computeWorkerKey', void 0);\n\n    _defineProperty(this, '_cacheKeys', void 0);\n\n    _defineProperty(this, '_callback', void 0);\n\n    _defineProperty(this, '_last', void 0);\n\n    _defineProperty(this, '_locks', void 0);\n\n    _defineProperty(this, '_numOfWorkers', void 0);\n\n    _defineProperty(this, '_offset', void 0);\n\n    _defineProperty(this, '_queue', void 0);\n\n    this._cacheKeys = Object.create(null);\n    this._callback = callback;\n    this._last = [];\n    this._locks = [];\n    this._numOfWorkers = numOfWorkers;\n    this._offset = 0;\n    this._queue = [];\n\n    if (computeWorkerKey) {\n      this._computeWorkerKey = computeWorkerKey;\n    }\n  }\n\n  doWork(method, ...args) {\n    return new Promise((resolve, reject) => {\n      const computeWorkerKey = this._computeWorkerKey;\n      const request = [_types.CHILD_MESSAGE_CALL, false, method, args];\n      let worker = null;\n      let hash = null;\n\n      if (computeWorkerKey) {\n        hash = computeWorkerKey.call(this, method, ...args);\n        worker = hash == null ? null : this._cacheKeys[hash];\n      }\n\n      const onStart = worker => {\n        if (hash != null) {\n          this._cacheKeys[hash] = worker;\n        }\n      };\n\n      const onEnd = (error, result) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n\n      const task = {\n        onEnd,\n        onStart,\n        request\n      };\n\n      if (worker) {\n        this._enqueue(task, worker.getWorkerId());\n      } else {\n        this._push(task);\n      }\n    });\n  }\n\n  _getNextTask(workerId) {\n    let queueHead = this._queue[workerId];\n\n    while (queueHead && queueHead.task.request[1]) {\n      queueHead = queueHead.next || null;\n    }\n\n    this._queue[workerId] = queueHead;\n    return queueHead && queueHead.task;\n  }\n\n  _process(workerId) {\n    if (this._isLocked(workerId)) {\n      return this;\n    }\n\n    const task = this._getNextTask(workerId);\n\n    if (!task) {\n      return this;\n    }\n\n    const onEnd = (error, result) => {\n      task.onEnd(error, result);\n\n      this._unlock(workerId);\n\n      this._process(workerId);\n    };\n\n    task.request[1] = true;\n\n    this._lock(workerId);\n\n    this._callback(workerId, task.request, task.onStart, onEnd);\n\n    return this;\n  }\n\n  _enqueue(task, workerId) {\n    const item = {\n      next: null,\n      task\n    };\n\n    if (task.request[1]) {\n      return this;\n    }\n\n    if (this._queue[workerId]) {\n      this._last[workerId].next = item;\n    } else {\n      this._queue[workerId] = item;\n    }\n\n    this._last[workerId] = item;\n\n    this._process(workerId);\n\n    return this;\n  }\n\n  _push(task) {\n    for (let i = 0; i < this._numOfWorkers; i++) {\n      this._enqueue(task, (this._offset + i) % this._numOfWorkers);\n    }\n\n    this._offset++;\n    return this;\n  }\n\n  _lock(workerId) {\n    this._locks[workerId] = true;\n  }\n\n  _unlock(workerId) {\n    this._locks[workerId] = false;\n  }\n\n  _isLocked(workerId) {\n    return this._locks[workerId];\n  }\n\n}\n\nexports.default = Farm;","map":null,"metadata":{},"sourceType":"script"}