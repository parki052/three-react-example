{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n\n  _istanbulLibReport = function _istanbulLibReport() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n\n  _istanbulReports = function _istanbulReports() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n\n  _istanbulLibCoverage = function _istanbulLibCoverage() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n\n  _istanbulLibSourceMaps = function _istanbulLibSourceMaps() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = _interopRequireDefault(require('jest-worker'));\n\n  _jestWorker = function _jestWorker() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function _glob() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _base_reporter = _interopRequireDefault(require('./base_reporter'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst FAIL_COLOR = _chalk().default.bold.red;\n\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\n\nclass CoverageReporter extends _base_reporter.default {\n  constructor(globalConfig, options) {\n    super();\n\n    _defineProperty(this, '_coverageMap', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_sourceMapStore', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore = _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._options = options || {};\n  }\n\n  onTestResult(_test, testResult, _aggregatedResults) {\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n\n    const sourceMaps = testResult.sourceMaps;\n\n    if (sourceMaps) {\n      Object.keys(sourceMaps).forEach(sourcePath => {\n        let inputSourceMap;\n\n        try {\n          const coverage = this._coverageMap.fileCoverageFor(sourcePath);\n\n          inputSourceMap = coverage.toJSON().inputSourceMap;\n        } finally {\n          if (inputSourceMap) {\n            this._sourceMapStore.registerMap(sourcePath, inputSourceMap);\n          } else {\n            this._sourceMapStore.registerURL(sourcePath, sourceMaps[sourcePath]);\n          }\n        }\n      });\n    }\n  }\n\n  onRunComplete(contexts, aggregatedResults) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this._addUntestedFiles(_this._globalConfig, contexts);\n\n      const _this$_sourceMapStore = _this._sourceMapStore.transformCoverage(_this._coverageMap),\n            map = _this$_sourceMapStore.map,\n            sourceFinder = _this$_sourceMapStore.sourceFinder;\n\n      try {\n        const reportContext = _istanbulLibReport().default.createContext({\n          dir: _this._globalConfig.coverageDirectory,\n          sourceFinder\n        });\n\n        const coverageReporters = _this._globalConfig.coverageReporters || [];\n\n        if (!_this._globalConfig.useStderr && coverageReporters.length < 1) {\n          coverageReporters.push('text-summary');\n        }\n\n        const tree = _istanbulLibReport().default.summarizers.pkg(map);\n\n        coverageReporters.forEach(reporter => {\n          tree.visit(_istanbulReports().default.create(reporter, {}), reportContext);\n        });\n        aggregatedResults.coverageMap = map;\n      } catch (e) {\n        console.error(_chalk().default.red(\"\\n        Failed to write coverage reports:\\n        ERROR: \".concat(e.toString(), \"\\n        STACK: \").concat(e.stack, \"\\n      \")));\n      }\n\n      _this._checkThreshold(_this._globalConfig, map);\n    })();\n  }\n\n  _addUntestedFiles(globalConfig, contexts) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const files = [];\n      contexts.forEach(context => {\n        const config = context.config;\n\n        if (globalConfig.collectCoverageFrom && globalConfig.collectCoverageFrom.length) {\n          context.hasteFS.matchFilesWithGlob(globalConfig.collectCoverageFrom, config.rootDir).forEach(filePath => files.push({\n            config,\n            path: filePath\n          }));\n        }\n      });\n\n      if (!files.length) {\n        return;\n      }\n\n      if (_jestUtil().isInteractive) {\n        process.stderr.write(RUNNING_TEST_COLOR('Running coverage on untested files...'));\n      }\n\n      let worker;\n\n      if (_this2._globalConfig.maxWorkers <= 1) {\n        worker = require('./coverage_worker');\n      } else {\n        worker = new (_jestWorker().default)(require.resolve('./coverage_worker'), {\n          exposedMethods: ['worker'],\n          maxRetries: 2,\n          numWorkers: _this2._globalConfig.maxWorkers\n        });\n      }\n\n      const instrumentation = files.map(\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(function* (fileObj) {\n          const filename = fileObj.path;\n          const config = fileObj.config;\n\n          if (!_this2._coverageMap.data[filename] && 'worker' in worker) {\n            try {\n              const result = yield worker.worker({\n                config,\n                globalConfig,\n                options: _objectSpread({}, _this2._options, {\n                  changedFiles: _this2._options.changedFiles && Array.from(_this2._options.changedFiles)\n                }),\n                path: filename\n              });\n\n              if (result) {\n                _this2._coverageMap.addFileCoverage(result.coverage);\n\n                if (result.sourceMapPath) {\n                  _this2._sourceMapStore.registerURL(filename, result.sourceMapPath);\n                }\n              }\n            } catch (error) {\n              console.error(_chalk().default.red([\"Failed to collect coverage from \".concat(filename), \"ERROR: \".concat(error.message), \"STACK: \".concat(error.stack)].join('\\n')));\n            }\n          }\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n\n      try {\n        yield Promise.all(instrumentation);\n      } catch (err) {// Do nothing; errors were reported earlier to the console.\n      }\n\n      if (_jestUtil().isInteractive) {\n        (0, _jestUtil().clearLine)(process.stderr);\n      }\n\n      if (worker && 'end' in worker && typeof worker.end === 'function') {\n        worker.end();\n      }\n    })();\n  }\n\n  _checkThreshold(globalConfig, map) {\n    if (globalConfig.coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce((errors, key) => {\n          const actual = actuals[key].pct;\n          const actualUncovered = actuals[key].total - actuals[key].covered;\n          const threshold = thresholds[key];\n\n          if (threshold != null) {\n            if (threshold < 0) {\n              if (threshold * -1 < actualUncovered) {\n                errors.push(\"Jest: Uncovered count for \".concat(key, \" (\").concat(actualUncovered, \")\") + \"exceeds \".concat(name, \" threshold (\").concat(-1 * threshold, \")\"));\n              }\n            } else if (actual < threshold) {\n              errors.push(\"Jest: \\\"\".concat(name, \"\\\" coverage threshold for \").concat(key, \" (\").concat(threshold, \"%) not met: \").concat(actual, \"%\"));\n            }\n          }\n\n          return errors;\n        }, []);\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(globalConfig.coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce((files, file) => {\n        const pathOrGlobMatches = thresholdGroups.reduce((agg, thresholdGroup) => {\n          const absoluteThresholdGroup = _path().default.resolve(thresholdGroup); // The threshold group might be a path:\n\n\n          if (file.indexOf(absoluteThresholdGroup) === 0) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.PATH;\n            return agg.concat([[file, thresholdGroup]]);\n          } // If the threshold group is not a path it might be a glob:\n          // Note: glob.sync is slow. By memoizing the files matching each glob\n          // (rather than recalculating it for each covered file) we save a tonne\n          // of execution time.\n\n\n          if (filesByGlob[absoluteThresholdGroup] === undefined) {\n            filesByGlob[absoluteThresholdGroup] = _glob().default.sync(absoluteThresholdGroup).map(filePath => _path().default.resolve(filePath));\n          }\n\n          if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.GLOB;\n            return agg.concat([[file, thresholdGroup]]);\n          }\n\n          return agg;\n        }, []);\n\n        if (pathOrGlobMatches.length > 0) {\n          return files.concat(pathOrGlobMatches);\n        } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n\n        if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n          groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] = THRESHOLD_GROUP_TYPES.GLOBAL;\n          return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n        } // A covered file that doesn't have a threshold:\n\n\n        return files.concat([[file, undefined]]);\n      }, []);\n\n      const getFilesInThresholdGroup = thresholdGroup => coveredFilesSortedIntoThresholdGroup.filter(fileAndGroup => fileAndGroup[1] === thresholdGroup).map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths) {\n        return filePaths.map(filePath => map.fileCoverageFor(filePath)).reduce((combinedCoverage, nextFileCoverage) => {\n          if (combinedCoverage === undefined || combinedCoverage === null) {\n            return nextFileCoverage.toSummary();\n          }\n\n          return combinedCoverage.merge(nextFileCoverage.toSummary());\n        }, undefined);\n      }\n\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL));\n\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, globalConfig.coverageThreshold[thresholdGroup], coverage));\n              }\n\n              break;\n            }\n\n          case THRESHOLD_GROUP_TYPES.PATH:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(thresholdGroup));\n\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, globalConfig.coverageThreshold[thresholdGroup], coverage));\n              }\n\n              break;\n            }\n\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(fileMatchingGlob => {\n              errors = errors.concat(check(fileMatchingGlob, globalConfig.coverageThreshold[thresholdGroup], map.fileCoverageFor(fileMatchingGlob).toSummary()));\n            });\n            break;\n\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(\"Jest: Coverage data for \".concat(thresholdGroup, \" was not found.\"));\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(err => err !== undefined && err !== null && err.length > 0);\n\n      if (errors.length > 0) {\n        this.log(\"\".concat(FAIL_COLOR(errors.join('\\n'))));\n\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  } // Only exposed for the internal runner. Should not be used\n\n\n  getCoverageMap() {\n    return this._coverageMap;\n  }\n\n}\n\nexports.default = CoverageReporter;","map":null,"metadata":{},"sourceType":"script"}