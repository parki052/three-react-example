{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = defaultResolver;\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _browserResolve() {\n  const data = _interopRequireDefault(require('browser-resolve'));\n\n  _browserResolve = function _browserResolve() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestPnpResolver() {\n  const data = _interopRequireDefault(require('jest-pnp-resolver'));\n\n  _jestPnpResolver = function _jestPnpResolver() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _isBuiltinModule = _interopRequireDefault(require('./isBuiltinModule'));\n\nvar _nodeModulesPaths = _interopRequireDefault(require('./nodeModulesPaths'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction defaultResolver(path, options) {\n  // @ts-ignore: the \"pnp\" version named isn't in DefinitelyTyped\n  if (process.versions.pnp) {\n    return (0, _jestPnpResolver().default)(path, options);\n  }\n\n  const resolve = options.browser ? _browserResolve().default.sync : resolveSync;\n  return resolve(path, {\n    basedir: options.basedir,\n    defaultResolver,\n    extensions: options.extensions,\n    moduleDirectory: options.moduleDirectory,\n    paths: options.paths,\n    rootDir: options.rootDir\n  });\n}\n\nconst REGEX_RELATIVE_IMPORT = /^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[\\\\\\/])/;\n\nfunction resolveSync(target, options) {\n  const basedir = options.basedir;\n  const extensions = options.extensions || ['.js'];\n  const paths = options.paths || [];\n\n  if (REGEX_RELATIVE_IMPORT.test(target)) {\n    // resolve relative import\n    const resolveTarget = _path().default.resolve(basedir, target);\n\n    const result = tryResolve(resolveTarget);\n\n    if (result) {\n      return result;\n    }\n  } else {\n    // otherwise search for node_modules\n    const dirs = (0, _nodeModulesPaths.default)(basedir, {\n      moduleDirectory: options.moduleDirectory,\n      paths\n    });\n\n    for (let i = 0; i < dirs.length; i++) {\n      const resolveTarget = _path().default.join(dirs[i], target);\n\n      const result = tryResolve(resolveTarget);\n\n      if (result) {\n        return result;\n      }\n    }\n  }\n\n  if ((0, _isBuiltinModule.default)(target)) {\n    return target;\n  }\n\n  const err = new Error(\"Cannot find module '\" + target + \"' from '\" + basedir + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n  /*\n   * contextual helper functions\n   */\n\n  function tryResolve(name) {\n    const dir = _path().default.dirname(name);\n\n    let result;\n\n    if (isDirectory(dir)) {\n      result = resolveAsFile(name) || resolveAsDirectory(name);\n    }\n\n    if (result) {\n      // Dereference symlinks to ensure we don't create a separate\n      // module instance depending on how it was referenced.\n      result = _fs().default.realpathSync(result);\n    }\n\n    return result;\n  }\n\n  function resolveAsFile(name) {\n    if (isFile(name)) {\n      return name;\n    }\n\n    for (let i = 0; i < extensions.length; i++) {\n      const file = name + extensions[i];\n\n      if (isFile(file)) {\n        return file;\n      }\n    }\n\n    return undefined;\n  }\n\n  function resolveAsDirectory(name) {\n    if (!isDirectory(name)) {\n      return undefined;\n    }\n\n    const pkgfile = _path().default.join(name, 'package.json');\n\n    let pkgmain;\n\n    try {\n      const body = _fs().default.readFileSync(pkgfile, 'utf8');\n\n      pkgmain = JSON.parse(body).main;\n    } catch (e) {}\n\n    if (pkgmain && !isCurrentDirectory(pkgmain)) {\n      const resolveTarget = _path().default.resolve(name, pkgmain);\n\n      const result = tryResolve(resolveTarget);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return resolveAsFile(_path().default.join(name, 'index'));\n  }\n}\n\nvar IPathType;\n\n(function (IPathType) {\n  IPathType[IPathType['FILE'] = 1] = 'FILE';\n  IPathType[IPathType['DIRECTORY'] = 2] = 'DIRECTORY';\n  IPathType[IPathType['OTHER'] = 3] = 'OTHER';\n})(IPathType || (IPathType = {}));\n\nconst checkedPaths = new Map();\n\nfunction statSyncCached(path) {\n  const result = checkedPaths.get(path);\n\n  if (result !== undefined) {\n    return result;\n  }\n\n  let stat;\n\n  try {\n    stat = _fs().default.statSync(path);\n  } catch (e) {\n    if (!(e && (e.code === 'ENOENT' || e.code === 'ENOTDIR'))) {\n      throw e;\n    }\n  }\n\n  if (stat) {\n    if (stat.isFile() || stat.isFIFO()) {\n      checkedPaths.set(path, IPathType.FILE);\n      return IPathType.FILE;\n    } else if (stat.isDirectory()) {\n      checkedPaths.set(path, IPathType.DIRECTORY);\n      return IPathType.DIRECTORY;\n    }\n  }\n\n  checkedPaths.set(path, IPathType.OTHER);\n  return IPathType.OTHER;\n}\n/*\n * helper functions\n */\n\n\nfunction isFile(file) {\n  return statSyncCached(file) === IPathType.FILE;\n}\n\nfunction isDirectory(dir) {\n  return statSyncCached(dir) === IPathType.DIRECTORY;\n}\n\nconst CURRENT_DIRECTORY = _path().default.resolve('.');\n\nfunction isCurrentDirectory(testPath) {\n  return CURRENT_DIRECTORY === _path().default.resolve(testPath);\n}","map":null,"metadata":{},"sourceType":"script"}