{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.wrapAnsiString = exports.getSummary = exports.relativePath = exports.formatTestPath = exports.trimAndFormatPath = exports.printDisplayName = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function _slash() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst PROGRESS_BAR_WIDTH = 40;\n\nconst printDisplayName = config => {\n  const displayName = config.displayName;\n\n  const white = _chalk().default.reset.inverse.white;\n\n  if (!displayName) {\n    return '';\n  }\n\n  if (typeof displayName === 'string') {\n    return _chalk().default.supportsColor ? white(\" \".concat(displayName, \" \")) : displayName;\n  }\n\n  const name = displayName.name,\n        color = displayName.color;\n  const chosenColor = _chalk().default.reset.inverse[color] ? _chalk().default.reset.inverse[color] : white;\n  return _chalk().default.supportsColor ? chosenColor(\" \".concat(name, \" \")) : name;\n};\n\nexports.printDisplayName = printDisplayName;\n\nconst trimAndFormatPath = (pad, config, testPath, columns) => {\n  const maxLength = columns - pad;\n  const relative = relativePath(config, testPath);\n  const basename = relative.basename;\n  let dirname = relative.dirname; // length is ok\n\n  if ((dirname + _path().default.sep + basename).length <= maxLength) {\n    return (0, _slash().default)(_chalk().default.dim(dirname + _path().default.sep) + _chalk().default.bold(basename));\n  } // we can fit trimmed dirname and full basename\n\n\n  const basenameLength = basename.length;\n\n  if (basenameLength + 4 < maxLength) {\n    const dirnameLength = maxLength - 4 - basenameLength;\n    dirname = '...' + dirname.slice(dirname.length - dirnameLength, dirname.length);\n    return (0, _slash().default)(_chalk().default.dim(dirname + _path().default.sep) + _chalk().default.bold(basename));\n  }\n\n  if (basenameLength + 4 === maxLength) {\n    return (0, _slash().default)(_chalk().default.dim('...' + _path().default.sep) + _chalk().default.bold(basename));\n  } // can't fit dirname, but can fit trimmed basename\n\n\n  return (0, _slash().default)(_chalk().default.bold('...' + basename.slice(basename.length - maxLength - 4, basename.length)));\n};\n\nexports.trimAndFormatPath = trimAndFormatPath;\n\nconst formatTestPath = (config, testPath) => {\n  const _relativePath = relativePath(config, testPath),\n        dirname = _relativePath.dirname,\n        basename = _relativePath.basename;\n\n  return (0, _slash().default)(_chalk().default.dim(dirname + _path().default.sep) + _chalk().default.bold(basename));\n};\n\nexports.formatTestPath = formatTestPath;\n\nconst relativePath = (config, testPath) => {\n  // this function can be called with ProjectConfigs or GlobalConfigs. GlobalConfigs\n  // do not have config.cwd, only config.rootDir. Try using config.cwd, fallback\n  // to config.rootDir. (Also, some unit just use config.rootDir, which is ok)\n  testPath = _path().default.relative(config.cwd || config.rootDir, testPath);\n\n  const dirname = _path().default.dirname(testPath);\n\n  const basename = _path().default.basename(testPath);\n\n  return {\n    basename,\n    dirname\n  };\n};\n\nexports.relativePath = relativePath;\n\nconst getSummary = (aggregatedResults, options) => {\n  let runTime = (Date.now() - aggregatedResults.startTime) / 1000;\n\n  if (options && options.roundTime) {\n    runTime = Math.floor(runTime);\n  }\n\n  const estimatedTime = options && options.estimatedTime || 0;\n  const snapshotResults = aggregatedResults.snapshot;\n  const snapshotsAdded = snapshotResults.added;\n  const snapshotsFailed = snapshotResults.unmatched;\n  const snapshotsOutdated = snapshotResults.unchecked;\n  const snapshotsFilesRemoved = snapshotResults.filesRemoved;\n  const snapshotsDidUpdate = snapshotResults.didUpdate;\n  const snapshotsPassed = snapshotResults.matched;\n  const snapshotsTotal = snapshotResults.total;\n  const snapshotsUpdated = snapshotResults.updated;\n  const suitesFailed = aggregatedResults.numFailedTestSuites;\n  const suitesPassed = aggregatedResults.numPassedTestSuites;\n  const suitesPending = aggregatedResults.numPendingTestSuites;\n  const suitesRun = suitesFailed + suitesPassed;\n  const suitesTotal = aggregatedResults.numTotalTestSuites;\n  const testsFailed = aggregatedResults.numFailedTests;\n  const testsPassed = aggregatedResults.numPassedTests;\n  const testsPending = aggregatedResults.numPendingTests;\n  const testsTodo = aggregatedResults.numTodoTests;\n  const testsTotal = aggregatedResults.numTotalTests;\n  const width = options && options.width || 0;\n  const suites = _chalk().default.bold('Test Suites: ') + (suitesFailed ? _chalk().default.bold.red(\"\".concat(suitesFailed, \" failed\")) + ', ' : '') + (suitesPending ? _chalk().default.bold.yellow(\"\".concat(suitesPending, \" skipped\")) + ', ' : '') + (suitesPassed ? _chalk().default.bold.green(\"\".concat(suitesPassed, \" passed\")) + ', ' : '') + (suitesRun !== suitesTotal ? suitesRun + ' of ' + suitesTotal : suitesTotal) + \" total\";\n  const tests = _chalk().default.bold('Tests:       ') + (testsFailed ? _chalk().default.bold.red(\"\".concat(testsFailed, \" failed\")) + ', ' : '') + (testsPending ? _chalk().default.bold.yellow(\"\".concat(testsPending, \" skipped\")) + ', ' : '') + (testsTodo ? _chalk().default.bold.magenta(\"\".concat(testsTodo, \" todo\")) + ', ' : '') + (testsPassed ? _chalk().default.bold.green(\"\".concat(testsPassed, \" passed\")) + ', ' : '') + \"\".concat(testsTotal, \" total\");\n  const snapshots = _chalk().default.bold('Snapshots:   ') + (snapshotsFailed ? _chalk().default.bold.red(\"\".concat(snapshotsFailed, \" failed\")) + ', ' : '') + (snapshotsOutdated && !snapshotsDidUpdate ? _chalk().default.bold.yellow(\"\".concat(snapshotsOutdated, \" obsolete\")) + ', ' : '') + (snapshotsOutdated && snapshotsDidUpdate ? _chalk().default.bold.green(\"\".concat(snapshotsOutdated, \" removed\")) + ', ' : '') + (snapshotsFilesRemoved && !snapshotsDidUpdate ? _chalk().default.bold.yellow((0, _jestUtil().pluralize)('file', snapshotsFilesRemoved) + ' obsolete') + ', ' : '') + (snapshotsFilesRemoved && snapshotsDidUpdate ? _chalk().default.bold.green((0, _jestUtil().pluralize)('file', snapshotsFilesRemoved) + ' removed') + ', ' : '') + (snapshotsUpdated ? _chalk().default.bold.green(\"\".concat(snapshotsUpdated, \" updated\")) + ', ' : '') + (snapshotsAdded ? _chalk().default.bold.green(\"\".concat(snapshotsAdded, \" written\")) + ', ' : '') + (snapshotsPassed ? _chalk().default.bold.green(\"\".concat(snapshotsPassed, \" passed\")) + ', ' : '') + \"\".concat(snapshotsTotal, \" total\");\n  const time = renderTime(runTime, estimatedTime, width);\n  return [suites, tests, snapshots, time].join('\\n');\n};\n\nexports.getSummary = getSummary;\n\nconst renderTime = (runTime, estimatedTime, width) => {\n  // If we are more than one second over the estimated time, highlight it.\n  const renderedTime = estimatedTime && runTime >= estimatedTime + 1 ? _chalk().default.bold.yellow(runTime + 's') : runTime + 's';\n  let time = _chalk().default.bold(\"Time:\") + \"        \".concat(renderedTime);\n\n  if (runTime < estimatedTime) {\n    time += \", estimated \".concat(estimatedTime, \"s\");\n  } // Only show a progress bar if the test run is actually going to take\n  // some time.\n\n\n  if (estimatedTime > 2 && runTime < estimatedTime && width) {\n    const availableWidth = Math.min(PROGRESS_BAR_WIDTH, width);\n    const length = Math.min(Math.floor(runTime / estimatedTime * availableWidth), availableWidth);\n\n    if (availableWidth >= 2) {\n      time += '\\n' + _chalk().default.green('█').repeat(length) + _chalk().default.white('█').repeat(availableWidth - length);\n    }\n  }\n\n  return time;\n}; // word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\n\n\nconst wrapAnsiString = (string, terminalWidth) => {\n  if (terminalWidth === 0) {\n    // if the terminal width is zero, don't bother word-wrapping\n    return string;\n  }\n\n  const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/g;\n  const tokens = [];\n  let lastIndex = 0;\n  let match;\n\n  while (match = ANSI_REGEXP.exec(string)) {\n    const ansi = match[0];\n    const index = match['index'];\n\n    if (index != lastIndex) {\n      tokens.push(['string', string.slice(lastIndex, index)]);\n    }\n\n    tokens.push(['ansi', ansi]);\n    lastIndex = index + ansi.length;\n  }\n\n  if (lastIndex != string.length - 1) {\n    tokens.push(['string', string.slice(lastIndex, string.length)]);\n  }\n\n  let lastLineLength = 0;\n  return tokens.reduce((lines, [kind, token]) => {\n    if (kind === 'string') {\n      if (lastLineLength + token.length > terminalWidth) {\n        while (token.length) {\n          const chunk = token.slice(0, terminalWidth - lastLineLength);\n          const remaining = token.slice(terminalWidth - lastLineLength, token.length);\n          lines[lines.length - 1] += chunk;\n          lastLineLength += chunk.length;\n          token = remaining;\n\n          if (token.length) {\n            lines.push('');\n            lastLineLength = 0;\n          }\n        }\n      } else {\n        lines[lines.length - 1] += token;\n        lastLineLength += token.length;\n      }\n    } else {\n      lines[lines.length - 1] += token;\n    }\n\n    return lines;\n  }, ['']).join('\\n');\n};\n\nexports.wrapAnsiString = wrapAnsiString;","map":null,"metadata":{},"sourceType":"script"}