{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst pathutils = require('./pathutils');\n\nconst _require$SourceMapCon = require('source-map').SourceMapConsumer,\n      GREATEST_LOWER_BOUND = _require$SourceMapCon.GREATEST_LOWER_BOUND,\n      LEAST_UPPER_BOUND = _require$SourceMapCon.LEAST_UPPER_BOUND;\n/**\n * AST ranges are inclusive for start positions and exclusive for end positions.\n * Source maps are also logically ranges over text, though interacting with\n * them is generally achieved by working with explicit positions.\n *\n * When finding the _end_ location of an AST item, the range behavior is\n * important because what we're asking for is the _end_ of whatever range\n * corresponds to the end location we seek.\n *\n * This boils down to the following steps, conceptually, though the source-map\n * library doesn't expose primitives to do this nicely:\n *\n * 1. Find the range on the generated file that ends at, or exclusively\n *    contains the end position of the AST node.\n * 2. Find the range on the original file that corresponds to\n *    that generated range.\n * 3. Find the _end_ location of that original range.\n */\n\n\nfunction originalEndPositionFor(sourceMap, generatedEnd) {\n  // Given the generated location, find the original location of the mapping\n  // that corresponds to a range on the generated file that overlaps the\n  // generated file end location. Note however that this position on its\n  // own is not useful because it is the position of the _start_ of the range\n  // on the original file, and we want the _end_ of the range.\n  const beforeEndMapping = originalPositionTryBoth(sourceMap, generatedEnd.line, generatedEnd.column - 1);\n\n  if (beforeEndMapping.source === null) {\n    return null;\n  } // Convert that original position back to a generated one, with a bump\n  // to the right, and a rightward bias. Since 'generatedPositionFor' searches\n  // for mappings in the original-order sorted list, this will find the\n  // mapping that corresponds to the one immediately after the\n  // beforeEndMapping mapping.\n\n\n  const afterEndMapping = sourceMap.generatedPositionFor({\n    source: beforeEndMapping.source,\n    line: beforeEndMapping.line,\n    column: beforeEndMapping.column + 1,\n    bias: LEAST_UPPER_BOUND\n  });\n\n  if ( // If this is null, it means that we've hit the end of the file,\n  // so we can use Infinity as the end column.\n  afterEndMapping.line === null || // If these don't match, it means that the call to\n  // 'generatedPositionFor' didn't find any other original mappings on\n  // the line we gave, so consider the binding to extend to infinity.\n  sourceMap.originalPositionFor(afterEndMapping).line !== beforeEndMapping.line) {\n    return {\n      source: beforeEndMapping.source,\n      line: beforeEndMapping.line,\n      column: Infinity\n    };\n  } // Convert the end mapping into the real original position.\n\n\n  return sourceMap.originalPositionFor(afterEndMapping);\n}\n/**\n * Attempts to determine the original source position, first\n * returning the closest element to the left (GREATEST_LOWER_BOUND),\n * and next returning the closest element to the right (LEAST_UPPER_BOUND).\n */\n\n\nfunction originalPositionTryBoth(sourceMap, line, column) {\n  const mapping = sourceMap.originalPositionFor({\n    line,\n    column,\n    bias: GREATEST_LOWER_BOUND\n  });\n\n  if (mapping.source === null) {\n    return sourceMap.originalPositionFor({\n      line,\n      column,\n      bias: LEAST_UPPER_BOUND\n    });\n  } else {\n    return mapping;\n  }\n}\n\nfunction isInvalidPosition(pos) {\n  return !pos || typeof pos.line !== 'number' || typeof pos.column !== 'number' || pos.line < 0 || pos.column < 0;\n}\n/**\n * determines the original position for a given location\n * @param  {SourceMapConsumer} sourceMap the source map\n * @param  {Object} generatedLocation the original location Object\n * @returns {Object} the remapped location Object\n */\n\n\nfunction getMapping(sourceMap, generatedLocation, origFile) {\n  if (!generatedLocation) {\n    return null;\n  }\n\n  if (isInvalidPosition(generatedLocation.start) || isInvalidPosition(generatedLocation.end)) {\n    return null;\n  }\n\n  const start = originalPositionTryBoth(sourceMap, generatedLocation.start.line, generatedLocation.start.column);\n  let end = originalEndPositionFor(sourceMap, generatedLocation.end);\n  /* istanbul ignore if: edge case too hard to test for */\n\n  if (!(start && end)) {\n    return null;\n  }\n\n  if (!(start.source && end.source)) {\n    return null;\n  }\n\n  if (start.source !== end.source) {\n    return null;\n  }\n  /* istanbul ignore if: edge case too hard to test for */\n\n\n  if (start.line === null || start.column === null) {\n    return null;\n  }\n  /* istanbul ignore if: edge case too hard to test for */\n\n\n  if (end.line === null || end.column === null) {\n    return null;\n  }\n\n  if (start.line === end.line && start.column === end.column) {\n    end = sourceMap.originalPositionFor({\n      line: generatedLocation.end.line,\n      column: generatedLocation.end.column,\n      bias: LEAST_UPPER_BOUND\n    });\n    end.column -= 1;\n  }\n\n  return {\n    source: pathutils.relativeTo(start.source, origFile),\n    loc: {\n      start: {\n        line: start.line,\n        column: start.column\n      },\n      end: {\n        line: end.line,\n        column: end.column\n      }\n    }\n  };\n}\n\nmodule.exports = getMapping;","map":null,"metadata":{},"sourceType":"script"}