{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _v() {\n  const data = _interopRequireDefault(require('v8'));\n\n  _v = function _v() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _vm() {\n  const data = _interopRequireDefault(require('vm'));\n\n  _vm = function _vm() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _prettyFormat() {\n  const data = _interopRequireDefault(require('pretty-format'));\n\n  _prettyFormat = function _prettyFormat() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestGetType() {\n  const data = require('jest-get-type');\n\n  _jestGetType = function _jestGetType() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass _default {\n  constructor(value) {\n    _defineProperty(this, '_isReferenceBeingHeld', void 0);\n\n    if ((0, _jestGetType().isPrimitive)(value)) {\n      throw new TypeError(['Primitives cannot leak memory.', 'You passed a ' + typeof value + ': <' + (0, _prettyFormat().default)(value) + '>'].join(' '));\n    }\n\n    let weak;\n\n    try {\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      weak = require('weak');\n    } catch (err) {\n      if (!err || err.code !== 'MODULE_NOT_FOUND') {\n        throw err;\n      }\n\n      throw new Error('The leaking detection mechanism requires the \"weak\" package to be installed and work. ' + 'Please install it as a dependency on your main project');\n    }\n\n    weak(value, () => this._isReferenceBeingHeld = false);\n    this._isReferenceBeingHeld = true; // Ensure value is not leaked by the closure created by the \"weak\" callback.\n\n    value = null;\n  }\n\n  isLeaking() {\n    this._runGarbageCollector();\n\n    return this._isReferenceBeingHeld;\n  }\n\n  _runGarbageCollector() {\n    const isGarbageCollectorHidden = !global.gc; // GC is usually hidden, so we have to expose it before running.\n\n    _v().default.setFlagsFromString('--expose-gc');\n\n    _vm().default.runInNewContext('gc')(); // The GC was not initially exposed, so let's hide it again.\n\n\n    if (isGarbageCollectorHidden) {\n      _v().default.setFlagsFromString('--no-expose-gc');\n    }\n  }\n\n}\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}