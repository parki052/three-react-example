{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function _micromatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolveDependencies() {\n  const data = _interopRequireDefault(require('jest-resolve-dependencies'));\n\n  _jestResolveDependencies = function _jestResolveDependencies() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function _jestConfig() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst globsToMatcher = globs => path => _micromatch().default.some((0, _jestUtil().replacePathSepForGlob)(path), globs, {\n  dot: true\n});\n\nconst regexToMatcher = testRegex => path => testRegex.some(testRegex => new RegExp(testRegex).test(path));\n\nconst toTests = (context, tests) => tests.map(path => ({\n  context,\n  duration: undefined,\n  path\n}));\n\nclass SearchSource {\n  constructor(context) {\n    _defineProperty(this, '_context', void 0);\n\n    _defineProperty(this, '_testPathCases', []);\n\n    const config = context.config;\n    this._context = context;\n    const rootPattern = new RegExp(config.roots.map(dir => (0, _jestRegexUtil().escapePathForRegex)(dir + _path().default.sep)).join('|'));\n\n    this._testPathCases.push({\n      isMatch: path => rootPattern.test(path),\n      stat: 'roots'\n    });\n\n    if (config.testMatch.length) {\n      this._testPathCases.push({\n        isMatch: globsToMatcher(config.testMatch),\n        stat: 'testMatch'\n      });\n    }\n\n    if (config.testPathIgnorePatterns.length) {\n      const testIgnorePatternsRegex = new RegExp(config.testPathIgnorePatterns.join('|'));\n\n      this._testPathCases.push({\n        isMatch: path => !testIgnorePatternsRegex.test(path),\n        stat: 'testPathIgnorePatterns'\n      });\n    }\n\n    if (config.testRegex.length) {\n      this._testPathCases.push({\n        isMatch: regexToMatcher(config.testRegex),\n        stat: 'testRegex'\n      });\n    }\n  }\n\n  _filterTestPathsWithStats(allPaths, testPathPattern) {\n    const data = {\n      stats: {\n        roots: 0,\n        testMatch: 0,\n        testPathIgnorePatterns: 0,\n        testRegex: 0\n      },\n      tests: [],\n      total: allPaths.length\n    };\n    const testCases = Array.from(this._testPathCases); // clone\n\n    if (testPathPattern) {\n      const regex = (0, _jestUtil().testPathPatternToRegExp)(testPathPattern);\n      testCases.push({\n        isMatch: path => regex.test(path),\n        stat: 'testPathPattern'\n      });\n      data.stats.testPathPattern = 0;\n    }\n\n    data.tests = allPaths.filter(test => {\n      let filterResult = true;\n\n      for (var _i = 0; _i < testCases.length; _i++) {\n        const _testCases$_i = testCases[_i],\n              isMatch = _testCases$_i.isMatch,\n              stat = _testCases$_i.stat;\n\n        if (isMatch(test.path)) {\n          data.stats[stat]++;\n        } else {\n          filterResult = false;\n        }\n      }\n\n      return filterResult;\n    });\n    return data;\n  }\n\n  _getAllTestPaths(testPathPattern) {\n    return this._filterTestPathsWithStats(toTests(this._context, this._context.hasteFS.getAllFiles()), testPathPattern);\n  }\n\n  isTestFilePath(path) {\n    return this._testPathCases.every(testCase => testCase.isMatch(path));\n  }\n\n  findMatchingTests(testPathPattern) {\n    return this._getAllTestPaths(testPathPattern);\n  }\n\n  findRelatedTests(allPaths, collectCoverage) {\n    const dependencyResolver = new (_jestResolveDependencies().default)(this._context.resolver, this._context.hasteFS, (0, _jestSnapshot().buildSnapshotResolver)(this._context.config));\n\n    if (!collectCoverage) {\n      return {\n        tests: toTests(this._context, dependencyResolver.resolveInverse(allPaths, this.isTestFilePath.bind(this), {\n          skipNodeResolution: this._context.config.skipNodeResolution\n        }))\n      };\n    }\n\n    const testModulesMap = dependencyResolver.resolveInverseModuleMap(allPaths, this.isTestFilePath.bind(this), {\n      skipNodeResolution: this._context.config.skipNodeResolution\n    });\n    const allPathsAbsolute = Array.from(allPaths).map(p => _path().default.resolve(p));\n    const collectCoverageFrom = new Set();\n    testModulesMap.forEach(testModule => {\n      if (!testModule.dependencies) {\n        return;\n      }\n\n      testModule.dependencies.filter(p => allPathsAbsolute.includes(p)).map(filename => {\n        filename = (0, _jestConfig().replaceRootDirInPath)(this._context.config.rootDir, filename);\n        return _path().default.isAbsolute(filename) ? _path().default.relative(this._context.config.rootDir, filename) : filename;\n      }).forEach(filename => collectCoverageFrom.add(filename));\n    });\n    return {\n      collectCoverageFrom,\n      tests: toTests(this._context, testModulesMap.map(testModule => testModule.file))\n    };\n  }\n\n  findTestsByPaths(paths) {\n    return {\n      tests: toTests(this._context, paths.map(p => _path().default.resolve(this._context.config.cwd, p)).filter(this.isTestFilePath.bind(this)))\n    };\n  }\n\n  findRelatedTestsFromPattern(paths, collectCoverage) {\n    if (Array.isArray(paths) && paths.length) {\n      const resolvedPaths = paths.map(p => _path().default.resolve(this._context.config.cwd, p));\n      return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);\n    }\n\n    return {\n      tests: []\n    };\n  }\n\n  findTestRelatedToChangedFiles(changedFilesInfo, collectCoverage) {\n    const repos = changedFilesInfo.repos,\n          changedFiles = changedFilesInfo.changedFiles; // no SCM (git/hg/...) is found in any of the roots.\n\n    const noSCM = Object.keys(repos).every(scm => repos[scm].size === 0);\n    return noSCM ? {\n      noSCM: true,\n      tests: []\n    } : this.findRelatedTests(changedFiles, collectCoverage);\n  }\n\n  _getTestPaths(globalConfig, changedFiles) {\n    const paths = globalConfig.nonFlagArgs;\n\n    if (globalConfig.onlyChanged) {\n      if (!changedFiles) {\n        throw new Error('Changed files must be set when running with -o.');\n      }\n\n      return this.findTestRelatedToChangedFiles(changedFiles, globalConfig.collectCoverage);\n    } else if (globalConfig.runTestsByPath && paths && paths.length) {\n      return this.findTestsByPaths(paths);\n    } else if (globalConfig.findRelatedTests && paths && paths.length) {\n      return this.findRelatedTestsFromPattern(paths, globalConfig.collectCoverage);\n    } else if (globalConfig.testPathPattern != null) {\n      return this.findMatchingTests(globalConfig.testPathPattern);\n    } else {\n      return {\n        tests: []\n      };\n    }\n  }\n\n  getTestPaths(globalConfig, changedFiles, filter) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const searchResult = _this._getTestPaths(globalConfig, changedFiles);\n\n      const filterPath = globalConfig.filter;\n\n      if (filter) {\n        const tests = searchResult.tests;\n        const filterResult = yield filter(tests.map(test => test.path));\n\n        if (!Array.isArray(filterResult.filtered)) {\n          throw new Error(\"Filter \".concat(filterPath, \" did not return a valid test list\"));\n        }\n\n        const filteredSet = new Set(filterResult.filtered.map(result => result.test));\n        return _objectSpread({}, searchResult, {\n          tests: tests.filter(test => filteredSet.has(test.path))\n        });\n      }\n\n      return searchResult;\n    })();\n  }\n\n}\n\nexports.default = SearchSource;","map":null,"metadata":{},"sourceType":"script"}