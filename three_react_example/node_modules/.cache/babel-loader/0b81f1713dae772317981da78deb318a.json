{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRunner() {\n  const data = _interopRequireDefault(require('jest-runner'));\n\n  _jestRunner = function _jestRunner() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _reporters() {\n  const data = require('@jest/reporters');\n\n  _reporters = function _reporters() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function _exit() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function _testResult() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ReporterDispatcher = _interopRequireDefault(require('./ReporterDispatcher'));\n\nvar _testSchedulerHelper = require('./testSchedulerHelper');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // The default jest-runner is required because it is the default test runner\n// and required implicitly through the `runner` ProjectConfig option.\n\n\n_jestRunner().default;\n\nclass TestScheduler {\n  constructor(globalConfig, options, context) {\n    _defineProperty(this, '_dispatcher', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_context', void 0);\n\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n    this._options = options;\n    this._context = context;\n\n    this._setupReporters();\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(ReporterClass) {\n    this._dispatcher.unregister(ReporterClass);\n  }\n\n  scheduleTests(tests, watcher) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const onStart = _this._dispatcher.onTestStart.bind(_this._dispatcher);\n\n      const timings = [];\n      const contexts = new Set();\n      tests.forEach(test => {\n        contexts.add(test.context);\n\n        if (test.duration) {\n          timings.push(test.duration);\n        }\n      });\n      const aggregatedResults = createAggregatedResults(tests.length);\n      const estimatedTime = Math.ceil(getEstimatedTime(timings, _this._globalConfig.maxWorkers) / 1000);\n      const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(tests, timings, _this._globalConfig);\n\n      const onResult =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(function* (test, testResult) {\n          if (watcher.isInterrupted()) {\n            return Promise.resolve();\n          }\n\n          if (testResult.testResults.length === 0) {\n            const message = 'Your test suite must contain at least one test.';\n            return onFailure(test, {\n              message,\n              stack: new Error(message).stack\n            });\n          } // Throws when the context is leaked after executing a test.\n\n\n          if (testResult.leaks) {\n            const message = _chalk().default.red.bold('EXPERIMENTAL FEATURE!\\n') + 'Your test suite is leaking memory. Please ensure all references are cleaned.\\n' + '\\n' + 'There is a number of things that can leak memory:\\n' + '  - Async operations that have not finished (e.g. fs.readFile).\\n' + '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' + '  - Keeping references to the global scope.';\n            return onFailure(test, {\n              message,\n              stack: new Error(message).stack\n            });\n          }\n\n          (0, _testResult().addResult)(aggregatedResults, testResult);\n          yield _this._dispatcher.onTestResult(test, testResult, aggregatedResults);\n          return _this._bailIfNeeded(contexts, aggregatedResults, watcher);\n        });\n\n        return function onResult(_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      const onFailure =\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(function* (test, error) {\n          if (watcher.isInterrupted()) {\n            return;\n          }\n\n          const testResult = (0, _testResult().buildFailureTestResult)(test.path, error);\n          testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(testResult.testExecError, test.context.config, _this._globalConfig, test.path);\n          (0, _testResult().addResult)(aggregatedResults, testResult);\n          yield _this._dispatcher.onTestResult(test, testResult, aggregatedResults);\n        });\n\n        return function onFailure(_x3, _x4) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      const updateSnapshotState = () => {\n        contexts.forEach(context => {\n          const status = _jestSnapshot().default.cleanup(context.hasteFS, _this._globalConfig.updateSnapshot, _jestSnapshot().default.buildSnapshotResolver(context.config), context.config.testPathIgnorePatterns);\n\n          aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n          aggregatedResults.snapshot.filesRemovedList = (aggregatedResults.snapshot.filesRemovedList || []).concat(status.filesRemovedList);\n        });\n        const updateAll = _this._globalConfig.updateSnapshot === 'all';\n        aggregatedResults.snapshot.didUpdate = updateAll;\n        aggregatedResults.snapshot.failure = !!(!updateAll && (aggregatedResults.snapshot.unchecked || aggregatedResults.snapshot.unmatched || aggregatedResults.snapshot.filesRemoved));\n      };\n\n      yield _this._dispatcher.onRunStart(aggregatedResults, {\n        estimatedTime,\n        showStatus: !runInBand\n      });\n      const testRunners = Object.create(null);\n      contexts.forEach(({\n        config\n      }) => {\n        if (!testRunners[config.runner]) {\n          const Runner = require(config.runner);\n\n          testRunners[config.runner] = new Runner(_this._globalConfig, {\n            changedFiles: _this._context && _this._context.changedFiles\n          });\n        }\n      });\n\n      const testsByRunner = _this._partitionTests(testRunners, tests);\n\n      if (testsByRunner) {\n        try {\n          var _arr = Object.keys(testRunners);\n\n          for (var _i = 0; _i < _arr.length; _i++) {\n            const runner = _arr[_i];\n            yield testRunners[runner].runTests(testsByRunner[runner], watcher, onStart, onResult, onFailure, {\n              serial: runInBand || Boolean(testRunners[runner].isSerial)\n            });\n          }\n        } catch (error) {\n          if (!watcher.isInterrupted()) {\n            throw error;\n          }\n        }\n      }\n\n      updateSnapshotState();\n      aggregatedResults.wasInterrupted = watcher.isInterrupted();\n      yield _this._dispatcher.onRunComplete(contexts, aggregatedResults);\n      const anyTestFailures = !(aggregatedResults.numFailedTests === 0 && aggregatedResults.numRuntimeErrorTestSuites === 0);\n\n      const anyReporterErrors = _this._dispatcher.hasErrors();\n\n      aggregatedResults.success = !(anyTestFailures || aggregatedResults.snapshot.failure || anyReporterErrors);\n      return aggregatedResults;\n    })();\n  }\n\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n\n  _shouldAddDefaultReporters(reporters) {\n    return !reporters || !!reporters.find(reporter => this._getReporterProps(reporter).path === 'default');\n  }\n\n  _setupReporters() {\n    const _this$_globalConfig = this._globalConfig,\n          collectCoverage = _this$_globalConfig.collectCoverage,\n          notify = _this$_globalConfig.notify,\n          reporters = _this$_globalConfig.reporters;\n\n    const isDefault = this._shouldAddDefaultReporters(reporters);\n\n    if (isDefault) {\n      this._setupDefaultReporters(collectCoverage);\n    }\n\n    if (!isDefault && collectCoverage) {\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {\n        changedFiles: this._context && this._context.changedFiles\n      }));\n    }\n\n    if (notify) {\n      this.addReporter(new (_reporters().NotifyReporter)(this._globalConfig, this._options.startRun, this._context));\n    }\n\n    if (reporters && Array.isArray(reporters)) {\n      this._addCustomReporters(reporters);\n    }\n  }\n\n  _setupDefaultReporters(collectCoverage) {\n    this.addReporter(this._globalConfig.verbose ? new (_reporters().VerboseReporter)(this._globalConfig) : new (_reporters().DefaultReporter)(this._globalConfig));\n\n    if (collectCoverage) {\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {\n        changedFiles: this._context && this._context.changedFiles\n      }));\n    }\n\n    this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));\n  }\n\n  _addCustomReporters(reporters) {\n    reporters.forEach(reporter => {\n      const _this$_getReporterPro = this._getReporterProps(reporter),\n            options = _this$_getReporterPro.options,\n            path = _this$_getReporterPro.path;\n\n      if (path === 'default') return;\n\n      try {\n        const Reporter = require(path);\n\n        this.addReporter(new Reporter(this._globalConfig, options));\n      } catch (error) {\n        throw new Error('An error occurred while adding the reporter at path \"' + path + '\".' + error.message);\n      }\n    });\n  }\n  /**\n   * Get properties of a reporter in an object\n   * to make dealing with them less painful.\n   */\n\n\n  _getReporterProps(reporter) {\n    if (typeof reporter === 'string') {\n      return {\n        options: this._options,\n        path: reporter\n      };\n    } else if (Array.isArray(reporter)) {\n      const _reporter = _slicedToArray(reporter, 2),\n            path = _reporter[0],\n            options = _reporter[1];\n\n      return {\n        options,\n        path\n      };\n    }\n\n    throw new Error('Reporter should be either a string or an array');\n  }\n\n  _bailIfNeeded(contexts, aggregatedResults, watcher) {\n    if (this._globalConfig.bail !== 0 && aggregatedResults.numFailedTests >= this._globalConfig.bail) {\n      if (watcher.isWatchMode()) {\n        watcher.setState({\n          interrupted: true\n        });\n      } else {\n        const failureExit = () => (0, _exit().default)(1);\n\n        return this._dispatcher.onRunComplete(contexts, aggregatedResults).then(failureExit).catch(failureExit);\n      }\n    }\n\n    return Promise.resolve();\n  }\n\n}\n\nexports.default = TestScheduler;\n\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings, workers) => {\n  if (!timings.length) {\n    return 0;\n  }\n\n  const max = Math.max.apply(null, timings);\n  return timings.length <= workers ? max : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};","map":null,"metadata":{},"sourceType":"script"}