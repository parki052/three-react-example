{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nObject.defineProperty(exports, 'ChangedFiles', {\n  enumerable: true,\n  get: function get() {\n    return _types.ChangedFiles;\n  }\n});\nObject.defineProperty(exports, 'ChangedFilesPromise', {\n  enumerable: true,\n  get: function get() {\n    return _types.ChangedFilesPromise;\n  }\n});\nexports.findRepos = exports.getChangedFilesForRoots = void 0;\n\nfunction _throat() {\n  const data = _interopRequireDefault(require('throat'));\n\n  _throat = function _throat() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _types = require('./types');\n\nvar _git = _interopRequireDefault(require('./git'));\n\nvar _hg = _interopRequireDefault(require('./hg'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction notEmpty(value) {\n  return value != null;\n} // This is an arbitrary number. The main goal is to prevent projects with\n// many roots (50+) from spawning too many processes at once.\n\n\nconst mutex = (0, _throat().default)(5);\n\nconst findGitRoot = dir => mutex(() => _git.default.getRoot(dir));\n\nconst findHgRoot = dir => mutex(() => _hg.default.getRoot(dir));\n\nconst getChangedFilesForRoots =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(function* (roots, options) {\n    const repos = yield findRepos(roots);\n\n    const changedFilesOptions = _objectSpread({\n      includePaths: roots\n    }, options);\n\n    const gitPromises = Array.from(repos.git).map(repo => _git.default.findChangedFiles(repo, changedFilesOptions));\n    const hgPromises = Array.from(repos.hg).map(repo => _hg.default.findChangedFiles(repo, changedFilesOptions));\n    const changedFiles = (yield Promise.all(gitPromises.concat(hgPromises))).reduce((allFiles, changedFilesInTheRepo) => {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = changedFilesInTheRepo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          const file = _step.value;\n          allFiles.add(file);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return allFiles;\n    }, new Set());\n    return {\n      changedFiles,\n      repos\n    };\n  });\n\n  return function getChangedFilesForRoots(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.getChangedFilesForRoots = getChangedFilesForRoots;\n\nconst findRepos =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(function* (roots) {\n    const gitRepos = yield Promise.all(roots.reduce((promises, root) => promises.concat(findGitRoot(root)), []));\n    const hgRepos = yield Promise.all(roots.reduce((promises, root) => promises.concat(findHgRoot(root)), []));\n    return {\n      git: new Set(gitRepos.filter(notEmpty)),\n      hg: new Set(hgRepos.filter(notEmpty))\n    };\n  });\n\n  return function findRepos(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.findRepos = findRepos;","map":null,"metadata":{},"sourceType":"script"}