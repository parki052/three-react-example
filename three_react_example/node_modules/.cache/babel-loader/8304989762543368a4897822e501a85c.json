{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getStringDiff = exports.printMultilineStringDiffs = exports.createPatchMark = exports.printAnnotation = exports.hasCommonDiff = exports.computeStringDiffs = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = exports.MULTILINE_REGEXP = exports.getReceivedString = exports.getExpectedString = exports.getHighlightedString = exports.RECEIVED_COLOR = exports.INVERTED_COLOR = exports.EXPECTED_COLOR = exports.DIM_COLOR = void 0;\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst DIM_COLOR = _chalk.default.dim;\nexports.DIM_COLOR = DIM_COLOR;\nconst EXPECTED_COLOR = _chalk.default.green;\nexports.EXPECTED_COLOR = EXPECTED_COLOR;\nconst INVERTED_COLOR = _chalk.default.inverse;\nexports.INVERTED_COLOR = INVERTED_COLOR;\nconst RECEIVED_COLOR = _chalk.default.red;\nexports.RECEIVED_COLOR = RECEIVED_COLOR;\nconst PATCH_COLOR = _chalk.default.yellow; // Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op (inverse highlight)\n// * exclude change strings which have opposite op\n\nconst getHighlightedString = (op, diffs) => diffs.reduce((reduced, diff) => reduced + (diff[0] === _cleanupSemantic.DIFF_EQUAL ? diff[1] : diff[0] === op ? INVERTED_COLOR(diff[1]) : ''), '');\n\nexports.getHighlightedString = getHighlightedString;\n\nconst getExpectedString = diffs => getHighlightedString(_cleanupSemantic.DIFF_DELETE, diffs);\n\nexports.getExpectedString = getExpectedString;\n\nconst getReceivedString = diffs => getHighlightedString(_cleanupSemantic.DIFF_INSERT, diffs);\n\nexports.getReceivedString = getReceivedString;\nconst MULTILINE_REGEXP = /\\n/;\nexports.MULTILINE_REGEXP = MULTILINE_REGEXP;\nconst NEWLINE_SYMBOL = '\\u{21B5}'; // downwards arrow with corner leftwards\n\nconst SPACE_SYMBOL = '\\u{00B7}'; // middle dot\n// Instead of inverse highlight which now implies a change,\n// replace common spaces with middle dot at the end of the line.\n\nconst replaceSpacesAtEnd = line => line.replace(/\\s+$/, spaces => SPACE_SYMBOL.repeat(spaces.length));\n\nconst printDeleteLine = line => EXPECTED_COLOR(line.length !== 0 ? '- ' + replaceSpacesAtEnd(line) : '-');\n\nexports.printDeleteLine = printDeleteLine;\n\nconst printInsertLine = line => RECEIVED_COLOR(line.length !== 0 ? '+ ' + replaceSpacesAtEnd(line) : '+'); // Prevent visually ambiguous empty line as the first or the last.\n\n\nexports.printInsertLine = printInsertLine;\n\nconst printCommonLine = (line, isFirstOrLast = false) => line.length !== 0 ? DIM_COLOR('  ' + replaceSpacesAtEnd(line)) : isFirstOrLast ? DIM_COLOR('  ' + NEWLINE_SYMBOL) : '';\n\nexports.printCommonLine = printCommonLine;\n\nconst computeStringDiffs = (expected, received) => {\n  const isMultiline = MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n  if (isMultiline) {\n    expected += '\\n';\n    received += '\\n';\n  }\n\n  const diffs = (0, _diffStrings.default)(expected, received);\n  (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n\n  return {\n    diffs,\n    isMultiline\n  };\n};\n\nexports.computeStringDiffs = computeStringDiffs;\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some((diff, i) => diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n'));\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\n\nexports.hasCommonDiff = hasCommonDiff;\n\nconst printAnnotation = options => EXPECTED_COLOR('- ' + (options && options.aAnnotation || 'Expected')) + '\\n' + RECEIVED_COLOR('+ ' + (options && options.bAnnotation || 'Received')) + '\\n\\n'; // In GNU diff format, indexes are one-based instead of zero-based.\n\n\nexports.printAnnotation = printAnnotation;\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd) => PATCH_COLOR(\"@@ -\".concat(aStart + 1, \",\").concat(aEnd - aStart, \" +\").concat(bStart + 1, \",\").concat(bEnd - bStart, \" @@\")); // Return formatted diff lines without labels.\n\n\nexports.createPatchMark = createPatchMark;\n\nconst printMultilineStringDiffs = (diffs, expand) => {\n  const lines = (0, _getAlignedDiffs.default)(diffs);\n  return expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(lines) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(lines);\n};\n\nexports.printMultilineStringDiffs = printMultilineStringDiffs;\nconst MAX_DIFF_STRING_LENGTH = 20000; // Print specific substring diff for strings only:\n// * if strings are not equal\n// * if neither string is empty\n// * if neither string is too long\n// * if there is a common string after semantic cleanup\n\nconst getStringDiff = (expected, received, options) => {\n  if (expected === received || expected.length === 0 || received.length === 0 || expected.length > MAX_DIFF_STRING_LENGTH || received.length > MAX_DIFF_STRING_LENGTH) {\n    return null;\n  }\n\n  const _computeStringDiffs = computeStringDiffs(expected, received),\n        diffs = _computeStringDiffs.diffs,\n        isMultiline = _computeStringDiffs.isMultiline;\n\n  if (!hasCommonDiff(diffs, isMultiline)) {\n    return null;\n  }\n\n  return isMultiline ? {\n    annotatedDiff: printAnnotation(options) + printMultilineStringDiffs(diffs, options === undefined || options.expand !== false),\n    isMultiline\n  } : {\n    a: getExpectedString(diffs),\n    b: getReceivedString(diffs),\n    isMultiline\n  };\n};\n\nexports.getStringDiff = getStringDiff;","map":null,"metadata":{},"sourceType":"script"}