{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _jestMessageUtil = require('jest-message-util');\n\nvar _utils = require('./utils');\n\nvar _inline_snapshots = require('./inline_snapshots');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestExistsFile = global[Symbol.for('jest-native-exists-file')] || _fs.default.existsSync;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass SnapshotState {\n  // @ts-ignore\n  constructor(snapshotPath, options) {\n    _defineProperty(this, '_counters', void 0);\n\n    _defineProperty(this, '_dirty', void 0);\n\n    _defineProperty(this, '_index', void 0);\n\n    _defineProperty(this, '_updateSnapshot', void 0);\n\n    _defineProperty(this, '_snapshotData', void 0);\n\n    _defineProperty(this, '_initialData', void 0);\n\n    _defineProperty(this, '_snapshotPath', void 0);\n\n    _defineProperty(this, '_inlineSnapshots', void 0);\n\n    _defineProperty(this, '_uncheckedKeys', void 0);\n\n    _defineProperty(this, '_getBabelTraverse', void 0);\n\n    _defineProperty(this, '_getPrettier', void 0);\n\n    _defineProperty(this, 'added', void 0);\n\n    _defineProperty(this, 'expand', void 0);\n\n    _defineProperty(this, 'matched', void 0);\n\n    _defineProperty(this, 'unmatched', void 0);\n\n    _defineProperty(this, 'updated', void 0);\n\n    this._snapshotPath = snapshotPath;\n\n    const _getSnapshotData = (0, _utils.getSnapshotData)(this._snapshotPath, options.updateSnapshot),\n          data = _getSnapshotData.data,\n          dirty = _getSnapshotData.dirty;\n\n    this._initialData = data;\n    this._snapshotData = data;\n    this._dirty = dirty;\n    this._getBabelTraverse = options.getBabelTraverse;\n    this._getPrettier = options.getPrettier;\n    this._inlineSnapshots = [];\n    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));\n    this._counters = new Map();\n    this._index = 0;\n    this.expand = options.expand || false;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this._updateSnapshot = options.updateSnapshot;\n    this.updated = 0;\n  }\n\n  markSnapshotsAsCheckedForTest(testName) {\n    this._uncheckedKeys.forEach(uncheckedKey => {\n      if ((0, _utils.keyToTestName)(uncheckedKey) === testName) {\n        this._uncheckedKeys.delete(uncheckedKey);\n      }\n    });\n  }\n\n  _addSnapshot(key, receivedSerialized, options) {\n    this._dirty = true;\n\n    if (options.isInline) {\n      const error = options.error || new Error();\n      const lines = (0, _jestMessageUtil.getStackTraceLines)(error.stack || '');\n      const frame = (0, _jestMessageUtil.getTopFrame)(lines);\n\n      if (!frame) {\n        throw new Error(\"Jest: Couldn't infer stack frame for inline snapshot.\");\n      }\n\n      this._inlineSnapshots.push({\n        frame,\n        snapshot: receivedSerialized\n      });\n    } else {\n      this._snapshotData[key] = receivedSerialized;\n    }\n  }\n\n  clear() {\n    this._snapshotData = this._initialData;\n    this._inlineSnapshots = [];\n    this._counters = new Map();\n    this._index = 0;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this.updated = 0;\n  }\n\n  save() {\n    const hasExternalSnapshots = Object.keys(this._snapshotData).length;\n    const hasInlineSnapshots = this._inlineSnapshots.length;\n    const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots;\n    const status = {\n      deleted: false,\n      saved: false\n    };\n\n    if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {\n      if (hasExternalSnapshots) {\n        (0, _utils.saveSnapshotFile)(this._snapshotData, this._snapshotPath);\n      }\n\n      if (hasInlineSnapshots) {\n        const prettier = this._getPrettier(); // Load lazily\n\n\n        const babelTraverse = this._getBabelTraverse(); // Load lazily\n\n\n        (0, _inline_snapshots.saveInlineSnapshots)(this._inlineSnapshots, prettier, babelTraverse);\n      }\n\n      status.saved = true;\n    } else if (!hasExternalSnapshots && jestExistsFile(this._snapshotPath)) {\n      if (this._updateSnapshot === 'all') {\n        _fs.default.unlinkSync(this._snapshotPath);\n      }\n\n      status.deleted = true;\n    }\n\n    return status;\n  }\n\n  getUncheckedCount() {\n    return this._uncheckedKeys.size || 0;\n  }\n\n  getUncheckedKeys() {\n    return Array.from(this._uncheckedKeys);\n  }\n\n  removeUncheckedKeys() {\n    if (this._updateSnapshot === 'all' && this._uncheckedKeys.size) {\n      this._dirty = true;\n\n      this._uncheckedKeys.forEach(key => delete this._snapshotData[key]);\n\n      this._uncheckedKeys.clear();\n    }\n  }\n\n  match({\n    testName,\n    received,\n    key,\n    inlineSnapshot,\n    error\n  }) {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n\n    const count = Number(this._counters.get(testName));\n    const isInline = inlineSnapshot !== undefined;\n\n    if (!key) {\n      key = (0, _utils.testNameToKey)(testName, count);\n    } // Do not mark the snapshot as \"checked\" if the snapshot is inline and\n    // there's an external snapshot. This way the external snapshot can be\n    // removed with `--updateSnapshot`.\n\n\n    if (!(isInline && this._snapshotData[key])) {\n      this._uncheckedKeys.delete(key);\n    }\n\n    const receivedSerialized = (0, _utils.serialize)(received);\n    const expected = isInline ? inlineSnapshot : this._snapshotData[key];\n    const pass = expected === receivedSerialized;\n    const hasSnapshot = isInline ? inlineSnapshot !== '' : this._snapshotData[key] !== undefined;\n\n    const snapshotIsPersisted = isInline || _fs.default.existsSync(this._snapshotPath);\n\n    if (pass && !isInline) {\n      // Executing a snapshot file as JavaScript and writing the strings back\n      // when other snapshots have changed loses the proper escaping for some\n      // characters. Since we check every snapshot in every test, use the newly\n      // generated formatted string.\n      // Note that this is only relevant when a snapshot is added and the dirty\n      // flag is set.\n      this._snapshotData[key] = receivedSerialized;\n    } // These are the conditions on when to write snapshots:\n    //  * There's no snapshot file in a non-CI environment.\n    //  * There is a snapshot file and we decided to update the snapshot.\n    //  * There is a snapshot file, but it doesn't have this snaphsot.\n    // These are the conditions on when not to write snapshots:\n    //  * The update flag is set to 'none'.\n    //  * There's no snapshot file or a file without this snapshot on a CI environment.\n\n\n    if (hasSnapshot && this._updateSnapshot === 'all' || (!hasSnapshot || !snapshotIsPersisted) && (this._updateSnapshot === 'new' || this._updateSnapshot === 'all')) {\n      if (this._updateSnapshot === 'all') {\n        if (!pass) {\n          if (hasSnapshot) {\n            this.updated++;\n          } else {\n            this.added++;\n          }\n\n          this._addSnapshot(key, receivedSerialized, {\n            error,\n            isInline\n          });\n        } else {\n          this.matched++;\n        }\n      } else {\n        this._addSnapshot(key, receivedSerialized, {\n          error,\n          isInline\n        });\n\n        this.added++;\n      }\n\n      return {\n        actual: '',\n        count,\n        expected: '',\n        key,\n        pass: true\n      };\n    } else {\n      if (!pass) {\n        this.unmatched++;\n        return {\n          actual: (0, _utils.unescape)(receivedSerialized),\n          count,\n          expected: expected ? (0, _utils.unescape)(expected) : null,\n          key,\n          pass: false\n        };\n      } else {\n        this.matched++;\n        return {\n          actual: '',\n          count,\n          expected: '',\n          key,\n          pass: true\n        };\n      }\n    }\n  }\n\n  fail(testName, _received, key) {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n\n    const count = Number(this._counters.get(testName));\n\n    if (!key) {\n      key = (0, _utils.testNameToKey)(testName, count);\n    }\n\n    this._uncheckedKeys.delete(key);\n\n    this.unmatched++;\n    return key;\n  }\n\n}\n\nexports.default = SnapshotState;","map":null,"metadata":{},"sourceType":"script"}