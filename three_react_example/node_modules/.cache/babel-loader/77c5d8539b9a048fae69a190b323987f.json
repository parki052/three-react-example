{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stringLength() {\n  const data = _interopRequireDefault(require('string-length'));\n\n  _stringLength = function _stringLength() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst RUNNING_TEXT = ' RUNS ';\nconst RUNNING = _chalk().default.reset.inverse.yellow.bold(RUNNING_TEXT) + ' ';\n/**\n * This class is a perf optimization for sorting the list of currently\n * running tests. It tries to keep tests in the same positions without\n * shifting the whole list.\n */\n\nclass CurrentTestList {\n  constructor() {\n    _defineProperty(this, '_array', void 0);\n\n    this._array = [];\n  }\n\n  add(testPath, config) {\n    const index = this._array.indexOf(null);\n\n    const record = {\n      config,\n      testPath\n    };\n\n    if (index !== -1) {\n      this._array[index] = record;\n    } else {\n      this._array.push(record);\n    }\n  }\n\n  delete(testPath) {\n    const record = this._array.find(record => record !== null && record.testPath === testPath);\n\n    this._array[this._array.indexOf(record || null)] = null;\n  }\n\n  get() {\n    return this._array;\n  }\n\n}\n/**\n * A class that generates the CLI status of currently running tests\n * and also provides an ANSI escape sequence to remove status lines\n * from the terminal.\n */\n\n\nclass Status {\n  constructor() {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_callback', void 0);\n\n    _defineProperty(this, '_currentTests', void 0);\n\n    _defineProperty(this, '_done', void 0);\n\n    _defineProperty(this, '_emitScheduled', void 0);\n\n    _defineProperty(this, '_estimatedTime', void 0);\n\n    _defineProperty(this, '_interval', void 0);\n\n    _defineProperty(this, '_aggregatedResults', void 0);\n\n    _defineProperty(this, '_showStatus', void 0);\n\n    this._cache = null;\n    this._currentTests = new CurrentTestList();\n    this._done = false;\n    this._emitScheduled = false;\n    this._estimatedTime = 0;\n    this._showStatus = false;\n  }\n\n  onChange(callback) {\n    this._callback = callback;\n  }\n\n  runStarted(aggregatedResults, options) {\n    this._estimatedTime = options && options.estimatedTime || 0;\n    this._showStatus = options && options.showStatus;\n    this._interval = setInterval(() => this._tick(), 1000);\n    this._aggregatedResults = aggregatedResults;\n\n    this._debouncedEmit();\n  }\n\n  runFinished() {\n    this._done = true;\n    if (this._interval) clearInterval(this._interval);\n\n    this._emit();\n  }\n\n  testStarted(testPath, config) {\n    this._currentTests.add(testPath, config);\n\n    if (!this._showStatus) {\n      this._emit();\n    } else {\n      this._debouncedEmit();\n    }\n  }\n\n  testFinished(_config, testResult, aggregatedResults) {\n    const testFilePath = testResult.testFilePath;\n    this._aggregatedResults = aggregatedResults;\n\n    this._currentTests.delete(testFilePath);\n\n    this._debouncedEmit();\n  }\n\n  get() {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    if (this._done) {\n      return {\n        clear: '',\n        content: ''\n      };\n    }\n\n    const width = process.stdout.columns;\n    let content = '\\n';\n\n    this._currentTests.get().forEach(record => {\n      if (record) {\n        const config = record.config,\n              testPath = record.testPath;\n        const projectDisplayName = config.displayName ? (0, _utils.printDisplayName)(config) + ' ' : '';\n        const prefix = RUNNING + projectDisplayName;\n        content += (0, _utils.wrapAnsiString)(prefix + (0, _utils.trimAndFormatPath)((0, _stringLength().default)(prefix), config, testPath, width), width) + '\\n';\n      }\n    });\n\n    if (this._showStatus && this._aggregatedResults) {\n      content += '\\n' + (0, _utils.getSummary)(this._aggregatedResults, {\n        estimatedTime: this._estimatedTime,\n        roundTime: true,\n        width\n      });\n    }\n\n    let height = 0;\n\n    for (let i = 0; i < content.length; i++) {\n      if (content[i] === '\\n') {\n        height++;\n      }\n    }\n\n    const clear = '\\r\\x1B[K\\r\\x1B[1A'.repeat(height);\n    return this._cache = {\n      clear,\n      content\n    };\n  }\n\n  _emit() {\n    this._cache = null;\n    if (this._callback) this._callback();\n  }\n\n  _debouncedEmit() {\n    if (!this._emitScheduled) {\n      // Perf optimization to avoid two separate renders When\n      // one test finishes and another test starts executing.\n      this._emitScheduled = true;\n      setTimeout(() => {\n        this._emit();\n\n        this._emitScheduled = false;\n      }, 100);\n    }\n  }\n\n  _tick() {\n    this._debouncedEmit();\n  }\n\n}\n\nexports.default = Status;","map":null,"metadata":{},"sourceType":"script"}