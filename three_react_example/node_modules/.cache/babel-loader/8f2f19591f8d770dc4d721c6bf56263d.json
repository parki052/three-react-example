{"ast":null,"code":"'use strict';\n\nvar _types = require('../types');\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nprocess.on('message', request => {\n  switch (request[0]) {\n    case _types.CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      break;\n\n    case _types.CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types.CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError('Unexpected request from parent process: ' + request[0]);\n  }\n});\n\nfunction reportSuccess(result) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  process.send([_types.PARENT_MESSAGE_OK, result]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  process.send([type, error.constructor && error.constructor.name, error.message, error.stack, typeof error === 'object' ? _objectSpread({}, error) : error]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  process.exit(0);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (result && typeof result.then === 'function') {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}