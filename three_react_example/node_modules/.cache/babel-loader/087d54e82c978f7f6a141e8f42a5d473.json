{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _pEachSeries() {\n  const data = _interopRequireDefault(require('p-each-series'));\n\n  _pEachSeries = function _pEachSeries() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function _transform() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar _default =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(function* ({\n    allTests,\n    globalConfig,\n    moduleName\n  }) {\n    const globalModulePaths = new Set(allTests.map(test => test.context.config[moduleName]));\n\n    if (globalConfig[moduleName]) {\n      globalModulePaths.add(globalConfig[moduleName]);\n    }\n\n    if (globalModulePaths.size > 0) {\n      yield (0, _pEachSeries().default)(Array.from(globalModulePaths),\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(function* (modulePath) {\n          if (!modulePath) {\n            return;\n          }\n\n          const correctConfig = allTests.find(t => t.context.config[moduleName] === modulePath);\n          const projectConfig = correctConfig ? correctConfig.context.config // Fallback to first config\n          : allTests[0].context.config;\n          const transformer = new (_transform().ScriptTransformer)(projectConfig);\n          yield transformer.requireAndTranspileModule(modulePath,\n          /*#__PURE__*/\n          function () {\n            var _ref3 = _asyncToGenerator(function* (m) {\n              const globalModule = (0, _jestUtil().interopRequireDefault)(m).default;\n\n              if (typeof globalModule !== 'function') {\n                throw new TypeError(\"\".concat(moduleName, \" file must export a function at \").concat(modulePath));\n              }\n\n              yield globalModule(globalConfig);\n            });\n\n            return function (_x3) {\n              return _ref3.apply(this, arguments);\n            };\n          }());\n        });\n\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }\n\n    return Promise.resolve();\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}