{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _jestMessageUtil = require('jest-message-util');\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass Jasmine2Reporter {\n  constructor(globalConfig, config, testPath) {\n    _defineProperty(this, '_testResults', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_currentSuites', void 0);\n\n    _defineProperty(this, '_resolve', void 0);\n\n    _defineProperty(this, '_resultsPromise', void 0);\n\n    _defineProperty(this, '_startTimes', void 0);\n\n    _defineProperty(this, '_testPath', void 0);\n\n    this._globalConfig = globalConfig;\n    this._config = config;\n    this._testPath = testPath;\n    this._testResults = [];\n    this._currentSuites = [];\n    this._resolve = null;\n    this._resultsPromise = new Promise(resolve => this._resolve = resolve);\n    this._startTimes = new Map();\n  }\n\n  jasmineStarted(_runDetails) {}\n\n  specStarted(spec) {\n    this._startTimes.set(spec.id, jestNow());\n  }\n\n  specDone(result) {\n    this._testResults.push(this._extractSpecResults(result, this._currentSuites.slice(0)));\n  }\n\n  suiteStarted(suite) {\n    this._currentSuites.push(suite.description);\n  }\n\n  suiteDone(_result) {\n    this._currentSuites.pop();\n  }\n\n  jasmineDone(_runDetails) {\n    let numFailingTests = 0;\n    let numPassingTests = 0;\n    let numPendingTests = 0;\n    let numTodoTests = 0;\n    const testResults = this._testResults;\n    testResults.forEach(testResult => {\n      if (testResult.status === 'failed') {\n        numFailingTests++;\n      } else if (testResult.status === 'pending') {\n        numPendingTests++;\n      } else if (testResult.status === 'todo') {\n        numTodoTests++;\n      } else {\n        numPassingTests++;\n      }\n    });\n    const testResult = {\n      console: null,\n      failureMessage: (0, _jestMessageUtil.formatResultsErrors)(testResults, this._config, this._globalConfig, this._testPath),\n      numFailingTests,\n      numPassingTests,\n      numPendingTests,\n      numTodoTests,\n      perfStats: {\n        end: 0,\n        start: 0\n      },\n      snapshot: {\n        added: 0,\n        fileDeleted: false,\n        matched: 0,\n        unchecked: 0,\n        unmatched: 0,\n        updated: 0\n      },\n      testFilePath: this._testPath,\n      testResults\n    };\n\n    this._resolve(testResult);\n  }\n\n  getResults() {\n    return this._resultsPromise;\n  }\n\n  _addMissingMessageToStack(stack, message) {\n    // Some errors (e.g. Angular injection error) don't prepend error.message\n    // to stack, instead the first line of the stack is just plain 'Error'\n    const ERROR_REGEX = /^Error:?\\s*\\n/;\n\n    if (stack && message && !stack.includes(message)) {\n      return message + stack.replace(ERROR_REGEX, '\\n');\n    }\n\n    return stack;\n  }\n\n  _extractSpecResults(specResult, ancestorTitles) {\n    const start = this._startTimes.get(specResult.id);\n\n    const duration = start ? jestNow() - start : undefined;\n    const status = specResult.status === 'disabled' ? 'pending' : specResult.status;\n    const location = specResult.__callsite ? {\n      column: specResult.__callsite.getColumnNumber(),\n      line: specResult.__callsite.getLineNumber()\n    } : null;\n    const results = {\n      ancestorTitles,\n      duration,\n      failureMessages: [],\n      fullName: specResult.fullName,\n      location,\n      numPassingAsserts: 0,\n      // Jasmine2 only returns an array of failed asserts.\n      status,\n      title: specResult.description\n    };\n    specResult.failedExpectations.forEach(failed => {\n      const message = !failed.matcherName && failed.stack ? this._addMissingMessageToStack(failed.stack, failed.message) : failed.message || '';\n      results.failureMessages.push(message);\n    });\n    return results;\n  }\n\n}\n\nexports.default = Jasmine2Reporter;","map":null,"metadata":{},"sourceType":"script"}