{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst MS_IN_A_YEAR = 31536000000; // TODO: Copied from `jest-util` to avoid cyclic dependency. Import from `jest-util` in the next major\n\nconst setGlobal = (globalToMutate, key, value) => {\n  // @ts-ignore: no index\n  globalToMutate[key] = value;\n};\n\nclass FakeTimers {\n  constructor({\n    global,\n    moduleMocker,\n    timerConfig,\n    config,\n    maxLoops\n  }) {\n    _defineProperty(this, '_cancelledImmediates', void 0);\n\n    _defineProperty(this, '_cancelledTicks', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_disposed', void 0);\n\n    _defineProperty(this, '_fakeTimerAPIs', void 0);\n\n    _defineProperty(this, '_global', void 0);\n\n    _defineProperty(this, '_immediates', void 0);\n\n    _defineProperty(this, '_maxLoops', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_now', void 0);\n\n    _defineProperty(this, '_ticks', void 0);\n\n    _defineProperty(this, '_timerAPIs', void 0);\n\n    _defineProperty(this, '_timers', void 0);\n\n    _defineProperty(this, '_uuidCounter', void 0);\n\n    _defineProperty(this, '_timerConfig', void 0);\n\n    this._global = global;\n    this._timerConfig = timerConfig;\n    this._config = config;\n    this._maxLoops = maxLoops || 100000;\n    this._uuidCounter = 1;\n    this._moduleMocker = moduleMocker; // Store original timer APIs for future reference\n\n    this._timerAPIs = {\n      clearImmediate: global.clearImmediate,\n      clearInterval: global.clearInterval,\n      clearTimeout: global.clearTimeout,\n      nextTick: global.process && global.process.nextTick,\n      setImmediate: global.setImmediate,\n      setInterval: global.setInterval,\n      setTimeout: global.setTimeout\n    };\n    this.reset();\n\n    this._createMocks();\n  }\n\n  clearAllTimers() {\n    this._immediates.forEach(immediate => this._fakeClearImmediate(immediate.uuid));\n\n    this._timers.clear();\n  }\n\n  dispose() {\n    this._disposed = true;\n    this.clearAllTimers();\n  }\n\n  reset() {\n    this._cancelledTicks = {};\n    this._cancelledImmediates = {};\n    this._now = 0;\n    this._ticks = [];\n    this._immediates = [];\n    this._timers = new Map();\n  }\n\n  runAllTicks() {\n    this._checkFakeTimers(); // Only run a generous number of ticks and then bail.\n    // This is just to help avoid recursive loops\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const tick = this._ticks.shift();\n\n      if (tick === undefined) {\n        break;\n      }\n\n      if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledTicks[tick.uuid] = true;\n        tick.callback();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' ticks, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runAllImmediates() {\n    this._checkFakeTimers(); // Only run a generous number of immediates and then bail.\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const immediate = this._immediates.shift();\n\n      if (immediate === undefined) {\n        break;\n      }\n\n      this._runImmediate(immediate);\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' immediates, and there are still more! Assuming ' + \"we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  _runImmediate(immediate) {\n    if (!this._cancelledImmediates.hasOwnProperty(immediate.uuid)) {\n      // Callback may throw, so update the map prior calling.\n      this._cancelledImmediates[immediate.uuid] = true;\n      immediate.callback();\n    }\n  }\n\n  runAllTimers() {\n    this._checkFakeTimers();\n\n    this.runAllTicks();\n    this.runAllImmediates(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const nextTimerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n\n      if (nextTimerHandle === null) {\n        break;\n      }\n\n      this._runTimerHandle(nextTimerHandle); // Some of the immediate calls could be enqueued\n      // during the previous handling of the timers, we should\n      // run them as well.\n\n\n      if (this._immediates.length) {\n        this.runAllImmediates();\n      }\n\n      if (this._ticks.length) {\n        this.runAllTicks();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runOnlyPendingTimers() {\n    // We need to hold the current shape of `this._timers` because existing\n    // timers can add new ones to the map and hence would run more than necessary.\n    // See https://github.com/facebook/jest/pull/4608 for details\n    const timerEntries = Array.from(this._timers.entries());\n\n    this._checkFakeTimers();\n\n    this._immediates.forEach(this._runImmediate, this);\n\n    timerEntries.sort(([, left], [, right]) => left.expiry - right.expiry).forEach(([timerHandle]) => this._runTimerHandle(timerHandle));\n  }\n\n  advanceTimersToNextTimer(steps = 1) {\n    if (steps < 1) {\n      return;\n    }\n\n    const nextExpiry = Array.from(this._timers.values()).reduce((minExpiry, timer) => {\n      if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;\n      return minExpiry;\n    }, null);\n\n    if (nextExpiry !== null) {\n      this.advanceTimersByTime(nextExpiry - this._now);\n      this.advanceTimersToNextTimer(steps - 1);\n    }\n  }\n\n  advanceTimersByTime(msToRun) {\n    this._checkFakeTimers(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const timerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n\n      if (timerHandle === null) {\n        break;\n      }\n\n      const timerValue = this._timers.get(timerHandle);\n\n      if (timerValue === undefined) {\n        break;\n      }\n\n      const nextTimerExpiry = timerValue.expiry;\n\n      if (this._now + msToRun < nextTimerExpiry) {\n        // There are no timers between now and the target we're running to, so\n        // adjust our time cursor and quit\n        this._now += msToRun;\n        break;\n      } else {\n        msToRun -= nextTimerExpiry - this._now;\n        this._now = nextTimerExpiry;\n\n        this._runTimerHandle(timerHandle);\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runWithRealTimers(cb) {\n    const prevClearImmediate = this._global.clearImmediate;\n    const prevClearInterval = this._global.clearInterval;\n    const prevClearTimeout = this._global.clearTimeout;\n    const prevNextTick = this._global.process.nextTick;\n    const prevSetImmediate = this._global.setImmediate;\n    const prevSetInterval = this._global.setInterval;\n    const prevSetTimeout = this._global.setTimeout;\n    this.useRealTimers();\n    let cbErr = null;\n    let errThrown = false;\n\n    try {\n      cb();\n    } catch (e) {\n      errThrown = true;\n      cbErr = e;\n    }\n\n    this._global.clearImmediate = prevClearImmediate;\n    this._global.clearInterval = prevClearInterval;\n    this._global.clearTimeout = prevClearTimeout;\n    this._global.process.nextTick = prevNextTick;\n    this._global.setImmediate = prevSetImmediate;\n    this._global.setInterval = prevSetInterval;\n    this._global.setTimeout = prevSetTimeout;\n\n    if (errThrown) {\n      throw cbErr;\n    }\n  }\n\n  useRealTimers() {\n    const global = this._global;\n    setGlobal(global, 'clearImmediate', this._timerAPIs.clearImmediate);\n    setGlobal(global, 'clearInterval', this._timerAPIs.clearInterval);\n    setGlobal(global, 'clearTimeout', this._timerAPIs.clearTimeout);\n    setGlobal(global, 'setImmediate', this._timerAPIs.setImmediate);\n    setGlobal(global, 'setInterval', this._timerAPIs.setInterval);\n    setGlobal(global, 'setTimeout', this._timerAPIs.setTimeout);\n    global.process.nextTick = this._timerAPIs.nextTick;\n  }\n\n  useFakeTimers() {\n    this._createMocks();\n\n    const global = this._global;\n    setGlobal(global, 'clearImmediate', this._fakeTimerAPIs.clearImmediate);\n    setGlobal(global, 'clearInterval', this._fakeTimerAPIs.clearInterval);\n    setGlobal(global, 'clearTimeout', this._fakeTimerAPIs.clearTimeout);\n    setGlobal(global, 'setImmediate', this._fakeTimerAPIs.setImmediate);\n    setGlobal(global, 'setInterval', this._fakeTimerAPIs.setInterval);\n    setGlobal(global, 'setTimeout', this._fakeTimerAPIs.setTimeout);\n    global.process.nextTick = this._fakeTimerAPIs.nextTick;\n  }\n\n  getTimerCount() {\n    this._checkFakeTimers();\n\n    return this._timers.size + this._immediates.length + this._ticks.length;\n  }\n\n  _checkFakeTimers() {\n    if (this._global.setTimeout !== this._fakeTimerAPIs.setTimeout) {\n      this._global.console.warn(\"A function to advance timers was called but the timers API is not \" + \"mocked with fake timers. Call `jest.useFakeTimers()` in this \" + \"test or enable fake timers globally by setting \" + \"`\\\"timers\\\": \\\"fake\\\"` in \" + \"the configuration file. This warning is likely a result of a \" + \"default configuration change in Jest 15.\\n\\n\" + \"Release Blog Post: https://jestjs.io/blog/2016/09/01/jest-15.html\\n\" + \"Stack Trace:\\n\" + (0, _jestMessageUtil().formatStackTrace)(new Error().stack, this._config, {\n        noStackTrace: false\n      }));\n    }\n  }\n\n  _createMocks() {\n    const fn = (impl // @ts-ignore TODO: figure out better typings here\n    ) => this._moduleMocker.fn().mockImplementation(impl); // TODO: add better typings; these are mocks, but typed as regular timers\n\n\n    this._fakeTimerAPIs = {\n      clearImmediate: fn(this._fakeClearImmediate.bind(this)),\n      clearInterval: fn(this._fakeClearTimer.bind(this)),\n      clearTimeout: fn(this._fakeClearTimer.bind(this)),\n      nextTick: fn(this._fakeNextTick.bind(this)),\n      setImmediate: fn(this._fakeSetImmediate.bind(this)),\n      setInterval: fn(this._fakeSetInterval.bind(this)),\n      setTimeout: fn(this._fakeSetTimeout.bind(this))\n    };\n  }\n\n  _fakeClearTimer(timerRef) {\n    const uuid = this._timerConfig.refToId(timerRef);\n\n    if (uuid) {\n      this._timers.delete(String(uuid));\n    }\n  }\n\n  _fakeClearImmediate(uuid) {\n    this._cancelledImmediates[uuid] = true;\n  }\n\n  _fakeNextTick(callback, ...args) {\n    if (this._disposed) {\n      return;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._ticks.push({\n      callback: function (_callback) {\n        function callback() {\n          return _callback.apply(this, arguments);\n        }\n\n        callback.toString = function () {\n          return _callback.toString();\n        };\n\n        return callback;\n      }(() => callback.apply(null, args)),\n      uuid\n    });\n\n    const cancelledTicks = this._cancelledTicks;\n\n    this._timerAPIs.nextTick(() => {\n      if (!cancelledTicks.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledTicks[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n  }\n\n  _fakeSetImmediate(callback, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._immediates.push({\n      callback: function (_callback2) {\n        function callback() {\n          return _callback2.apply(this, arguments);\n        }\n\n        callback.toString = function () {\n          return _callback2.toString();\n        };\n\n        return callback;\n      }(() => callback.apply(null, args)),\n      uuid: String(uuid)\n    });\n\n    const cancelledImmediates = this._cancelledImmediates;\n\n    this._timerAPIs.setImmediate(() => {\n      if (!cancelledImmediates.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledImmediates[String(uuid)] = true;\n        callback.apply(null, args);\n      }\n    });\n\n    return uuid;\n  }\n\n  _fakeSetInterval(callback, intervalDelay, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    if (intervalDelay == null) {\n      intervalDelay = 0;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: function (_callback3) {\n        function callback() {\n          return _callback3.apply(this, arguments);\n        }\n\n        callback.toString = function () {\n          return _callback3.toString();\n        };\n\n        return callback;\n      }(() => callback.apply(null, args)),\n      expiry: this._now + intervalDelay,\n      interval: intervalDelay,\n      type: 'interval'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _fakeSetTimeout(callback, delay, ...args) {\n    if (this._disposed) {\n      return null;\n    } // eslint-disable-next-line no-bitwise\n\n\n    delay = Number(delay) | 0;\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: function (_callback4) {\n        function callback() {\n          return _callback4.apply(this, arguments);\n        }\n\n        callback.toString = function () {\n          return _callback4.toString();\n        };\n\n        return callback;\n      }(() => callback.apply(null, args)),\n      expiry: this._now + delay,\n      interval: undefined,\n      type: 'timeout'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _getNextTimerHandle() {\n    let nextTimerHandle = null;\n    let soonestTime = MS_IN_A_YEAR;\n\n    this._timers.forEach((timer, uuid) => {\n      if (timer.expiry < soonestTime) {\n        soonestTime = timer.expiry;\n        nextTimerHandle = uuid;\n      }\n    });\n\n    return nextTimerHandle;\n  }\n\n  _runTimerHandle(timerHandle) {\n    const timer = this._timers.get(timerHandle);\n\n    if (!timer) {\n      return;\n    }\n\n    switch (timer.type) {\n      case 'timeout':\n        const callback = timer.callback;\n\n        this._timers.delete(timerHandle);\n\n        callback();\n        break;\n\n      case 'interval':\n        timer.expiry = this._now + (timer.interval || 0);\n        timer.callback();\n        break;\n\n      default:\n        throw new Error('Unexpected timer type: ' + timer.type);\n    }\n  }\n\n}\n\nexports.default = FakeTimers;","map":null,"metadata":{},"sourceType":"script"}