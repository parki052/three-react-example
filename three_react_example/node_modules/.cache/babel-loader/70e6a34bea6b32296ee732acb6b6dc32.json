{"ast":null,"code":"'use strict';\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function _events() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _anymatch() {\n  const data = _interopRequireDefault(require('anymatch'));\n\n  _anymatch = function _anymatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function _micromatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _walker() {\n  const data = _interopRequireDefault(require('walker'));\n\n  _walker = function _walker() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nlet fsevents;\n\ntry {\n  fsevents = require('fsevents');\n} catch (e) {// Optional dependency, only supported on Darwin.\n}\n\nconst CHANGE_EVENT = 'change';\nconst DELETE_EVENT = 'delete';\nconst ADD_EVENT = 'add';\nconst ALL_EVENT = 'all';\n/**\n * Export `FSEventsWatcher` class.\n * Watches `dir`.\n */\n\nclass FSEventsWatcher extends _events().EventEmitter {\n  static isSupported() {\n    return fsevents !== undefined;\n  }\n\n  static normalizeProxy(callback) {\n    return (filepath, stats) => callback(_path().default.normalize(filepath), stats);\n  }\n\n  static recReaddir(dir, dirCallback, fileCallback, endCallback, errorCallback, ignored) {\n    (0, _walker().default)(dir).filterDir(currentDir => !ignored || !(0, _anymatch().default)(ignored, currentDir)).on('dir', FSEventsWatcher.normalizeProxy(dirCallback)).on('file', FSEventsWatcher.normalizeProxy(fileCallback)).on('error', errorCallback).on('end', () => {\n      endCallback();\n    });\n  }\n\n  constructor(dir, opts) {\n    if (!fsevents) {\n      throw new Error('`fsevents` unavailable (this watcher can only be used on Darwin)');\n    }\n\n    super();\n\n    _defineProperty(this, 'root', void 0);\n\n    _defineProperty(this, 'ignored', void 0);\n\n    _defineProperty(this, 'glob', void 0);\n\n    _defineProperty(this, 'dot', void 0);\n\n    _defineProperty(this, 'hasIgnore', void 0);\n\n    _defineProperty(this, 'doIgnore', void 0);\n\n    _defineProperty(this, 'watcher', void 0);\n\n    _defineProperty(this, '_tracked', void 0);\n\n    this.dot = opts.dot || false;\n    this.ignored = opts.ignored;\n    this.glob = Array.isArray(opts.glob) ? opts.glob : [opts.glob];\n    this.hasIgnore = Boolean(opts.ignored) && !(Array.isArray(opts) && opts.length > 0);\n    this.doIgnore = opts.ignored ? (0, _anymatch().default)(opts.ignored) : () => false;\n    this.root = _path().default.resolve(dir);\n    this.watcher = fsevents(this.root);\n    this.watcher.start().on('change', this.handleEvent.bind(this));\n    this._tracked = new Set();\n    FSEventsWatcher.recReaddir(this.root, filepath => {\n      this._tracked.add(filepath);\n    }, filepath => {\n      this._tracked.add(filepath);\n    }, this.emit.bind(this, 'ready'), this.emit.bind(this, 'error'), this.ignored);\n  }\n  /**\n   * End watching.\n   */\n\n\n  close(callback) {\n    this.watcher.stop();\n    this.removeAllListeners();\n\n    if (typeof callback === 'function') {\n      process.nextTick(callback.bind(null, null, true));\n    }\n  }\n\n  isFileIncluded(relativePath) {\n    if (this.doIgnore(relativePath)) {\n      return false;\n    }\n\n    return this.glob.length ? _micromatch().default.some(relativePath, this.glob, {\n      dot: this.dot\n    }) : this.dot || _micromatch().default.some(relativePath, '**/*');\n  }\n\n  handleEvent(filepath) {\n    const relativePath = _path().default.relative(this.root, filepath);\n\n    if (!this.isFileIncluded(relativePath)) {\n      return;\n    }\n\n    _fs().default.lstat(filepath, (error, stat) => {\n      if (error && error.code !== 'ENOENT') {\n        this.emit('error', error);\n        return;\n      }\n\n      if (error) {\n        // Ignore files that aren't tracked and don't exist.\n        if (!this._tracked.has(filepath)) {\n          return;\n        }\n\n        this._emit(DELETE_EVENT, relativePath);\n\n        this._tracked.delete(filepath);\n\n        return;\n      }\n\n      if (this._tracked.has(filepath)) {\n        this._emit(CHANGE_EVENT, relativePath, stat);\n      } else {\n        this._tracked.add(filepath);\n\n        this._emit(ADD_EVENT, relativePath, stat);\n      }\n    });\n  }\n  /**\n   * Emit events.\n   */\n\n\n  _emit(type, file, stat) {\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n\n}\n\nmodule.exports = FSEventsWatcher;","map":null,"metadata":{},"sourceType":"script"}