{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = jasmineAsyncInstall;\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _throat = _interopRequireDefault(require('throat'));\n\nvar _isError3 = _interopRequireDefault(require('./isError'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\n\nfunction promisifyLifeCycleFunction(originalFn, env) {\n  return function (fn, timeout) {\n    if (!fn) {\n      return originalFn.call(env);\n    }\n\n    const hasDoneCallback = typeof fn === 'function' && fn.length > 0;\n\n    if (hasDoneCallback) {\n      // Jasmine will handle it\n      return originalFn.call(env, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack; // We make *all* functions async and run `done` right away if they\n    // didn't return a promise.\n\n    const asyncJestLifecycle = function asyncJestLifecycle(done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn) ? _co.default.wrap(fn) : fn;\n      const returnValue = wrappedFn.call({});\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const _isError = (0, _isError3.default)(error),\n                checkIsError = _isError.isError,\n                message = _isError.message;\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          done.fail(checkIsError ? error : extraError);\n        });\n      } else {\n        done();\n      }\n    };\n\n    return originalFn.call(env, asyncJestLifecycle, timeout);\n  };\n} // Similar to promisifyLifeCycleFunction but throws an error\n// when the return value is neither a Promise nor `undefined`\n\n\nfunction promisifyIt(originalFn, env, jasmine) {\n  return function (specName, fn, timeout) {\n    if (!fn) {\n      const spec = originalFn.call(env, specName);\n      spec.pend('not implemented');\n      return spec;\n    }\n\n    const hasDoneCallback = fn.length > 0;\n\n    if (hasDoneCallback) {\n      return originalFn.call(env, specName, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack;\n\n    const asyncJestTest = function asyncJestTest(done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn) ? _co.default.wrap(fn) : fn;\n      const returnValue = wrappedFn.call({});\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const _isError2 = (0, _isError3.default)(error),\n                checkIsError = _isError2.isError,\n                message = _isError2.message;\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          if (jasmine.Spec.isPendingSpecException(error)) {\n            env.pending(message);\n            done();\n          } else {\n            done.fail(checkIsError ? error : extraError);\n          }\n        });\n      } else if (returnValue === undefined) {\n        done();\n      } else {\n        done.fail(new Error('Jest: `it` and `test` must return either a Promise or undefined.'));\n      }\n    };\n\n    return originalFn.call(env, specName, asyncJestTest, timeout);\n  };\n}\n\nfunction makeConcurrent(originalFn, env, mutex) {\n  return function (specName, fn, timeout) {\n    if (env != null && !env.specFilter({\n      getFullName: () => specName || ''\n    })) {\n      return originalFn.call(env, specName, () => Promise.resolve(), timeout);\n    }\n\n    let promise;\n\n    try {\n      promise = mutex(() => {\n        const promise = fn();\n\n        if (isPromise(promise)) {\n          return promise;\n        }\n\n        throw new Error(\"Jest: concurrent test \\\"\".concat(specName, \"\\\" must return a Promise.\"));\n      });\n    } catch (error) {\n      return originalFn.call(env, specName, () => Promise.reject(error));\n    }\n\n    return originalFn.call(env, specName, () => promise, timeout);\n  };\n}\n\nfunction jasmineAsyncInstall(globalConfig, global) {\n  const jasmine = global.jasmine;\n  const mutex = (0, _throat.default)(globalConfig.maxConcurrency);\n  const env = jasmine.getEnv();\n  env.it = promisifyIt(env.it, env, jasmine);\n  env.fit = promisifyIt(env.fit, env, jasmine);\n\n  global.it.concurrent = (env => {\n    const concurrent = makeConcurrent(env.it, env, mutex);\n    concurrent.only = makeConcurrent(env.fit, env, mutex);\n    concurrent.skip = makeConcurrent(env.xit, env, mutex);\n    return concurrent;\n  })(env);\n\n  global.fit.concurrent = makeConcurrent(env.fit, env, mutex);\n  env.afterAll = promisifyLifeCycleFunction(env.afterAll, env);\n  env.afterEach = promisifyLifeCycleFunction(env.afterEach, env);\n  env.beforeAll = promisifyLifeCycleFunction(env.beforeAll, env);\n  env.beforeEach = promisifyLifeCycleFunction(env.beforeEach, env);\n}","map":null,"metadata":{},"sourceType":"script"}