{"ast":null,"code":"'use strict';\n\nfunction _child_process() {\n  const data = require('child_process');\n\n  _child_process = function _child_process() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = _interopRequireDefault(require('events'));\n\n  _events = function _events() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = _interopRequireDefault(require('os'));\n\n  _os = function _os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sane() {\n  const data = _interopRequireDefault(require('sane'));\n\n  _sane = function _sane() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _invariant() {\n  const data = _interopRequireDefault(require('invariant'));\n\n  _invariant = function _invariant() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSerializer() {\n  const data = _interopRequireDefault(require('jest-serializer'));\n\n  _jestSerializer = function _jestSerializer() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = _interopRequireDefault(require('jest-worker'));\n\n  _jestWorker = function _jestWorker() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _worker = require('./worker');\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar _getPlatformExtension = _interopRequireDefault(require('./lib/getPlatformExtension'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _node = _interopRequireDefault(require('./crawlers/node'));\n\nvar _normalizePathSep = _interopRequireDefault(require('./lib/normalizePathSep'));\n\nvar _watchman = _interopRequireDefault(require('./crawlers/watchman'));\n\nvar _WatchmanWatcher = _interopRequireDefault(require('./lib/WatchmanWatcher'));\n\nvar _FSEventsWatcher = _interopRequireDefault(require('./lib/FSEventsWatcher'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\n\nconst NODE_MODULES = _path().default.sep + 'node_modules' + _path().default.sep;\n\nconst PACKAGE_JSON = _path().default.sep + 'package.json'; // TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\n\nconst _require = require('../package.json'),\n      VERSION = _require.version;\n\nconst canUseWatchman = (() => {\n  try {\n    (0, _child_process().execSync)('watchman --version', {\n      stdio: ['ignore']\n    });\n    return true;\n  } catch (e) {}\n\n  return false;\n})();\n\nconst escapePathSeparator = string => _path().default.sep === '\\\\' ? string.replace(/(\\/|\\\\)/g, '\\\\\\\\') : string;\n\nconst getWhiteList = list => {\n  if (list && list.length) {\n    const newList = list.map(item => escapePathSeparator(item.replace(/(\\/)/g, _path().default.sep)));\n    return new RegExp('(' + escapePathSeparator(NODE_MODULES) + '(?:' + newList.join('|') + ')(?=$|' + escapePathSeparator(_path().default.sep) + '))', 'g');\n  }\n\n  return null;\n};\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\n/* eslint-disable-next-line no-redeclare */\n\n\nclass HasteMap extends _events().default {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, '_buildPromise', void 0);\n\n    _defineProperty(this, '_cachePath', void 0);\n\n    _defineProperty(this, '_changeInterval', void 0);\n\n    _defineProperty(this, '_console', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_watchers', void 0);\n\n    _defineProperty(this, '_whitelist', void 0);\n\n    _defineProperty(this, '_worker', void 0);\n\n    this._options = {\n      cacheDirectory: options.cacheDirectory || _os().default.tmpdir(),\n      computeDependencies: options.computeDependencies === undefined ? true : options.computeDependencies,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      ignorePattern: options.ignorePattern,\n      mapper: options.mapper,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,\n      name: options.name,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman == null ? true : options.useWatchman,\n      watch: !!options.watch\n    };\n    this._console = options.console || global.console;\n\n    if (options.ignorePattern && !(options.ignorePattern instanceof RegExp)) {\n      this._console.warn('jest-haste-map: the `ignorePattern` options as a function is being ' + 'deprecated. Provide a RegExp instead. See https://github.com/facebook/jest/pull/4063.');\n    }\n\n    const rootDirHash = _crypto().default.createHash('md5').update(options.rootDir).digest('hex');\n\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = require(options.dependencyExtractor);\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(this._options.cacheDirectory, \"haste-map-\".concat(this._options.name, \"-\").concat(rootDirHash), VERSION, this._options.name, this._options.roots.map(root => fastPath.relative(options.rootDir, root)).join(':'), this._options.extensions.join(':'), this._options.platforms.join(':'), this._options.computeSha1.toString(), options.mocksPattern || '', (options.ignorePattern || '').toString(), hasteImplHash, dependencyExtractorHash);\n    this._whitelist = getWhiteList(options.providesModuleNodeModules);\n    this._buildPromise = null;\n    this._watchers = [];\n    this._worker = null;\n  }\n\n  static getCacheFilePath(tmpdir, name, ...extra) {\n    const hash = _crypto().default.createHash('md5').update(extra.join(''));\n\n    return _path().default.join(tmpdir, name.replace(/\\W/g, '-') + '-' + hash.digest('hex'));\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    var _this = this;\n\n    if (!this._buildPromise) {\n      this._buildPromise = _asyncToGenerator(function* () {\n        const data = yield _this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (data.changedFiles === undefined || data.changedFiles.size > 0 || data.removedFiles.size > 0) {\n          hasteMap = yield _this._buildHasteMap(data);\n\n          _this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = _this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;\n\n        yield _this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = _jestSerializer().default.readFileSync(this._cachePath);\n    } catch (err) {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n\n  _buildFileMap() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let hasteMap;\n\n      try {\n        const read = _this2._options.resetCache ? _this2._createEmptyMap : _this2.read;\n        hasteMap = yield read.call(_this2);\n      } catch (_unused) {\n        hasteMap = _this2._createEmptyMap();\n      }\n\n      return _this2._crawl(hasteMap);\n    })();\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform = (0, _getPlatformExtension.default)(module[_constants.default.PATH], this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (existingModule && existingModule[_constants.default.PATH] !== module[_constants.default.PATH]) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](['jest-haste-map: Haste module naming collision: ' + id, '  The following files share their name; please adjust your hasteImpl:', '    * <rootDir>' + _path().default.sep + existingModule[_constants.default.PATH], '    * <rootDir>' + _path().default.sep + module[_constants.default.PATH], ''].join('\\n'));\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(existingModule[_constants.default.PATH], module[_constants.default.PATH]);\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([[module[_constants.default.PATH], module[_constants.default.TYPE]], [existingModule[_constants.default.PATH], existingModule[_constants.default.TYPE]]]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(module[_constants.default.PATH], module[_constants.default.TYPE]);\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error('jest-haste-map: File to process was not found in the haste map.');\n    }\n\n    const moduleMetadata = hasteMap.map.get(fileMetadata[_constants.default.ID]);\n    const computeSha1 = this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM) : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      } // @ts-ignore: checking error code is OK if error comes from \"fs\".\n\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n\n    if (this._options.retainAllFiles && this._isNodeModulesDir(filePath)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions).getSha1({\n          computeDependencies: this._options.computeDependencies,\n          computeSha1,\n          dependencyExtractor: this._options.dependencyExtractor,\n          filePath,\n          hasteImplModulePath: this._options.hasteImplModulePath,\n          rootDir\n        }).then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n          this._console[method](['jest-haste-map: duplicate manual mock found: ' + mockPath, '  The following files share their name; please delete one of them:', '    * <rootDir>' + _path().default.sep + existingMockPath, '    * <rootDir>' + _path().default.sep + secondMockPath, ''].join('\\n'));\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions).worker({\n      computeDependencies: this._options.computeDependencies,\n      computeSha1,\n      dependencyExtractor: this._options.dependencyExtractor,\n      filePath,\n      hasteImplModulePath: this._options.hasteImplModulePath,\n      rootDir\n    }).then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const removedFiles = data.removedFiles,\n          changedFiles = data.changedFiles,\n          hasteMap = data.hasteMap; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = removedFiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const _step$value = _slicedToArray(_step.value, 2),\n              relativeFilePath = _step$value[0],\n              fileMetadata = _step$value[1];\n\n        this._recoverDuplicates(hasteMap, relativeFilePath, fileMetadata[_constants.default.ID]);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    const promises = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = filesToProcess.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        const relativeFilePath = _step2.value;\n\n        if (this._options.skipPackageJson && relativeFilePath.endsWith(PACKAGE_JSON)) {\n          continue;\n        } // SHA-1, if requested, should already be present thanks to the crawler.\n\n\n        const filePath = fastPath.resolve(this._options.rootDir, relativeFilePath);\n\n        const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n        if (promise) {\n          promises.push(promise);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return Promise.all(promises).then(() => {\n      this._cleanup();\n\n      hasteMap.map = map;\n      hasteMap.mocks = mocks;\n      return hasteMap;\n    }, error => {\n      this._cleanup();\n\n      throw error;\n    });\n  }\n\n  _cleanup() {\n    const worker = this._worker; // @ts-ignore\n\n    if (worker && typeof worker.end === 'function') {\n      // @ts-ignore\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n\n  _persist(hasteMap) {\n    _jestSerializer().default.writeFileSync(this._cachePath, hasteMap);\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n\n  _getWorker(options) {\n    if (!this._worker) {\n      if (options && options.forceInBand || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        // @ts-ignore: assignment of a worker with custom properties.\n        this._worker = new (_jestWorker().default)(require.resolve('./worker'), {\n          exposedMethods: ['getSha1', 'worker'],\n          maxRetries: 3,\n          numWorkers: this._options.maxWorkers\n        });\n      }\n    }\n\n    return this._worker;\n  }\n\n  _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl = canUseWatchman && this._options.useWatchman ? _watchman.default : _node.default;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      mapper: options.mapper,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.default) {\n        this._console.warn(\"jest-haste-map: Watchman crawl failed. Retrying once with node \" + \"crawler.\\n\" + \"  Usually this happens when watchman isn't running. Create an \" + \"empty `.watchmanconfig` file in your project's root folder or \" + \"initialize a git or hg repository in your project.\\n\" + \"  \" + error);\n\n        return (0, _node.default)(crawlerOptions).catch(e => {\n          throw new Error(\"Crawler retry failed:\\n\" + \"  Original error: \".concat(error.message, \"\\n\") + \"  Retry error: \".concat(e.message, \"\\n\"));\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n\n  _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher = canUseWatchman && this._options.useWatchman ? _WatchmanWatcher.default : _FSEventsWatcher.default.isSupported() ? _FSEventsWatcher.default : _sane().default.NodeWatcher;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      // @ts-ignore: TODO how? \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\"\n      const watcher = new Watcher(root, {\n        dot: false,\n        glob: extensions.map(extension => '**/*.' + extension),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(() => reject(new Error('Failed to start watch mode.')), MAX_WAIT_TIME);\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = _path().default.join(root, (0, _normalizePathSep.default)(filePath));\n\n      if (stat && stat.isDirectory() || this._ignore(filePath) || !extensions.some(extension => filePath.endsWith(extension))) {\n        return;\n      }\n\n      changeQueue = changeQueue.then(() => {\n        // If we get duplicate events for the same file, ignore them.\n        if (eventsQueue.find(event => event.type === type && event.filePath === filePath && (!event.stat && !stat || !!event.stat && !!stat && event.stat.mtime.getTime() === stat.mtime.getTime()))) {\n          return null;\n        }\n\n        if (mustCopy) {\n          mustCopy = false;\n          hasteMap = {\n            clocks: new Map(hasteMap.clocks),\n            duplicates: new Map(hasteMap.duplicates),\n            files: new Map(hasteMap.files),\n            map: new Map(hasteMap.map),\n            mocks: new Map(hasteMap.mocks)\n          };\n        }\n\n        const add = () => {\n          eventsQueue.push({\n            filePath,\n            stat,\n            type\n          });\n          return null;\n        };\n\n        const relativeFilePath = fastPath.relative(rootDir, filePath);\n        const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n        if (fileMetadata != null) {\n          const moduleName = fileMetadata[_constants.default.ID];\n\n          const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n          hasteMap.files.delete(relativeFilePath);\n          let moduleMap = hasteMap.map.get(moduleName);\n\n          if (moduleMap != null) {\n            // We are forced to copy the object because jest-haste-map exposes\n            // the map as an immutable entity.\n            moduleMap = copy(moduleMap);\n            delete moduleMap[platform];\n\n            if (Object.keys(moduleMap).length === 0) {\n              hasteMap.map.delete(moduleName);\n            } else {\n              hasteMap.map.set(moduleName, moduleMap);\n            }\n          }\n\n          if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n            const mockName = (0, _getMockName.default)(filePath);\n            hasteMap.mocks.delete(mockName);\n          }\n\n          this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n        } // If the file was added or changed,\n        // parse it and update the haste map.\n\n\n        if (type === 'add' || type === 'change') {\n          (0, _invariant().default)(stat, 'since the file exists or changed, it should have stats');\n          const fileMetadata = ['', stat ? stat.mtime.getTime() : -1, stat ? stat.size : 0, 0, '', null];\n          hasteMap.files.set(relativeFilePath, fileMetadata);\n\n          const promise = this._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {\n            forceInBand: true\n          }); // Cleanup\n\n\n          this._cleanup();\n\n          if (promise) {\n            return promise.then(add);\n          } else {\n            // If a file in node_modules has changed,\n            // emit an event regardless.\n            add();\n          }\n        } else {\n          add();\n        }\n\n        return null;\n      }).catch(error => {\n        this._console.error(\"jest-haste-map: watch error:\\n  \".concat(error.stack, \"\\n\"));\n      });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(watchers => {\n      this._watchers = watchers;\n    });\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform = (0, _getPlatformExtension.default)(relativeFilePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (dedupMap == null) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  end() {\n    // @ts-ignore: TODO TS cannot decide if `setInterval` and `clearInterval` comes from NodeJS or the DOM\n    clearInterval(this._changeInterval);\n\n    if (!this._watchers.length) {\n      return Promise.resolve();\n    }\n\n    return Promise.all(this._watchers.map(watcher => new Promise(resolve => watcher.close(resolve)))).then(() => {\n      this._watchers = [];\n    });\n  }\n  /**\n   * Helpers\n   */\n\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern && ignorePattern(filePath);\n    return ignoreMatched || !this._options.retainAllFiles && this._isNodeModulesDir(filePath);\n  }\n\n  _isNodeModulesDir(filePath) {\n    if (!filePath.includes(NODE_MODULES)) {\n      return false;\n    }\n\n    if (this._whitelist) {\n      const whitelist = this._whitelist;\n      const match = whitelist.exec(filePath);\n      const matchEndIndex = whitelist.lastIndex;\n      whitelist.lastIndex = 0;\n\n      if (!match) {\n        return true;\n      }\n\n      const filePathInPackage = filePath.substr(matchEndIndex);\n      return filePathInPackage.startsWith(NODE_MODULES);\n    }\n\n    return true;\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n\n}\n\n_defineProperty(HasteMap, 'H', void 0);\n\n_defineProperty(HasteMap, 'DuplicateError', void 0);\n\n_defineProperty(HasteMap, 'ModuleMap', void 0);\n\nclass DuplicateError extends Error {\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n\n    _defineProperty(this, 'mockPath1', void 0);\n\n    _defineProperty(this, 'mockPath2', void 0);\n\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n\n}\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}\n\nHasteMap.H = _constants.default;\nHasteMap.DuplicateError = DuplicateError;\nHasteMap.ModuleMap = _ModuleMap.default;\nmodule.exports = HasteMap;","map":null,"metadata":{},"sourceType":"script"}