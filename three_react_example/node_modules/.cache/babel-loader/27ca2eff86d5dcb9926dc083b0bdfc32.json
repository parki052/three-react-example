{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.extract = extract;\nexports.strip = strip;\nexports.parse = parse;\nexports.parseWithComments = parseWithComments;\nexports.print = print;\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function _os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _detectNewline() {\n  const data = _interopRequireDefault(require('detect-newline'));\n\n  _detectNewline = function _detectNewline() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst commentEndRe = /\\*\\/$/;\nconst commentStartRe = /^\\/\\*\\*/;\nconst docblockRe = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/;\nconst lineCommentRe = /(^|\\s+)\\/\\/([^\\r\\n]*)/g;\nconst ltrimNewlineRe = /^(\\r?\\n)+/;\nconst multilineRe = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g;\nconst propertyRe = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g;\nconst stringStartRe = /(\\r?\\n|^) *\\* ?/g;\n\nfunction extract(contents) {\n  const match = contents.match(docblockRe);\n  return match ? match[0].trimLeft() : '';\n}\n\nfunction strip(contents) {\n  const match = contents.match(docblockRe);\n  return match && match[0] ? contents.substring(match[0].length) : contents;\n}\n\nfunction parse(docblock) {\n  return parseWithComments(docblock).pragmas;\n}\n\nfunction parseWithComments(docblock) {\n  const line = (0, _detectNewline().default)(docblock) || _os().EOL;\n\n  docblock = docblock.replace(commentStartRe, '').replace(commentEndRe, '').replace(stringStartRe, '$1'); // Normalize multi-line directives\n\n  let prev = '';\n\n  while (prev !== docblock) {\n    prev = docblock;\n    docblock = docblock.replace(multilineRe, \"\".concat(line, \"$1 $2\").concat(line));\n  }\n\n  docblock = docblock.replace(ltrimNewlineRe, '').trimRight();\n  const result = Object.create(null);\n  const comments = docblock.replace(propertyRe, '').replace(ltrimNewlineRe, '').trimRight();\n  let match;\n\n  while (match = propertyRe.exec(docblock)) {\n    // strip linecomments from pragmas\n    const nextPragma = match[2].replace(lineCommentRe, '');\n\n    if (typeof result[match[1]] === 'string' || Array.isArray(result[match[1]])) {\n      result[match[1]] = [].concat(result[match[1]], nextPragma);\n    } else {\n      result[match[1]] = nextPragma;\n    }\n  }\n\n  return {\n    comments,\n    pragmas: result\n  };\n}\n\nfunction print({\n  comments = '',\n  pragmas = {}\n}) {\n  const line = (0, _detectNewline().default)(comments) || _os().EOL;\n\n  const head = '/**';\n  const start = ' *';\n  const tail = ' */';\n  const keys = Object.keys(pragmas);\n  const printedObject = keys.map(key => printKeyValues(key, pragmas[key])).reduce((arr, next) => arr.concat(next), []).map(keyValue => start + ' ' + keyValue + line).join('');\n\n  if (!comments) {\n    if (keys.length === 0) {\n      return '';\n    }\n\n    if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {\n      const value = pragmas[keys[0]];\n      return \"\".concat(head, \" \").concat(printKeyValues(keys[0], value)[0]).concat(tail);\n    }\n  }\n\n  const printedComments = comments.split(line).map(textLine => \"\".concat(start, \" \").concat(textLine)).join(line) + line;\n  return head + line + (comments ? printedComments : '') + (comments && keys.length ? start + line : '') + printedObject + tail;\n}\n\nfunction printKeyValues(key, valueOrArray) {\n  return [].concat(valueOrArray).map(value => \"@\".concat(key, \" \").concat(value).trim());\n}","map":null,"metadata":{},"sourceType":"script"}