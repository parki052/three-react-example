{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = _default;\n\nvar _assert = require('assert');\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _jestMessageUtil = require('jest-message-util');\n\nvar _jestUtil = require('jest-util');\n\nvar _queueRunner = _interopRequireDefault(require('../queueRunner'));\n\nvar _treeProcessor = _interopRequireDefault(require('../treeProcessor'));\n\nvar _isError = _interopRequireDefault(require('../isError'));\n\nvar _assertionErrorMessage = _interopRequireDefault(require('../assertionErrorMessage'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _default(j$) {\n  var _temp;\n\n  return _temp = class Env {\n    constructor(_options) {\n      _defineProperty(this, 'specFilter', void 0);\n\n      _defineProperty(this, 'catchExceptions', void 0);\n\n      _defineProperty(this, 'throwOnExpectationFailure', void 0);\n\n      _defineProperty(this, 'catchingExceptions', void 0);\n\n      _defineProperty(this, 'topSuite', void 0);\n\n      _defineProperty(this, 'fail', void 0);\n\n      _defineProperty(this, 'pending', void 0);\n\n      _defineProperty(this, 'afterAll', void 0);\n\n      _defineProperty(this, 'fit', void 0);\n\n      _defineProperty(this, 'throwingExpectationFailures', void 0);\n\n      _defineProperty(this, 'randomizeTests', void 0);\n\n      _defineProperty(this, 'randomTests', void 0);\n\n      _defineProperty(this, 'seed', void 0);\n\n      _defineProperty(this, 'execute', void 0);\n\n      _defineProperty(this, 'fdescribe', void 0);\n\n      _defineProperty(this, 'spyOn', void 0);\n\n      _defineProperty(this, 'beforeEach', void 0);\n\n      _defineProperty(this, 'afterEach', void 0);\n\n      _defineProperty(this, 'clearReporters', void 0);\n\n      _defineProperty(this, 'addReporter', void 0);\n\n      _defineProperty(this, 'it', void 0);\n\n      _defineProperty(this, 'xdescribe', void 0);\n\n      _defineProperty(this, 'xit', void 0);\n\n      _defineProperty(this, 'beforeAll', void 0);\n\n      _defineProperty(this, 'todo', void 0);\n\n      _defineProperty(this, 'provideFallbackReporter', void 0);\n\n      _defineProperty(this, 'allowRespy', void 0);\n\n      _defineProperty(this, 'describe', void 0);\n\n      let totalSpecsDefined = 0;\n      let catchExceptions = true;\n      const realSetTimeout = global.setTimeout;\n      const realClearTimeout = global.clearTimeout;\n      const runnableResources = {};\n      const currentlyExecutingSuites = [];\n      let currentSpec = null;\n      let throwOnExpectationFailure = false;\n      let random = false;\n      let seed = null;\n      let nextSpecId = 0;\n      let nextSuiteId = 0;\n\n      const getNextSpecId = function getNextSpecId() {\n        return 'spec' + nextSpecId++;\n      };\n\n      const getNextSuiteId = function getNextSuiteId() {\n        return 'suite' + nextSuiteId++;\n      };\n\n      const topSuite = new j$.Suite({\n        id: getNextSuiteId(),\n        description: '',\n\n        getTestPath() {\n          return j$.testPath;\n        }\n\n      });\n      let currentDeclarationSuite = topSuite;\n\n      const currentSuite = function currentSuite() {\n        return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n      };\n\n      const currentRunnable = function currentRunnable() {\n        return currentSpec || currentSuite();\n      };\n\n      const reporter = new j$.ReportDispatcher(['jasmineStarted', 'jasmineDone', 'suiteStarted', 'suiteDone', 'specStarted', 'specDone']);\n\n      this.specFilter = function () {\n        return true;\n      };\n\n      const defaultResourcesForRunnable = function defaultResourcesForRunnable(id, _parentRunnableId) {\n        const resources = {\n          spies: []\n        };\n        runnableResources[id] = resources;\n      };\n\n      const clearResourcesForRunnable = function clearResourcesForRunnable(id) {\n        spyRegistry.clearSpies();\n        delete runnableResources[id];\n      };\n\n      const beforeAndAfterFns = function beforeAndAfterFns(suite) {\n        return function () {\n          let afters = [];\n          let befores = [];\n\n          while (suite) {\n            befores = befores.concat(suite.beforeFns);\n            afters = afters.concat(suite.afterFns);\n            suite = suite.parentSuite;\n          }\n\n          return {\n            befores: befores.reverse(),\n            afters\n          };\n        };\n      };\n\n      const getSpecName = function getSpecName(spec, suite) {\n        const fullName = [spec.description];\n        const suiteFullName = suite.getFullName();\n\n        if (suiteFullName !== '') {\n          fullName.unshift(suiteFullName);\n        }\n\n        return fullName.join(' ');\n      };\n\n      this.catchExceptions = function (value) {\n        catchExceptions = !!value;\n        return catchExceptions;\n      };\n\n      this.catchingExceptions = function () {\n        return catchExceptions;\n      };\n\n      this.throwOnExpectationFailure = function (value) {\n        throwOnExpectationFailure = !!value;\n      };\n\n      this.throwingExpectationFailures = function () {\n        return throwOnExpectationFailure;\n      };\n\n      this.randomizeTests = function (value) {\n        random = !!value;\n      };\n\n      this.randomTests = function () {\n        return random;\n      };\n\n      this.seed = function (value) {\n        if (value) {\n          seed = value;\n        }\n\n        return seed;\n      };\n\n      const queueRunnerFactory = options => {\n        options.clearTimeout = realClearTimeout;\n        options.fail = this.fail;\n        options.setTimeout = realSetTimeout;\n        return (0, _queueRunner.default)(options);\n      };\n\n      this.topSuite = function () {\n        return topSuite;\n      };\n\n      const uncaught = err => {\n        if (currentSpec) {\n          currentSpec.onException(err);\n          currentSpec.cancel();\n        } else {\n          console.error('Unhandled error');\n          console.error(err.stack);\n        }\n      };\n\n      let oldListenersException;\n      let oldListenersRejection;\n\n      const executionSetup = function executionSetup() {\n        // Need to ensure we are the only ones handling these exceptions.\n        oldListenersException = process.listeners('uncaughtException').slice();\n        oldListenersRejection = process.listeners('unhandledRejection').slice();\n        j$.process.removeAllListeners('uncaughtException');\n        j$.process.removeAllListeners('unhandledRejection');\n        j$.process.on('uncaughtException', uncaught);\n        j$.process.on('unhandledRejection', uncaught);\n      };\n\n      const executionTeardown = function executionTeardown() {\n        j$.process.removeListener('uncaughtException', uncaught);\n        j$.process.removeListener('unhandledRejection', uncaught); // restore previous exception handlers\n\n        oldListenersException.forEach(listener => {\n          j$.process.on('uncaughtException', listener);\n        });\n        oldListenersRejection.forEach(listener => {\n          j$.process.on('unhandledRejection', listener);\n        });\n      };\n\n      this.execute =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(function* (runnablesToRun, suiteTree = topSuite) {\n          if (!runnablesToRun) {\n            if (focusedRunnables.length) {\n              runnablesToRun = focusedRunnables;\n            } else {\n              runnablesToRun = [suiteTree.id];\n            }\n          }\n\n          if (currentlyExecutingSuites.length === 0) {\n            executionSetup();\n          }\n\n          const lastDeclarationSuite = currentDeclarationSuite;\n          yield (0, _treeProcessor.default)({\n            nodeComplete(suite) {\n              if (!suite.disabled) {\n                clearResourcesForRunnable(suite.id);\n              }\n\n              currentlyExecutingSuites.pop();\n\n              if (suite === topSuite) {\n                reporter.jasmineDone({\n                  failedExpectations: topSuite.result.failedExpectations\n                });\n              } else {\n                reporter.suiteDone(suite.getResult());\n              }\n            },\n\n            nodeStart(suite) {\n              currentlyExecutingSuites.push(suite);\n              defaultResourcesForRunnable(suite.id, suite.parentSuite && suite.parentSuite.id);\n\n              if (suite === topSuite) {\n                reporter.jasmineStarted({\n                  totalSpecsDefined\n                });\n              } else {\n                reporter.suiteStarted(suite.result);\n              }\n            },\n\n            queueRunnerFactory,\n            runnableIds: runnablesToRun,\n            tree: suiteTree\n          });\n          currentDeclarationSuite = lastDeclarationSuite;\n\n          if (currentlyExecutingSuites.length === 0) {\n            executionTeardown();\n          }\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      this.addReporter = function (reporterToAdd) {\n        reporter.addReporter(reporterToAdd);\n      };\n\n      this.provideFallbackReporter = function (reporterToAdd) {\n        reporter.provideFallbackReporter(reporterToAdd);\n      };\n\n      this.clearReporters = function () {\n        reporter.clearReporters();\n      };\n\n      const spyRegistry = new j$.SpyRegistry({\n        currentSpies() {\n          if (!currentRunnable()) {\n            throw new Error('Spies must be created in a before function or a spec');\n          }\n\n          return runnableResources[currentRunnable().id].spies;\n        }\n\n      });\n\n      this.allowRespy = function (allow) {\n        spyRegistry.allowRespy(allow);\n      };\n\n      this.spyOn = function (...args) {\n        return spyRegistry.spyOn.apply(spyRegistry, args);\n      };\n\n      const suiteFactory = function suiteFactory(description) {\n        const suite = new j$.Suite({\n          id: getNextSuiteId(),\n          description,\n          parentSuite: currentDeclarationSuite,\n          throwOnExpectationFailure,\n\n          getTestPath() {\n            return j$.testPath;\n          }\n\n        });\n        return suite;\n      };\n\n      this.describe = function (description, specDefinitions) {\n        const suite = suiteFactory(description);\n\n        if (specDefinitions === undefined) {\n          throw new Error(\"Missing second argument. It must be a callback function.\");\n        }\n\n        if (typeof specDefinitions !== 'function') {\n          throw new Error(\"Invalid second argument, \".concat(specDefinitions, \". It must be a callback function.\"));\n        }\n\n        if (specDefinitions.length > 0) {\n          throw new Error('describe does not expect any arguments');\n        }\n\n        if (currentDeclarationSuite.markedPending) {\n          suite.pend();\n        }\n\n        if (currentDeclarationSuite.markedTodo) {\n          // @ts-ignore TODO Possible error: Suite does not have todo method\n          suite.todo();\n        }\n\n        addSpecsToSuite(suite, specDefinitions);\n        return suite;\n      };\n\n      this.xdescribe = function (description, specDefinitions) {\n        const suite = suiteFactory(description);\n        suite.pend();\n        addSpecsToSuite(suite, specDefinitions);\n        return suite;\n      };\n\n      const focusedRunnables = [];\n\n      this.fdescribe = function (description, specDefinitions) {\n        const suite = suiteFactory(description);\n        suite.isFocused = true;\n        focusedRunnables.push(suite.id);\n        unfocusAncestor();\n        addSpecsToSuite(suite, specDefinitions);\n        return suite;\n      };\n\n      const addSpecsToSuite = (suite, specDefinitions) => {\n        const parentSuite = currentDeclarationSuite;\n        parentSuite.addChild(suite);\n        currentDeclarationSuite = suite;\n        let declarationError = undefined;\n        let describeReturnValue = undefined;\n\n        try {\n          describeReturnValue = specDefinitions.call(suite);\n        } catch (e) {\n          declarationError = e;\n        } // TODO throw in Jest 25: declarationError = new Error\n\n\n        if ((0, _jestUtil.isPromise)(describeReturnValue)) {\n          console.log((0, _jestMessageUtil.formatExecError)(new Error(_chalk.default.yellow('Returning a Promise from \"describe\" is not supported. Tests must be defined synchronously.\\n' + 'Returning a value from \"describe\" will fail the test in a future version of Jest.')), {\n            rootDir: '',\n            testMatch: []\n          }, {\n            noStackTrace: false\n          }));\n        } else if (describeReturnValue !== undefined) {\n          console.log((0, _jestMessageUtil.formatExecError)(new Error(_chalk.default.yellow('A \"describe\" callback must not return a value.\\n' + 'Returning a value from \"describe\" will fail the test in a future version of Jest.')), {\n            rootDir: '',\n            testMatch: []\n          }, {\n            noStackTrace: false\n          }));\n        }\n\n        if (declarationError) {\n          this.it('encountered a declaration exception', () => {\n            throw declarationError;\n          });\n        }\n\n        currentDeclarationSuite = parentSuite;\n      };\n\n      function findFocusedAncestor(suite) {\n        while (suite) {\n          if (suite.isFocused) {\n            return suite.id;\n          }\n\n          suite = suite.parentSuite;\n        }\n\n        return null;\n      }\n\n      function unfocusAncestor() {\n        const focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n\n        if (focusedAncestor) {\n          for (let i = 0; i < focusedRunnables.length; i++) {\n            if (focusedRunnables[i] === focusedAncestor) {\n              focusedRunnables.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n\n      const specFactory = (description, fn, suite, timeout) => {\n        totalSpecsDefined++;\n        const spec = new j$.Spec({\n          id: getNextSpecId(),\n          beforeAndAfterFns: beforeAndAfterFns(suite),\n          resultCallback: specResultCallback,\n\n          getSpecName(spec) {\n            return getSpecName(spec, suite);\n          },\n\n          getTestPath() {\n            return j$.testPath;\n          },\n\n          onStart: specStarted,\n          description,\n          queueRunnerFactory,\n\n          userContext() {\n            return suite.clonedSharedUserContext();\n          },\n\n          queueableFn: {\n            fn,\n\n            timeout() {\n              return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n            }\n\n          },\n          throwOnExpectationFailure\n        });\n\n        if (!this.specFilter(spec)) {\n          spec.disable();\n        }\n\n        return spec;\n\n        function specResultCallback(result) {\n          clearResourcesForRunnable(spec.id);\n          currentSpec = null;\n          reporter.specDone(result);\n        }\n\n        function specStarted(spec) {\n          currentSpec = spec;\n          defaultResourcesForRunnable(spec.id, suite.id);\n          reporter.specStarted(spec.result);\n        }\n      };\n\n      this.it = function (description, fn, timeout) {\n        if (typeof description !== 'string') {\n          throw new Error(\"Invalid first argument, \".concat(description, \". It must be a string.\"));\n        }\n\n        if (fn === undefined) {\n          throw new Error('Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.');\n        }\n\n        if (typeof fn !== 'function') {\n          throw new Error(\"Invalid second argument, \".concat(fn, \". It must be a callback function.\"));\n        }\n\n        const spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n\n        if (currentDeclarationSuite.markedPending) {\n          spec.pend();\n        } // When a test is defined inside another, jasmine will not run it.\n        // This check throws an error to warn the user about the edge-case.\n\n\n        if (currentSpec !== null) {\n          throw new Error('Tests cannot be nested. Test `' + spec.description + '` cannot run because it is nested within `' + currentSpec.description + '`.');\n        }\n\n        currentDeclarationSuite.addChild(spec);\n        return spec;\n      };\n\n      this.xit = function (...args) {\n        const spec = this.it.apply(this, args);\n        spec.pend('Temporarily disabled with xit');\n        return spec;\n      };\n\n      this.todo = function () {\n        const description = arguments[0];\n\n        if (arguments.length !== 1 || typeof description !== 'string') {\n          throw new _jestUtil.ErrorWithStack('Todo must be called with only a description.', test.todo);\n        }\n\n        const spec = specFactory(description, () => {}, currentDeclarationSuite);\n        spec.todo();\n        currentDeclarationSuite.addChild(spec);\n        return spec;\n      };\n\n      this.fit = function (description, fn, timeout) {\n        const spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n        currentDeclarationSuite.addChild(spec);\n        focusedRunnables.push(spec.id);\n        unfocusAncestor();\n        return spec;\n      };\n\n      this.beforeEach = function (beforeEachFunction, timeout) {\n        currentDeclarationSuite.beforeEach({\n          fn: beforeEachFunction,\n\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n\n        });\n      };\n\n      this.beforeAll = function (beforeAllFunction, timeout) {\n        currentDeclarationSuite.beforeAll({\n          fn: beforeAllFunction,\n\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n\n        });\n      };\n\n      this.afterEach = function (afterEachFunction, timeout) {\n        currentDeclarationSuite.afterEach({\n          fn: afterEachFunction,\n\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n\n        });\n      };\n\n      this.afterAll = function (afterAllFunction, timeout) {\n        currentDeclarationSuite.afterAll({\n          fn: afterAllFunction,\n\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n\n        });\n      };\n\n      this.pending = function (message) {\n        let fullMessage = j$.Spec.pendingSpecExceptionMessage;\n\n        if (message) {\n          fullMessage += message;\n        }\n\n        throw fullMessage;\n      };\n\n      this.fail = function (error) {\n        let checkIsError;\n        let message;\n\n        if (error instanceof _assert.AssertionError || error && error.name === _assert.AssertionError.name) {\n          checkIsError = false; // @ts-ignore TODO Possible error: j$.Spec does not have expand property\n\n          message = (0, _assertionErrorMessage.default)(error, {\n            expand: j$.Spec.expand\n          });\n        } else {\n          const check = (0, _isError.default)(error);\n          checkIsError = check.isError;\n          message = check.message;\n        }\n\n        const errorAsErrorObject = checkIsError ? error : new Error(message);\n        const runnable = currentRunnable();\n\n        if (!runnable) {\n          errorAsErrorObject.message = 'Caught error after test environment was torn down\\n\\n' + errorAsErrorObject.message;\n          throw errorAsErrorObject;\n        }\n\n        runnable.addExpectationResult(false, {\n          matcherName: '',\n          passed: false,\n          expected: '',\n          actual: '',\n          message,\n          error: errorAsErrorObject\n        });\n      };\n    }\n\n  }, _temp;\n}","map":null,"metadata":{},"sourceType":"script"}