{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = treeProcessor;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction treeProcessor(options) {\n  const nodeComplete = options.nodeComplete,\n        nodeStart = options.nodeStart,\n        queueRunnerFactory = options.queueRunnerFactory,\n        runnableIds = options.runnableIds,\n        tree = options.tree;\n\n  function isEnabled(node, parentEnabled) {\n    return parentEnabled || runnableIds.indexOf(node.id) !== -1;\n  }\n\n  function getNodeHandler(node, parentEnabled) {\n    const enabled = isEnabled(node, parentEnabled);\n    return node.children ? getNodeWithChildrenHandler(node, enabled) : getNodeWithoutChildrenHandler(node, enabled);\n  }\n\n  function getNodeWithoutChildrenHandler(node, enabled) {\n    return function fn(done = () => {}) {\n      node.execute(done, enabled);\n    };\n  }\n\n  function getNodeWithChildrenHandler(node, enabled) {\n    return (\n      /*#__PURE__*/\n      function () {\n        var _fn = _asyncToGenerator(function* (done = () => {}) {\n          nodeStart(node);\n          yield queueRunnerFactory({\n            onException: error => node.onException(error),\n            queueableFns: wrapChildren(node, enabled),\n            userContext: node.sharedUserContext()\n          });\n          nodeComplete(node);\n          done();\n        });\n\n        function fn() {\n          return _fn.apply(this, arguments);\n        }\n\n        return fn;\n      }()\n    );\n  }\n\n  function hasEnabledTest(node) {\n    if (node.children) {\n      return node.children.some(hasEnabledTest);\n    }\n\n    return !node.disabled;\n  }\n\n  function wrapChildren(node, enabled) {\n    if (!node.children) {\n      throw new Error('`node.children` is not defined.');\n    }\n\n    const children = node.children.map(child => ({\n      fn: getNodeHandler(child, enabled)\n    }));\n\n    if (!hasEnabledTest(node)) {\n      return children;\n    }\n\n    return node.beforeAllFns.concat(children).concat(node.afterAllFns);\n  }\n\n  const treeHandler = getNodeHandler(tree, false);\n  return treeHandler();\n}","map":null,"metadata":{},"sourceType":"script"}