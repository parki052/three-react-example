{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _base_reporter = _interopRequireDefault(require('./base_reporter'));\n\nvar _Status = _interopRequireDefault(require('./Status'));\n\nvar _get_result_header = _interopRequireDefault(require('./get_result_header'));\n\nvar _get_snapshot_status = _interopRequireDefault(require('./get_snapshot_status'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst TITLE_BULLET = _chalk().default.bold('\\u25cf ');\n\nclass DefaultReporter extends _base_reporter.default {\n  // ANSI clear sequence for the last printed status\n  constructor(globalConfig) {\n    super();\n\n    _defineProperty(this, '_clear', void 0);\n\n    _defineProperty(this, '_err', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_out', void 0);\n\n    _defineProperty(this, '_status', void 0);\n\n    _defineProperty(this, '_bufferedOutput', void 0);\n\n    this._globalConfig = globalConfig;\n    this._clear = '';\n    this._out = process.stdout.write.bind(process.stdout);\n    this._err = process.stderr.write.bind(process.stderr);\n    this._status = new _Status.default();\n    this._bufferedOutput = new Set();\n\n    this._wrapStdio(process.stdout);\n\n    this._wrapStdio(process.stderr);\n\n    this._status.onChange(() => {\n      this._clearStatus();\n\n      this._printStatus();\n    });\n  }\n\n  _wrapStdio(stream) {\n    const originalWrite = stream.write;\n    let buffer = [];\n    let timeout = null;\n\n    const flushBufferedOutput = () => {\n      const string = buffer.join('');\n      buffer = []; // This is to avoid conflicts between random output and status text\n\n      this._clearStatus();\n\n      if (string) {\n        originalWrite.call(stream, string);\n      }\n\n      this._printStatus();\n\n      this._bufferedOutput.delete(flushBufferedOutput);\n    };\n\n    this._bufferedOutput.add(flushBufferedOutput);\n\n    const debouncedFlush = () => {\n      // If the process blows up no errors would be printed.\n      // There should be a smart way to buffer stderr, but for now\n      // we just won't buffer it.\n      if (stream === process.stderr) {\n        flushBufferedOutput();\n      } else {\n        if (!timeout) {\n          timeout = setTimeout(() => {\n            flushBufferedOutput();\n            timeout = null;\n          }, 100);\n        }\n      }\n    };\n\n    stream.write = chunk => {\n      buffer.push(chunk);\n      debouncedFlush();\n      return true;\n    };\n  } // Don't wait for the debounced call and flush all output immediately.\n\n\n  forceFlushBufferedOutput() {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = this._bufferedOutput[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const flushBufferedOutput = _step.value;\n        flushBufferedOutput();\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  _clearStatus() {\n    if (_jestUtil().isInteractive) {\n      if (this._globalConfig.useStderr) {\n        this._err(this._clear);\n      } else {\n        this._out(this._clear);\n      }\n    }\n  }\n\n  _printStatus() {\n    const _this$_status$get = this._status.get(),\n          content = _this$_status$get.content,\n          clear = _this$_status$get.clear;\n\n    this._clear = clear;\n\n    if (_jestUtil().isInteractive) {\n      if (this._globalConfig.useStderr) {\n        this._err(content);\n      } else {\n        this._out(content);\n      }\n    }\n  }\n\n  onRunStart(aggregatedResults, options) {\n    this._status.runStarted(aggregatedResults, options);\n  }\n\n  onTestStart(test) {\n    this._status.testStarted(test.path, test.context.config);\n  }\n\n  onRunComplete() {\n    this.forceFlushBufferedOutput();\n\n    this._status.runFinished();\n\n    process.stdout.write = this._out;\n    process.stderr.write = this._err;\n    (0, _jestUtil().clearLine)(process.stderr);\n  }\n\n  onTestResult(test, testResult, aggregatedResults) {\n    this.testFinished(test.context.config, testResult, aggregatedResults);\n\n    if (!testResult.skipped) {\n      this.printTestFileHeader(testResult.testFilePath, test.context.config, testResult);\n      this.printTestFileFailureMessage(testResult.testFilePath, test.context.config, testResult);\n    }\n\n    this.forceFlushBufferedOutput();\n  }\n\n  testFinished(config, testResult, aggregatedResults) {\n    this._status.testFinished(config, testResult, aggregatedResults);\n  }\n\n  printTestFileHeader(_testPath, config, result) {\n    this.log((0, _get_result_header.default)(result, this._globalConfig, config));\n\n    if (result.console) {\n      this.log('  ' + TITLE_BULLET + 'Console\\n\\n' + (0, _jestUtil().getConsoleOutput)(config.cwd, !!this._globalConfig.verbose, result.console));\n    }\n  }\n\n  printTestFileFailureMessage(_testPath, _config, result) {\n    if (result.failureMessage) {\n      this.log(result.failureMessage);\n    }\n\n    const didUpdate = this._globalConfig.updateSnapshot === 'all';\n    const snapshotStatuses = (0, _get_snapshot_status.default)(result.snapshot, didUpdate);\n    snapshotStatuses.forEach(this.log);\n  }\n\n}\n\nexports.default = DefaultReporter;","map":null,"metadata":{},"sourceType":"script"}