{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = collectHandles;\nexports.formatHandleErrors = formatHandleErrors;\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stripAnsi() {\n  const data = _interopRequireDefault(require('strip-ansi'));\n\n  _stripAnsi = function _stripAnsi() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction stackIsFromUser(stack) {\n  // Either the test file, or something required by it\n  if (stack.includes('Runtime.requireModule')) {\n    return true;\n  } // jest-jasmine it or describe call\n\n\n  if (stack.includes('asyncJestTest') || stack.includes('asyncJestLifecycle')) {\n    return true;\n  } // An async function call from within circus\n\n\n  if (stack.includes('callAsyncCircusFn')) {\n    // jest-circus it or describe call\n    return stack.includes('_callCircusTest') || stack.includes('_callCircusHook');\n  }\n\n  return false;\n} // Inspired by https://github.com/mafintosh/why-is-node-running/blob/master/index.js\n// Extracted as we want to format the result ourselves\n\n\nfunction collectHandles() {\n  const activeHandles = new Map();\n  let hook;\n\n  try {\n    const asyncHooks = require('async_hooks');\n\n    hook = asyncHooks.createHook({\n      destroy(asyncId) {\n        activeHandles.delete(asyncId);\n      },\n\n      init: function initHook(asyncId, type) {\n        if (type === 'PROMISE' || type === 'TIMERWRAP') {\n          return;\n        }\n\n        const error = new (_jestUtil().ErrorWithStack)(type, initHook);\n\n        if (stackIsFromUser(error.stack || '')) {\n          activeHandles.set(asyncId, error);\n        }\n      }\n    });\n    hook.enable();\n  } catch (e) {\n    const nodeMajor = Number(process.versions.node.split('.')[0]);\n\n    if (e.code === 'MODULE_NOT_FOUND' && nodeMajor < 8) {\n      throw new Error('You can only use --detectOpenHandles on Node 8 and newer.');\n    } else {\n      throw e;\n    }\n  }\n\n  return () => {\n    hook.disable();\n    const result = Array.from(activeHandles.values());\n    activeHandles.clear();\n    return result;\n  };\n}\n\nfunction formatHandleErrors(errors, config) {\n  const stacks = new Set();\n  return errors.map(err => (0, _jestMessageUtil().formatExecError)(err, config, {\n    noStackTrace: false\n  }, undefined, true)) // E.g. timeouts might give multiple traces to the same line of code\n  // This hairy filtering tries to remove entries with duplicate stack traces\n  .filter(handle => {\n    const ansiFree = (0, _stripAnsi().default)(handle);\n    const match = ansiFree.match(/\\s+at(.*)/);\n\n    if (!match || match.length < 2) {\n      return true;\n    }\n\n    const stack = ansiFree.substr(ansiFree.indexOf(match[1])).trim();\n\n    if (stacks.has(stack)) {\n      return false;\n    }\n\n    stacks.add(stack);\n    return true;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}