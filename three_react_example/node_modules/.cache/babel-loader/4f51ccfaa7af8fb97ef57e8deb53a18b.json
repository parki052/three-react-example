{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function _micromatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass HasteFS {\n  constructor({\n    rootDir,\n    files\n  }) {\n    _defineProperty(this, '_rootDir', void 0);\n\n    _defineProperty(this, '_files', void 0);\n\n    this._rootDir = rootDir;\n    this._files = files;\n  }\n\n  getModuleName(file) {\n    const fileMetadata = this._getFileData(file);\n\n    return fileMetadata && fileMetadata[_constants.default.ID] || null;\n  }\n\n  getSize(file) {\n    const fileMetadata = this._getFileData(file);\n\n    return fileMetadata && fileMetadata[_constants.default.SIZE] || null;\n  }\n\n  getDependencies(file) {\n    const fileMetadata = this._getFileData(file);\n\n    if (fileMetadata) {\n      return fileMetadata[_constants.default.DEPENDENCIES] ? fileMetadata[_constants.default.DEPENDENCIES].split(_constants.default.DEPENDENCY_DELIM) : [];\n    } else {\n      return null;\n    }\n  }\n\n  getSha1(file) {\n    const fileMetadata = this._getFileData(file);\n\n    return fileMetadata && fileMetadata[_constants.default.SHA1] || null;\n  }\n\n  exists(file) {\n    return this._getFileData(file) != null;\n  }\n\n  getAllFiles() {\n    return Array.from(this.getAbsoluteFileIterator());\n  }\n\n  getFileIterator() {\n    return this._files.keys();\n  }\n\n  *getAbsoluteFileIterator() {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = this.getFileIterator()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const file = _step.value;\n        yield fastPath.resolve(this._rootDir, file);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  matchFiles(pattern) {\n    if (!(pattern instanceof RegExp)) {\n      pattern = new RegExp(pattern);\n    }\n\n    const files = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = this.getAbsoluteFileIterator()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        const file = _step2.value;\n\n        if (pattern.test(file)) {\n          files.push(file);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return files;\n  }\n\n  matchFilesWithGlob(globs, root) {\n    const files = new Set();\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = this.getAbsoluteFileIterator()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        const file = _step3.value;\n        const filePath = root ? fastPath.relative(root, file) : file;\n\n        if (_micromatch().default.some((0, _jestUtil().replacePathSepForGlob)(filePath), globs)) {\n          files.add(file);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    return files;\n  }\n\n  _getFileData(file) {\n    const relativePath = fastPath.relative(this._rootDir, file);\n    return this._files.get(relativePath);\n  }\n\n}\n\nexports.default = HasteFS;","map":null,"metadata":{},"sourceType":"script"}