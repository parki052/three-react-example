{"ast":null,"code":"'use strict';\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function _core() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function _slash() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst THIS_FILE = _fs().default.readFileSync(__filename);\n\nconst jestPresetPath = require.resolve('babel-preset-jest');\n\nconst babelIstanbulPlugin = require.resolve('babel-plugin-istanbul'); // Narrow down the types\n\n\nconst createTransformer = (options = {}) => {\n  options = _objectSpread({}, options, {\n    caller: {\n      name: 'babel-jest',\n      supportsStaticESM: false\n    },\n    compact: false,\n    plugins: options && options.plugins || [],\n    presets: (options && options.presets || []).concat(jestPresetPath),\n    sourceMaps: 'both'\n  });\n\n  function loadBabelConfig(cwd, filename) {\n    // `cwd` first to allow incoming options to override it\n    const babelConfig = (0, _core().loadPartialConfig)(_objectSpread({\n      cwd\n    }, options, {\n      filename\n    }));\n\n    if (!babelConfig) {\n      throw new Error(\"babel-jest: Babel ignores \".concat(_chalk().default.bold((0, _slash().default)(_path().default.relative(cwd, filename))), \" - make sure to include the file in Jest's \").concat(_chalk().default.bold('transformIgnorePatterns'), \" as well.\"));\n    }\n\n    return babelConfig;\n  }\n\n  return {\n    canInstrument: true,\n\n    getCacheKey(fileData, filename, configString, {\n      config,\n      instrument,\n      rootDir\n    }) {\n      const babelOptions = loadBabelConfig(config.cwd, filename);\n      const configPath = [babelOptions.config || '', babelOptions.babelrc || ''];\n      return _crypto().default.createHash('md5').update(THIS_FILE).update('\\0', 'utf8').update(JSON.stringify(babelOptions.options)).update('\\0', 'utf8').update(fileData).update('\\0', 'utf8').update(_path().default.relative(rootDir, filename)).update('\\0', 'utf8').update(configString).update('\\0', 'utf8').update(configPath.join('')).update('\\0', 'utf8').update(instrument ? 'instrument' : '').update('\\0', 'utf8').update(process.env.NODE_ENV || '').update('\\0', 'utf8').update(process.env.BABEL_ENV || '').digest('hex');\n    },\n\n    process(src, filename, config, transformOptions) {\n      const babelOptions = _objectSpread({}, loadBabelConfig(config.cwd, filename).options);\n\n      if (transformOptions && transformOptions.instrument) {\n        babelOptions.auxiliaryCommentBefore = ' istanbul ignore next '; // Copied from jest-runtime transform.js\n\n        babelOptions.plugins = (babelOptions.plugins || []).concat([[babelIstanbulPlugin, {\n          // files outside `cwd` will not be instrumented\n          cwd: config.rootDir,\n          exclude: []\n        }]]);\n      }\n\n      const transformResult = (0, _core().transformSync)(src, babelOptions);\n\n      if (transformResult) {\n        const code = transformResult.code,\n              map = transformResult.map;\n\n        if (typeof code === 'string') {\n          return {\n            code,\n            map\n          };\n        }\n      }\n\n      return src;\n    }\n\n  };\n};\n\nconst transformer = _objectSpread({}, createTransformer(), {\n  // Assigned here so only the exported transformer has `createTransformer`,\n  // instead of all created transformers by the function\n  createTransformer\n});\n\nmodule.exports = transformer;","map":null,"metadata":{},"sourceType":"script"}