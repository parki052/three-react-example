{"ast":null,"code":"'use strict';\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * DependencyResolver is used to resolve the direct dependencies of a module or\n * to retrieve a list of all transitive inverse dependencies.\n */\n\n/* eslint-disable-next-line no-redeclare */\n\n\nclass DependencyResolver {\n  constructor(resolver, hasteFS, snapshotResolver) {\n    _defineProperty(this, '_hasteFS', void 0);\n\n    _defineProperty(this, '_resolver', void 0);\n\n    _defineProperty(this, '_snapshotResolver', void 0);\n\n    this._resolver = resolver;\n    this._hasteFS = hasteFS;\n    this._snapshotResolver = snapshotResolver;\n  }\n\n  resolve(file, options) {\n    const dependencies = this._hasteFS.getDependencies(file);\n\n    if (!dependencies) {\n      return [];\n    }\n\n    return dependencies.reduce((acc, dependency) => {\n      if (this._resolver.isCoreModule(dependency)) {\n        return acc;\n      }\n\n      let resolvedDependency;\n\n      try {\n        resolvedDependency = this._resolver.resolveModule(file, dependency, options);\n      } catch (e) {\n        resolvedDependency = this._resolver.getMockModule(file, dependency);\n      }\n\n      if (resolvedDependency) {\n        acc.push(resolvedDependency);\n      }\n\n      return acc;\n    }, []);\n  }\n\n  resolveInverseModuleMap(paths, filter, options) {\n    if (!paths.size) {\n      return [];\n    }\n\n    const collectModules = (related, moduleMap, changed) => {\n      const visitedModules = new Set();\n      const result = [];\n\n      while (changed.size) {\n        changed = new Set(moduleMap.reduce((acc, module) => {\n          if (visitedModules.has(module.file) || !module.dependencies.some(dep => changed.has(dep))) {\n            return acc;\n          }\n\n          const file = module.file;\n\n          if (filter(file)) {\n            result.push(module);\n            related.delete(file);\n          }\n\n          visitedModules.add(file);\n          acc.push(file);\n          return acc;\n        }, []));\n      }\n\n      return result.concat(Array.from(related).map(file => ({\n        dependencies: [],\n        file\n      })));\n    };\n\n    const relatedPaths = new Set();\n    const changed = new Set();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const path = _step.value;\n\n        if (this._hasteFS.exists(path)) {\n          const modulePath = (0, _jestSnapshot().isSnapshotPath)(path) ? this._snapshotResolver.resolveTestPath(path) : path;\n          changed.add(modulePath);\n\n          if (filter(modulePath)) {\n            relatedPaths.add(modulePath);\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    const modules = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = this._hasteFS.getAbsoluteFileIterator()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        const file = _step2.value;\n        modules.push({\n          dependencies: this.resolve(file, options),\n          file\n        });\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return collectModules(relatedPaths, modules, changed);\n  }\n\n  resolveInverse(paths, filter, options) {\n    return this.resolveInverseModuleMap(paths, filter, options).map(module => module.file);\n  }\n\n}\n\nmodule.exports = DependencyResolver;","map":null,"metadata":{},"sourceType":"script"}