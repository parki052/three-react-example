{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.setup = setup;\nexports.worker = worker;\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function _jestHasteMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function _exit() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRuntime() {\n  const data = _interopRequireDefault(require('jest-runtime'));\n\n  _jestRuntime = function _jestRuntime() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _runTest = _interopRequireDefault(require('./runTest'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n} // Make sure uncaught errors are logged before we exit.\n\n\nprocess.on('uncaughtException', err => {\n  console.error(err.stack);\n  (0, _exit().default)(1);\n});\n\nconst formatError = error => {\n  if (typeof error === 'string') {\n    const _separateMessageFromS = (0, _jestMessageUtil().separateMessageFromStack)(error),\n          message = _separateMessageFromS.message,\n          stack = _separateMessageFromS.stack;\n\n    return {\n      message,\n      stack,\n      type: 'Error'\n    };\n  }\n\n  return {\n    code: error.code || undefined,\n    message: error.message,\n    stack: error.stack,\n    type: 'Error'\n  };\n};\n\nconst resolvers = new Map();\n\nconst getResolver = config => {\n  const resolver = resolvers.get(config.name);\n\n  if (!resolver) {\n    throw new Error('Cannot find resolver for: ' + config.name);\n  }\n\n  return resolver;\n};\n\nfunction setup(setupData) {\n  // Module maps that will be needed for the test runs are passed.\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = setupData.serializableResolvers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      const _step$value = _step.value,\n            config = _step$value.config,\n            serializableModuleMap = _step$value.serializableModuleMap;\n\n      const moduleMap = _jestHasteMap().default.ModuleMap.fromJSON(serializableModuleMap);\n\n      resolvers.set(config.name, _jestRuntime().default.createResolver(config, moduleMap));\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction worker(_x) {\n  return _worker.apply(this, arguments);\n}\n\nfunction _worker() {\n  _worker = _asyncToGenerator(function* ({\n    config,\n    globalConfig,\n    path,\n    context\n  }) {\n    try {\n      return yield (0, _runTest.default)(path, globalConfig, config, getResolver(config), context && _objectSpread({}, context, {\n        changedFiles: context.changedFiles && new Set(context.changedFiles)\n      }));\n    } catch (error) {\n      throw formatError(error);\n    }\n  });\n  return _worker.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}