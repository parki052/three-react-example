{"ast":null,"code":"'use strict';\n\nconst execa = require('execa');\n\nconst _require = require('fs'),\n      statSync = _require.statSync;\n\nconst path = require('path');\n\nconst common = require('./common');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst _require2 = require('os'),\n      EOL = _require2.EOL;\n/**\n * Constants\n */\n\n\nconst CHANGE_EVENT = common.CHANGE_EVENT;\nconst DELETE_EVENT = common.DELETE_EVENT;\nconst ADD_EVENT = common.ADD_EVENT;\nconst ALL_EVENT = common.ALL_EVENT;\nconst typeMap = {\n  rename: CHANGE_EVENT,\n  write: CHANGE_EVENT,\n  remove: DELETE_EVENT,\n  create: ADD_EVENT\n};\nconst messageRegexp = /(rename|write|remove|create)\\s(.+)/;\n/**\n * Manages streams from subprocess and turns into sane events\n *\n * @param {Stream} data\n * @private\n */\n\nfunction _messageHandler(data) {\n  data.toString().split(EOL).filter(str => str.trim().length).filter(str => messageRegexp.test(str)).map(line => {\n    const _ref = [...line.match(messageRegexp)],\n          command = _ref[1],\n          path = _ref[2];\n    return [command, path];\n  }).forEach(([command, file]) => {\n    let stat;\n    const type = typeMap[command];\n\n    if (type === DELETE_EVENT) {\n      stat = null;\n    } else {\n      try {\n        stat = statSync(file);\n      } catch (e) {\n        // There is likely a delete coming down the pipe.\n        if (e.code === 'ENOENT') {\n          return;\n        }\n\n        throw e;\n      }\n    }\n\n    this.emitEvent(type, path.relative(this.root, file), stat);\n  });\n}\n/**\n * Export `WatchexecWatcher` class.\n * Watches `dir`.\n *\n * @class WatchexecWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\n\nclass WatchexecWatcher extends EventEmitter {\n  constructor(dir, opts) {\n    super();\n    common.assignOptions(this, opts);\n    this.root = path.resolve(dir);\n    this._process = execa('watchexec', ['-n', '--', 'node', __dirname + '/watchexec_client.js'], {\n      cwd: dir\n    });\n\n    this._process.stdout.on('data', _messageHandler.bind(this));\n\n    this._readyTimer = setTimeout(this.emit.bind(this, 'ready'), 1000);\n  }\n\n  close(callback) {\n    clearTimeout(this._readyTimer);\n    this.removeAllListeners();\n    this._process && !this._process.killed && this._process.kill();\n\n    if (typeof callback === 'function') {\n      setImmediate(callback.bind(null, null, true));\n    }\n  }\n  /**\n   * Transform and emit an event comming from the poller.\n   *\n   * @param {EventEmitter} monitor\n   * @public\n   */\n\n\n  emitEvent(type, file, stat) {\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n\n}\n\nWatchexecWatcher._messageHandler = _messageHandler;\nmodule.exports = WatchexecWatcher;","map":null,"metadata":{},"sourceType":"script"}