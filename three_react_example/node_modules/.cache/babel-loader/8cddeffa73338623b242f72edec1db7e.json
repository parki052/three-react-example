{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.runCLI = void 0;\n\nfunction _console() {\n  const data = require('@jest/console');\n\n  _console = function _console() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function _jestConfig() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRuntime() {\n  const data = _interopRequireDefault(require('jest-runtime'));\n\n  _jestRuntime = function _jestRuntime() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _rimraf() {\n  const data = _interopRequireDefault(require('rimraf'));\n\n  _rimraf = function _rimraf() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function _exit() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _create_context = _interopRequireDefault(require('../lib/create_context'));\n\nvar _getChangedFilesPromise = _interopRequireDefault(require('../getChangedFilesPromise'));\n\nvar _collectHandles = require('../collectHandles');\n\nvar _handle_deprecation_warnings = _interopRequireDefault(require('../lib/handle_deprecation_warnings'));\n\nvar _runJest = _interopRequireDefault(require('../runJest'));\n\nvar _TestWatcher = _interopRequireDefault(require('../TestWatcher'));\n\nvar _watch = _interopRequireDefault(require('../watch'));\n\nvar _pluralize = _interopRequireDefault(require('../pluralize'));\n\nvar _log_debug_messages = _interopRequireDefault(require('../lib/log_debug_messages'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst preRunMessagePrint = _jestUtil().preRunMessage.print;\n\nconst runCLI =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(function* (argv, projects) {\n    const realFs = require('fs');\n\n    const fs = require('graceful-fs');\n\n    fs.gracefulify(realFs);\n    let results; // If we output a JSON object, we can't write anything to stdout, since\n    // it'll break the JSON structure and it won't be valid.\n\n    const outputStream = argv.json || argv.useStderr ? process.stderr : process.stdout;\n\n    const _readConfigs = (0, _jestConfig().readConfigs)(argv, projects),\n          globalConfig = _readConfigs.globalConfig,\n          configs = _readConfigs.configs,\n          hasDeprecationWarnings = _readConfigs.hasDeprecationWarnings;\n\n    if (argv.debug) {\n      (0, _log_debug_messages.default)(globalConfig, configs, outputStream);\n    }\n\n    if (argv.showConfig) {\n      (0, _log_debug_messages.default)(globalConfig, configs, process.stdout);\n      (0, _exit().default)(0);\n    }\n\n    if (argv.clearCache) {\n      configs.forEach(config => {\n        _rimraf().default.sync(config.cacheDirectory);\n\n        process.stdout.write(\"Cleared \".concat(config.cacheDirectory, \"\\n\"));\n      });\n      (0, _exit().default)(0);\n    }\n\n    yield _run(globalConfig, configs, hasDeprecationWarnings, outputStream, r => results = r);\n\n    if (argv.watch || argv.watchAll) {\n      // If in watch mode, return the promise that will never resolve.\n      // If the watch mode is interrupted, watch should handle the process\n      // shutdown.\n      return new Promise(() => {});\n    }\n\n    if (!results) {\n      throw new Error('AggregatedResult must be present after test run is complete');\n    }\n\n    const _results = results,\n          openHandles = _results.openHandles;\n\n    if (openHandles && openHandles.length) {\n      const formatted = (0, _collectHandles.formatHandleErrors)(openHandles, configs[0]);\n      const openHandlesString = (0, _pluralize.default)('open handle', formatted.length, 's');\n      const message = _chalk().default.red(\"\\nJest has detected the following \".concat(openHandlesString, \" potentially keeping Jest from exiting:\\n\\n\")) + formatted.join('\\n\\n');\n      console.error(message);\n    }\n\n    return {\n      globalConfig,\n      results\n    };\n  });\n\n  return function runCLI(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.runCLI = runCLI;\n\nconst buildContextsAndHasteMaps =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(function* (configs, globalConfig, outputStream) {\n    const hasteMapInstances = Array(configs.length);\n    const contexts = yield Promise.all(configs.map(\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(function* (config, index) {\n        (0, _jestUtil().createDirectory)(config.cacheDirectory);\n\n        const hasteMapInstance = _jestRuntime().default.createHasteMap(config, {\n          console: new (_console().CustomConsole)(outputStream, outputStream),\n          maxWorkers: globalConfig.maxWorkers,\n          resetCache: !config.cache,\n          watch: globalConfig.watch || globalConfig.watchAll,\n          watchman: globalConfig.watchman\n        });\n\n        hasteMapInstances[index] = hasteMapInstance;\n        return (0, _create_context.default)(config, (yield hasteMapInstance.build()));\n      });\n\n      return function (_x6, _x7) {\n        return _ref3.apply(this, arguments);\n      };\n    }()));\n    return {\n      contexts,\n      hasteMapInstances\n    };\n  });\n\n  return function buildContextsAndHasteMaps(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst _run =\n/*#__PURE__*/\nfunction () {\n  var _ref4 = _asyncToGenerator(function* (globalConfig, configs, hasDeprecationWarnings, outputStream, onComplete) {\n    // Queries to hg/git can take a while, so we need to start the process\n    // as soon as possible, so by the time we need the result it's already there.\n    const changedFilesPromise = (0, _getChangedFilesPromise.default)(globalConfig, configs); // Filter may need to do an HTTP call or something similar to setup.\n    // We will wait on an async response from this before using the filter.\n\n    let filter;\n\n    if (globalConfig.filter && !globalConfig.skipFilter) {\n      const rawFilter = require(globalConfig.filter);\n\n      let filterSetupPromise;\n\n      if (rawFilter.setup) {\n        // Wrap filter setup Promise to avoid \"uncaught Promise\" error.\n        // If an error is returned, we surface it in the return value.\n        filterSetupPromise = _asyncToGenerator(function* () {\n          try {\n            yield rawFilter.setup();\n          } catch (err) {\n            return err;\n          }\n\n          return undefined;\n        })();\n      }\n\n      filter =\n      /*#__PURE__*/\n      function () {\n        var _ref6 = _asyncToGenerator(function* (testPaths) {\n          if (filterSetupPromise) {\n            // Expect an undefined return value unless there was an error.\n            const err = yield filterSetupPromise;\n\n            if (err) {\n              throw err;\n            }\n          }\n\n          return rawFilter(testPaths);\n        });\n\n        return function filter(_x13) {\n          return _ref6.apply(this, arguments);\n        };\n      }();\n    }\n\n    const _ref7 = yield buildContextsAndHasteMaps(configs, globalConfig, outputStream),\n          contexts = _ref7.contexts,\n          hasteMapInstances = _ref7.hasteMapInstances;\n\n    globalConfig.watch || globalConfig.watchAll ? yield runWatch(contexts, configs, hasDeprecationWarnings, globalConfig, outputStream, hasteMapInstances, filter) : yield runWithoutWatch(globalConfig, contexts, outputStream, onComplete, changedFilesPromise, filter);\n  });\n\n  return function _run(_x8, _x9, _x10, _x11, _x12) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nconst runWatch =\n/*#__PURE__*/\nfunction () {\n  var _ref8 = _asyncToGenerator(function* (contexts, _configs, hasDeprecationWarnings, globalConfig, outputStream, hasteMapInstances, filter) {\n    if (hasDeprecationWarnings) {\n      try {\n        yield (0, _handle_deprecation_warnings.default)(outputStream, process.stdin);\n        return (0, _watch.default)(globalConfig, contexts, outputStream, hasteMapInstances, undefined, undefined, filter);\n      } catch (e) {\n        (0, _exit().default)(0);\n      }\n    }\n\n    return (0, _watch.default)(globalConfig, contexts, outputStream, hasteMapInstances, undefined, undefined, filter);\n  });\n\n  return function runWatch(_x14, _x15, _x16, _x17, _x18, _x19, _x20) {\n    return _ref8.apply(this, arguments);\n  };\n}();\n\nconst runWithoutWatch =\n/*#__PURE__*/\nfunction () {\n  var _ref9 = _asyncToGenerator(function* (globalConfig, contexts, outputStream, onComplete, changedFilesPromise, filter) {\n    const startRun =\n    /*#__PURE__*/\n    function () {\n      var _ref10 = _asyncToGenerator(function* () {\n        if (!globalConfig.listTests) {\n          preRunMessagePrint(outputStream);\n        }\n\n        return (0, _runJest.default)({\n          changedFilesPromise,\n          contexts,\n          failedTestsCache: undefined,\n          filter,\n          globalConfig,\n          onComplete,\n          outputStream,\n          startRun,\n          testWatcher: new _TestWatcher.default({\n            isWatchMode: false\n          })\n        });\n      });\n\n      return function startRun() {\n        return _ref10.apply(this, arguments);\n      };\n    }();\n\n    return startRun();\n  });\n\n  return function runWithoutWatch(_x21, _x22, _x23, _x24, _x25, _x26) {\n    return _ref9.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}